# Lezione 02
###### Definizione - Linguaggi Regolari
$$REG=\{L\subseteq\Sigma^{*}: \exists \text{ DFA }M\ \text{tale che } L(M)=L\}$$
Quindi contiene tutti i linguaggi che il DFA riconosce.

Vogliamo cpaire come progettare un DFA per un dato linguaggio.

Esempio: $$L=\Big\{x\in\{0,1 \}^{*}:x={1||y},\ y\in \{0,1 \}^{*}\Big\}$$
dove $||$ è l'operatore di concatenazione ("$1$ concatenato $y$")
convenzione, non serve mettere la delta con lo stato pozzo

Prova di correttezza:
DFA accetta $x$ se e solo se $x\in L$.
Osserviamo che $\delta^{*}(q_{1},u)=q_{1}\ \forall u\in\{0,1\}^{*}$
$\delta^{*}(q_{2},u)=q_{2}\ \forall u\in\{0,1\}^{*}$

Per induzione dimostriamo $x\in L$ se e solo se il DFA accetta $x.$

Caso base: $|x|=0.$ Se $x=\mathcal{E}$, $(\delta^{*},q_{0},\mathcal{E})=\delta(q_{0},\mathcal{E})=q_{0}\notin F.$

Passo induttivo: Sia $M>0.$ Supponiamo che $|W|<M$

$\delta^{*}(q_{0},w)=\begin{cases}q_{0} & \text{se } W=\mathcal{E}\\ q_{1} & \text{se }W \text{ inizia con 1}\\ q_{2} & \text{se }W \text{ inizia con 0} \end{cases}$

Prendo $x$ tale che $|x|$ tale che $|x|=n+1$ e lo passo

$x=au$ con $a\in\{0,1 \}\longrightarrow$ il primo carattere
$u\in\{0,1 \}^{n}\longrightarrow$ tutto il resto di caratteri in $n$

$\delta^{*}(q_{0},x)=\delta^{*}(q_{0},au)=\delta^{*}(\delta(q_{0},a)x)$

$\delta(q_0,a)=q_{2}$ se $a=0$
$\delta(q_{0},a)=q_{1}$ se $a=1$
$\implies \delta^{*}(q_{0},x)=q_{1}$ se e solo se $a=1.\quad \blacksquare$

Esercizi
$L=\{x\in \{0,1 \}^{*} \text{ tale che } w_{H}(x) \ge 3\}$
dove $w_{H}(x)=\#1$ in $x\in\{0,1 \}^{*}$

$L=\{x\in\{0,1 \}^{*}: x=0^{n} \text{ con }n\in N \}.$

### Operazioni sui Linguaggi
Fissiamo $\Sigma=\{0,1\}.$ Per $n\in\mathbb{N},[n]=\{1,2,...n \}$

Siccome i linguaggi sono insiemi di stringhe posso considerare su di essi operazioni:
- Unione:$$L_{1}\cup L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ oppure }x\in L_{2} \}$$
- Intersezione:$$L_{1}\cap L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ e }x\in L_{2} \}$$
- Complemento:$$\overline{a} = \{x\in\Sigma^{*}:x\notin L_{1} \}$$
- Concatenazione: se abbiamo $$x=a_{1},...,a_{n};\quad {y}=b_{1},...,b_{m}$$ $$\begin{gather}xy=a_{1},...,a_{n},b_{1},...,b_{m}\in \Sigma^{*}; \quad n,m\ge0. \\ \mathcal{E}x=x\mathcal{E}=x\implies\begin{cases}x\mathcal{E}=x\\x(ya)=(xy)a\\x,y\in\Sigma^{*},\ a\in\Sigma. \end{cases} \end{gather}$$
Posso concatenare i linguaggi
$L_{1}\circ L_{2}=\{xy:x\in L_{1} \text{ e } y\in L_{2}\}$
$L_{1}\circ L_{2}\ne L_{2}\circ L_{1}$ non è commutativa

es.
$\Sigma=\{a,b\}$
$L_{1}={a,ab,ba}$
$L_{2}=\{ab,b\}$

$L_{1}\circ L_{2}=\{aab,ab,abab,abb,baab,bab \}$

La potenza è un caso speciale. Per le stringhe $x^{n}=x...x\quad n$ volte, con $x\in\Sigma^{*}$

Quindi $\begin{cases}x^{0}=\mathcal{E}\\x^{n+1}=x^{n}x \end{cases}$

Lo stesso per i linguaggi:
$\begin{cases}L^{0}={\mathcal{E}} \\L ^{n+1}=L^{n}\circ L\end{cases}$

es. $L=\{a,ab,ba\}$
$$L^{2}=\{aa,aab,aba,abab,abba,baa,baab,baba \}$$
La ${*}:$ 
$$L^{*}=\cup^{*}_{n\ge0}\ L^{n}=\{ \underset{L^{0}}{\underbrace{\{\mathcal{E}\}}} \cup L^{1}\cup L^{2} \cup... \}$$
es.
$L=\{a,b \}$
$L^{*}=\{\mathcal{E},a,b,aa,bb,ba,aaa,... \}$

Vogliamo studiare le proprietà di chiusura dei linguaggi regolari.

Se $L_{1},L_{2}\in\text{REG}$, posso dire che $L_{1}\cup L_{2}\in\text{REG}?$ e $L_{1}\cap L_{2}?$ e $\overline{L_{1}}?$ E $L_{1}^{*}??$

###### Teorema - $\text{REG}$ è chiusa per unione.
Intuizione: $L_{1}, L_{2}\in\text{REG}\implies\exists M_{1},M_{2}\in\text{DFA}$ tale che $L(M_{1})=L_{1}$ e $L(M_{2})=L_{2}$

Devo definire $M$ tale che $L(M)=L_{1}\cup L_{2}.$
Problema: Dato $x$ candidato non posso prima provare a vedere se $M_{1}(x)$ accetta. 

Idea: $M$ deve eseguire $M_{1},M_{2}$ in parallelo e accettare se e solo se uno dei due accetta.