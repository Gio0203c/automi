# Lezione 02
## I Linguaggi Regolari
Nella lezione precedente abbiamo definito l'automa a stati finiti (DFA) come un primo modello semplice di computazione e definito cosa significa che un automa riconosce un linguaggio.

Ogni automa ha associato un linguaggio (l'insieme di tutte le stringhe che riconosce). L'insieme di tutti questi linguaggi forma una classe molto importante, quella dei **linguaggi regolari**
###### Definizione - Linguaggio Regolare
Un linguaggio viene definito **regolare** se esiste almeno un DFA $M$ che lo riconosce. In formule:
$$REG=\{L\subseteq\Sigma^{*}: \exists \text{ DFA }M\ \text{tale che } L(M)=L\}$$
Sebbene i DFA possano riconoscere una vasta gamma di linguaggi, essi hanno dei limiti. Verrà dimostrato che *non tutti* i linguaggi sono regolari, ovvero esistono linguaggi per i quali non è possibile un DFA che li riconosca.

È importante anche notare che, per un dato linguaggio, possono esistere molteplici DFA in grado di riconoscerlo. Dal punto di vista della correttezza, qualsiasi DFA che riconosca esattamente il linguaggio specificato è una soluzione valida. I

Esempio: 
Progettiamo un DFA che riconosca il seguente linguaggio: $$L=\Big\{x\in\{0,1 \}^{*}:x={1||y},\ y\in \{0,1 \}^{*}\Big\}$$dove:
- $||$ è l'operatore di concatenazione ("$1$ concatenato $y$"). 
- $\{0,1 \}^{*}$ significa "una stringa lunga da $0$ a $n$ caratteri fatta di $0$ e $1$"
In altre parole, stiamo cercando di trovare un DFA che accetti tutte le stringhe che iniziano con $1$ (indipendentemente da cosa c'è dopo). 

Un possibile DFA è il seguente:
![[lez02_01.drawio.svg|700x440]]

Lo stato iniziale è $q_{0}.$
- Se il primo simbolo letto è '$1$', l'automa si sposta nello stato $q_{1}.$ Poiché la condizione è soddisfatta, $q_{1}$ deve essere uno **stato di accettazione.** Una volta in $q_{1}$ qualsiasi simbolo successivo non cambierà la condizione, quindi l'automa rimarrà nello stato di accettazione.
- Se il primo simbolo letto è '$0$', la stringa non appartiene al linguaggio. L'automa si sposta nello stato $q_{2}$ che non è uno stato di accettazione. Qualsiasi simbolo successivo non cambierà la condizione. Questo tipo di stato spesso è chiamato **stato pozzo** (o **trap state**).

Come convenzione, a volte si omette di disegnare lo stato pozzo. Se da uno stato, per un certo input, non è disegnata alcuna transizione, si assume implicitamente che l'automa vada in uno stato pozzo non accettante.

Applicando questa convenzione, il DFA sopra può anche essere disegnato così:
![[lez02_02.drawio.svg|700x246]]

#### Prova di Correttezza
Dopo aver progettato un DFA, come possiamo essere sicuri che sia corretto? Bisogna fornire una **prova di correttezza**. In particolare dobbiamo dimostrare che:$$\text{Il DFA accetta  una stringa }x\iff x\in L$$
Per il nostro esempio, possiamo dimostrarlo per induzione sulla lunghezza della stringa di input $x.$

###### Prova di Correttezza dell'esercizio
Osserviamo che una volta raggiunto lo stato $q_{1}$ o $q_{2}$ l'automa non ne esce più. Formalmente:
$$\forall u\in \{0,1\}^{*}:\begin{cases}\delta^{*}(q_{1},u)=q_{1}\\\delta^{*}(q_{2},u)=q_{2}\end{cases}$$


Per induzione dimostriamo $x\in L$ se e solo se il DFA accetta $x.$

Dimostrazione:
1. **Caso base:** $|x|=0:$ 
   Se la cardinalità di $x$ è $0$, significa che $x=\mathcal{E}$ (la stringa vuota).$$\delta^{*}(q_{0},\mathcal{E})=\delta(q_{0},\mathcal{E})=q_{0}\notin F.$$La stringa vuota viene rifiutata. Questo è corretto perché $\mathcal{E}$ non inizia con '$1$'.
2. **Passo induttivo:** 
   Supponiamo che la proprietà sia vera per una stringa $w$ con cardinalità $|w|\le n.$$$\delta^{*}(q_{0},w)=\begin{cases}q_{0} & \text{se } w=\mathcal{E}\\ q_{1} & \text{se }w \text{ inizia con 1}\\ q_{2} & \text{se }w \text{ inizia con 0} \end{cases}$$Prendo $x$ tale che $|x|$ tale che $|x|=n+1.$ Posso interpretare $x$ come $x=au$, dove:$$\begin{cases}a\in\{0,1 \} & \text{è il primo simbolo}\\ u\in\{0,1 \}^{*} &\text{è una stringa di lunghezza }n\end{cases}$$Per definizione della funzione di transizione estesa:$$\delta^{*}(q_{0},x)=\delta^{*}(q_{0},au)=\delta^{*}(\delta(q_{0},a)x)$$
   Analizziamo i due casi per il primo simbolo $a$:
	1. Se $a=1$ la stringa $x$ inizia con '$1$' , quindi:$$\delta^*(q_0, x) = \delta^*(\delta(q_0, 1), u) = \delta^*(q_1, u)=q_{1}.$$ Poiché $q_{1}$ è uno stato di accettazione, la stringa viene accettata. Corretto.
	2. Se $a=0$ la stringa $x$ inizia con '$0$', quindi:$$\delta^*(q_0, x) = \delta^*(\delta(q_0, 0), u) = \delta^*(q_2, u)=q_{2}.$$Poiché $q_{1}$ non è uno stato di accettazione, la stringa viene rifiutata. Questo è corretto.
   La prova induttiva è completa e il DFA è corretto. $\blacksquare$
---
###### Esercizio
Proviamo a progettare un $DFA$ per i seguenti linguaggi su $\Sigma=\{0,1 \}$

1. 
   $$L=\Big\{x\in \{0,1 \}^{*} \text{ tale che } w_{H}(x) \ge 3\Big\}$$
   dove$$w_{H}(x)=\#1 \text{ in } x\in\{0,1 \}^{*}.$$
In particolare l'automa accetta le stringhe il cui peso di Hamming è maggiore di 3 (in una stringa binaria, il peso di Hamming corrisponde a quanti '$1$' ci sono).

Possibile soluzione:
![[lez02_03.drawio.svG|700x264]]
2. 
   $$L=\{x\in\{0,1 \}^{*}: x=0^{n}1 \text{ con }n\in \mathbb{N} \}.$$
In particolare l'automa accetta le stringhe di lunghezza $n$ che abbiano come carattere finale $1$ e tutti gli altri $0.$ 
 
Possibile soluzione:
![[lez02_04.drawio.svg|700x306]]
#### Operazioni sui Linguaggi
Poiché i linguaggi sono insiemi di stringhe, possiamo applicare loro le classiche operazioni insiemistiche. Dati due linguaggi $L_{1}$ e $L_{2}$, valgono le seguenti proprietà:
- **Unione**:$$L_{1}\cup L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ oppure }x\in L_{2} \}$$
- **Intersezione**:$$L_{1}\cap L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ e }x\in L_{2} \}$$
- **Complemento**:$$\overline{a} = \{x\in\Sigma^{*}:x\notin L_{1} \}$$
- **Concatenazione**: se abbiamo $$x=a_{1},...,a_{n};\quad {y}=b_{1},...,b_{m}$$la stringa concatenata sarà $$\begin{gather}xy=a_{1},...,a_{n},b_{1},...,b_{m}\in \Sigma^{*}; \quad n,m\ge0. \\\\ \begin{cases}x\mathcal{E}=\mathcal{E}x=x\\x(ya)=(xy)a\end{cases}\qquad x,y\in\Sigma^{*},\ a\in\Sigma. \end{gather}$$
	- La concatenazione aggiunge i caratteri della seconda stringa dopo l'ultimo carattere della prima. 
	- La stringa vuota concatenata ad una stringa mi genera la stringa precedente
	- La concatenazione preserva l'associatività.

> Nota: I linguaggi possono essere concatenati!

$$L_{1}\circ L_{2}=\{xy:x\in L_{1} \text{ e } y\in L_{2}\}$$
ma non è commutativa, ovvero: $$L_{1}\circ L_{2}\ne L_{2}\circ L_{1}$$
Esempio:
$$\begin{gather}\Sigma=\{a,b\},\quad L_{1}=\{a,ab,ba\},\quad L_{2}=\{ab,b\}\\\\L_{1}\circ L_{2}=\{aab,ab,abab,abb,baab,bab \}\\ L_{2}\circ L_{1} = \{aba, abab, abba, ba, bab, bba\}\\\\L_{1}\circ L_{2}\neq L_{2}\circ L_{1} \end{gather}$$

- **Potenza**: La potenza è un caso speciale. Per le stringhe $x^{n}$ significa $xx...x\quad n$ volte, con $x\in\Sigma^{*}$
  Quindi $\begin{cases}x^{0}=\mathcal{E}\\x^{n+1}=x^{n}x \end{cases}$
La potenza può essere applicata anche ai linguaggi:$$\begin{cases}L^{0}={\mathcal{E}} \\L ^{n+1}=L^{n}\circ L\end{cases}$$esempio:
Dato $L=\{a,ab,ba\}$:
$$L^{2}=\{aa,aab,aba,abab,abba,baa,baab,baba \}$$
- **Star di Kleene**$\{*\}:$ La stella di un Linguaggio $L$ si denota con $L^{*}$ ed è l'unione di tutte le sue potenze. Rappresenta l'insieme di tutte le stringhe che si possono formare concatenando zero o più stringhe da $L$
$$L^{*}=\cup^{*}_{n\ge0}\ L^{n}=\{ \underset{L^{0}}{\underbrace{\{\mathcal{E}\}}} \cup L^{1}\cup L^{2} \cup... \}$$esempio
$L=\{a,b \}$
$L^{*}=\{\mathcal{E},a,b,aa,bb,ba,aaa,... \}$
#### Proprietà di Chiusura dei Linguaggi Regolari
Se applicando delle operazioni a linguaggi regolari, il risultato è ancora un linguaggio regolare, allora la classe dei linguaggi è **chiusa** rispetto a quell'operazione.

Esempio:
Se $L_{1},L_{2}\in\text{REG}$, posso dire che $L_{1}\cup L_{2}\in\text{REG}?$ e $L_{1}\cap L_{2}?$ e $\overline{L_{1}}?$ e $L_{1}^{*}??$

Studiare queste proprietà è utile non solo dal punto di vista teorico, ma anche pratico. Se sappiamo che i linguaggi regolari sono chiusi rispetto all'unione, per costruire un DFA per $L_{1}\cup L_{2}$ possiamo progettarne uno per $L_{1}$ e uno per $L_{2}$, e poi usare una procedura generale per "fonderli" in un unico DFA per l'unione.
###### Teorema - $\text{REG}$ è chiusa per unione.
Intuizione: Siano $L_{1}$ e $L_{2}$ due linguaggi regolari, quindi: $$\begin{gather}L_{1}, L_{2}\in\text{REG}\implies\exists M_{1},M_{2}, \\\text{ tali che } L(M_{1})=L_{1} \text{ e }L(M_{2})=L_{2}\end{gather}$$Bisogna quindi definire un nuovo automa $M$ tale che $L(M)=L_{1}\cup L_{2}.$

Data una stringa di input $x$ il nuovo automa deve accettarla se $M_{1}$ la accetta oppure se $M_{2}$ la accetta.

L'idea di eseguire prima $M_{1}$ e poi $M_{2}$ sulla stessa stringa non è implementabile con un DFA. Il motivo fondamentale è che un DFA processa l'input in una singola passata, da sinistra a destra. 

Una volta letta l'intera stringa per essere testata su $M_{1}$ l'input è stato "consumato". L'automa non ha la capacità di "riavvolgere" l'input e ricominciare la lettura per $M_{2}$.

La soluzione quindi è di simulare $M_{1}$ e $M_{2}$ *in parallelo*. 

Continua nella prossima lezione...