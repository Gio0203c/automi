# Lezione 03
Nella lezione precedente, abbiamo introdotto la classe dei **linguaggi regolari** (indicata con **REG**), definita come l'insieme di tutti i linguaggi per i quali esiste un Automa a Stati Finiti Deterministico (DFA) in grado di riconoscerli.

Oggi esploreremo le **proprietà di chiusura** di questa classe. Dimostreremo che i linguaggi regolari sono chiusi rispetto a tutte le operazioni standard: unione, intersezione, complemento, concatenazione e stella di Kleene. Partiremo dalle operazioni più semplici, poiché la concatenazione e la stella richiederanno l'introduzione di un nuovo modello di computazione, che si rivelerà però equivalente al DFA.

#### Chiusura rispetto all'Unione

**Teorema:** La classe dei linguaggi regolari è chiusa rispetto all'operazione di unione.

**Dimostrazione (Costruzione del Prodotto)**

Dobbiamo dimostrare che se $$L_1$$ e $$L_2$$ sono linguaggi regolari, allora anche la loro unione $$L_1 \cup L_2$$ è un linguaggio regolare.

**Ipotesi:** Poiché $$L_1$$ e $$L_2$$ sono regolari, esistono due DFA, $$M_1$$ e $$M_2$$, che li riconoscono.
*   $$M_1 = (Q_1, \Sigma, \delta_1, q_{0,1}, F_1)$$ tale che $$L(M_1) = L_1$$
*   $$M_2 = (Q_2, \Sigma, \delta_2, q_{0,2}, F_2)$$ tale che $$L(M_2) = L_2$$
(Per semplicità, assumiamo che l'alfabeto $$\Sigma$$ sia lo stesso per entrambi).

**Tesi:** Dobbiamo costruire un nuovo DFA, $$M$$, tale che $$L(M) = L_1 \cup L_2$$.

L'idea, come anticipato, non può essere quella di eseguire prima $$M_1$$ e poi $$M_2$$, poiché un DFA elabora l'input in una singola passata senza possibilità di tornare indietro. La soluzione consiste nel **simulare l'esecuzione di $$M_1$$ e $$M_2$$ in parallelo**.

Costruiamo un nuovo DFA $$M = (Q, \Sigma, \delta, q_0, F)$$ i cui componenti sono definiti come segue:

1.  **Stati ($$Q$$):** Gli stati di $$M$$ devono tenere traccia simultaneamente dello stato di $$M_1$$ e di $$M_2$$. Pertanto, ogni stato di $$M$$ sarà una coppia di stati, uno da $$Q_1$$ e uno da $$Q_2$$.
    $$ Q = Q_1 \times Q_2 = \{ (r_1, r_2) \mid r_1 \in Q_1, r_2 \in Q_2 \} $$

2.  **Stato Iniziale ($$q_0$$):** All'inizio, entrambi gli automi si trovano nei rispettivi stati iniziali.
    $$ q_0 = (q_{0,1}, q_{0,2}) $$

3.  **Funzione di Transizione ($$\delta$$):** Quando $$M$$ legge un simbolo di input $$a$$, deve aggiornare lo stato di entrambi gli automi simulati, applicando le rispettive funzioni di transizione.
    Per ogni stato $$(r_1, r_2) \in Q$$ e ogni simbolo $$a \in \Sigma$$:
    $$ \delta((r_1, r_2), a) = (\delta_1(r_1, a), \delta_2(r_2, a)) $$

4.  **Stati di Accettazione ($$F$$):** L'automa $$M$$ deve accettare una stringa se e solo se essa appartiene a $$L_1$$ **oppure** a $$L_2$$. Questo significa che la computazione parallela deve terminare in uno stato $$(r_1, r_2)$$ dove $$r_1$$ è uno stato finale di $$M_1$$ **oppure** $$r_2$$ è uno stato finale di $$M_2$$.
    $$ F = \{ (r_1, r_2) \in Q \mid r_1 \in F_1 \lor r_2 \in F_2 \} $$
    Questo può essere scritto in modo più compatto come: $$F = (F_1 \times Q_2) \cup (Q_1 \times F_2)$$

Abbiamo così costruito un DFA $$M$$ che simula $$M_1$$ e $$M_2$$ in parallelo e accetta se almeno uno dei due accetta.

##### Correttezza della Costruzione
Per completare la prova, dovremmo dimostrare formalmente che $$L(M) = L_1 \cup L_2$$. Il punto chiave è dimostrare per induzione sulla lunghezza della stringa $$x$$ la seguente proprietà:
$$ \delta^*(q_0, x) = (\delta_1^*(q_{0,1}, x), \delta_2^*(q_{0,2}, x)) $$
Una volta stabilito questo, la correttezza segue direttamente dalla definizione degli stati finali $$F$$. Se $$M$$ accetta $$x$$, allora $$\delta^*(q_0, x)$$ è in $$F$$. Per la proprietà sopra e la definizione di $$F$$, questo significa che $$\delta_1^*(q_{0,1}, x) \in F_1$$ oppure $$\delta_2^*(q_{0,2}, x) \in F_2$$, il che implica $$x \in L_1$$ o $$x \in L_2$$. Il viceversa si dimostra in modo analogo.

#### Chiusura rispetto a Intersezione e Complemento

La stessa tecnica di costruzione del prodotto può essere adattata per dimostrare la chiusura rispetto all'**intersezione**. Se volessimo riconoscere $$L_1 \cap L_2$$, l'unica modifica necessaria sarebbe nella definizione degli stati finali. In questo caso, una stringa deve essere accettata se e solo se **entrambi** $$M_1$$ e $$M_2$$ la accettano.
$$ F_{intersezione} = \{ (r_1, r_2) \in Q \mid r_1 \in F_1 \land r_2 \in F_2 \} = F_1 \times F_2 $$

**Esercizio:** Dimostrare che la classe dei linguaggi regolari è chiusa anche per **complemento**. (Suggerimento: è ancora più semplice e non richiede la costruzione del prodotto).

#### Il Limite dei DFA e l'Introduzione al Non-Determinismo

Ora vogliamo trattare la **concatenazione**. Dati due linguaggi regolari $$L_1$$ e $$L_2$$, vogliamo dimostrare che anche $$L_1 \cdot L_2$$ è regolare.

Il problema è che, data una stringa $$x$$, per determinare se appartiene a $$L_1 \cdot L_2$$, dobbiamo verificare se può essere spezzata in due parti, $$x = x_1x_2$$, tali che $$x_1 \in L_1$$ e $$x_2 \in L_2$$. Un DFA, che legge l'input sequenzialmente, non sa a priori dove si trovi il punto di separazione tra $$x_1$$ e $$x_2$$.

Questo problema sembra molto più complicato da risolvere con un DFA. Per superare questa difficoltà, introduciamo un concetto fondamentale: il **non-determinismo**.

##### Il Concetto di Non-Determinismo
Finora, la nostra computazione è stata **deterministica**: da un dato stato, leggendo un dato simbolo, c'è un unico stato successivo possibile.

Il non-determinismo rilassa questa regola. In un automa non-deterministico:
*   Da un dato stato, leggendo un simbolo, l'automa può passare a **più stati contemporaneamente**.
*   Sono ammesse transizioni che non consumano alcun simbolo di input, chiamate **epsilon-transizioni** ($$\epsilon$$-archi).

È come se, di fronte a una scelta, la computazione si "sdoppiasse" in più rami paralleli. Ogni ramo esplora un diverso percorso di calcolo.

La **condizione di accettazione** è la chiave di volta: un automa non-deterministico accetta una stringa se **almeno uno** dei possibili rami di computazione termina in uno stato di accettazione. Rifiuta solo se *tutti* i rami terminano in stati non accettanti o "muoiono" (cioè si trovano in uno stato da cui non ci sono transizioni per l'input corrente).

### Automi a Stati Finiti Non-Deterministici (NFA)

**Definizione Formale di NFA**

Un Automa a Stati Finiti Non-Deterministico (NFA) è una tupla di 5 elementi: $$ N = (Q, \Sigma, \delta, q_0, F) $$.
I componenti $$Q, \Sigma, q_0, F$$ sono identici a quelli di un DFA. L'unica, cruciale differenza sta nella funzione di transizione $$\delta$$:

$$ \delta: Q \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q) $$

Dove $$\mathcal{P}(Q)$$ è l'**insieme delle parti** di $$Q$$, ovvero l'insieme di tutti i possibili sottoinsiemi di $$Q$$.

La definizione ci dice che:
1.  La funzione di transizione può avere come input anche il simbolo speciale $$\epsilon$$, che rappresenta le $$\epsilon$$-transizioni.
2.  L'output della funzione non è un singolo stato, ma un **insieme di stati**, che rappresenta tutte le possibili destinazioni.

#### Esempio: Stringhe con '1' in terzultima posizione
Progettiamo un NFA per il linguaggio $$L$$ delle stringhe binarie che hanno un '1' in terzultima posizione.

Con un NFA, l'idea è semplice:
1.  L'automa rimane nello stato iniziale $$q_1$$ leggendo qualsiasi simbolo.
2.  Quando legge un '1', l'automa usa il non-determinismo per "indovinare" se questo è il terzultimo '1'. Quindi, oltre a rimanere in $$q_1$$, crea un nuovo ramo di computazione che si sposta nello stato $$q_2$$.
3.  Dal ramo in $$q_2$$, l'automa deve verificare che seguano esattamente altri due caratteri. Legge un qualsiasi simbolo e passa a $$q_3$$.
4.  Da $$q_3$$, legge un ultimo simbolo e passa a $$q_4$$.
5.  $$q_4$$ è l'unico stato di accettazione. Se la stringa finisce qui, quel ramo accetta.

Il diagramma di stati è il seguente:
*   $$q_1$$ è lo stato iniziale.
*   Da $$q_1$$, con '0' o '1', rimane in $$q_1$$.
*   Da $$q_1$$, con '1', può anche passare a $$q_2$$.
*   Da $$q_2$$, con '0' o '1', passa a $$q_3$$.
*   Da $$q_3$$, con '0' o '1', passa a $$q_4$$.
*   $$q_4$$ è lo stato finale.

#### Computazione di un NFA
Tracciamo l'esecuzione dell'NFA sull'input `10110` (che deve essere accettato).
1.  Inizio: `(q1, 10110)`
2.  Legge '1': si sdoppia.
    *   Ramo A: `(q1, 0110)`
    *   Ramo B: `(q2, 0110)`
3.  Ramo A legge '0': `(q1, 110)`
    Ramo B legge '0': `(q3, 110)`
4.  Ramo A legge '1': si sdoppia di nuovo.
    *   Ramo A1: `(q1, 10)`
    *   Ramo A2: `(q2, 10)`
    Ramo B legge '1': `(q4, 10)` -> Ramo B muore (deve leggere ancora ma è in stato finale).
5.  Ramo A1 legge '1': si sdoppia.
    *   Ramo A1.1: `(q1, 0)`
    *   Ramo A1.2: `(q2, 0)`
    Ramo A2 legge '1': `(q3, 0)`
6.  Ramo A1.1 legge '0': `(q1, ε)` -> Termina, non accetta.
    Ramo A1.2 legge '0': `(q3, ε)` -> Termina, non accetta.
    Ramo A2 legge '0': `(q4, ε)` -> **Termina, ACCETTA.**

Poiché esiste almeno un ramo che accetta, l'intera computazione è accettata.

### Equivalenza tra NFA e DFA

Il non-determinismo sembra un potere magico. La classe dei linguaggi riconosciuti da NFA ($$L_{NFA}$$) è più grande di quella dei DFA (REG)?

**Teorema:** Un linguaggio è regolare se e solo se è riconosciuto da un NFA. Ovvero, $$L_{NFA} = \text{REG}$$.

**Dimostrazione**

La prova richiede di mostrare l'inclusione in entrambe le direzioni.

**1. $$\text{REG} \subseteq L_{NFA}$$ (Inclusione banale)**
Questa direzione è ovvia. Ogni DFA è un caso speciale di NFA: un NFA in cui non ci sono $$\epsilon$$-transizioni e l'insieme di destinazione di ogni transizione contiene sempre e solo un elemento. Pertanto, se un linguaggio è riconosciuto da un DFA, è anche riconosciuto da un NFA (lo stesso automa).

**2. $$L_{NFA} \subseteq \text{REG}$$ (La Costruzione dei Sottoinsiemi)**
Questa è la parte interessante. Dobbiamo dimostrare che per ogni NFA $$N$$, esiste un DFA $$D$$ equivalente, cioè tale che $$L(D) = L(N)$$.

L'idea è ancora una volta quella di simulare l'NFA. Il DFA che costruiremo, $$D$$, avrà stati che corrispondono a **sottoinsiemi di stati** dell'NFA $$N$$. In questo modo, $$D$$ può tenere traccia di tutti i possibili stati in cui $$N$$ potrebbe trovarsi dopo aver letto una certa sequenza di input. Questa tecnica è nota come **costruzione dei sottoinsiemi** (o "powerset construction").

Sia $$N = (Q_N, \Sigma, \delta_N, q_{0,N}, F_N)$$ un NFA. Costruiamo il DFA equivalente $$D = (Q_D, \Sigma, \delta_D, q_{0,D}, F_D)$$ come segue (per ora, senza $$\epsilon$$-transizioni):

*   **Stati ($$Q_D$$):** Ogni stato di $$D$$ è un sottoinsieme di stati di $$N$$.
    $$ Q_D = \mathcal{P}(Q_N) $$

*   **Stato Iniziale ($$q_{0,D}$$):** All'inizio, l'NFA si trova solo nel suo stato iniziale. Quindi, lo stato iniziale di $$D$$ è il sottoinsieme che contiene solo $$q_{0,N}$$.
    $$ q_{0,D} = \{ q_{0,N} \} $$

*   **Stati di Accettazione ($$F_D$$):** Il DFA $$D$$ accetta se l'insieme di stati correnti dell'NFA contiene almeno uno stato di accettazione di $$N$$.
    $$ F_D = \{ R \in Q_D \mid R \cap F_N \neq \emptyset \} $$

*   **Funzione di Transizione ($$\delta_D$$):** Se $$D$$ si trova nello stato $$R$$ (che è un insieme di stati di $$N$$) e legge il simbolo $$a$$, il suo prossimo stato sarà l'unione di tutti gli stati che $$N$$ può raggiungere da qualsiasi stato in $$R$$ con l'input $$a$$.
    $$ \delta_D(R, a) = \bigcup_{r \in R} \delta_N(r, a) $$

##### Gestione delle Epsilon-Transizioni
Per includere le $$\epsilon$$-transizioni, dobbiamo modificare la costruzione. Definiamo prima la **epsilon-chiusura** di un insieme di stati $$R$$, indicata con $$E(R)$$, come l'insieme di tutti gli stati raggiungibili da $$R$$ seguendo zero o più $$\epsilon$$-archi.

La costruzione del DFA viene modificata così:
1.  **Stato Iniziale:** Lo stato iniziale del DFA è l'epsilon-chiusura dello stato iniziale dell'NFA.
    $$ q_{0,D} = E(\{ q_{0,N} \}) $$
2.  **Funzione di Transizione:** Per andare da uno stato $$R$$ con input $$a$$, prima calcoliamo tutti gli stati raggiungibili tramite le transizioni su $$a$$ da ogni stato in $$R$$, e poi calcoliamo l'epsilon-chiusura del risultato.
    $$ \delta_D(R, a) = E\left( \bigcup_{r \in R} \delta_N(r, a) \right) $$

Questo DFA simula correttamente tutti i possibili percorsi di calcolo dell'NFA, dimostrando che i due modelli sono equivalenti in termini di potere espressivo (senza considerare le risorse).

#### Esercizio: Conversione da NFA a DFA
Dato il seguente NFA, definire il DFA $$D$$ equivalente tale che $$L(D) = L(N)$$.
(Si riferisce a un NFA disegnato alla lavagna con stati 1, 2, 3, transizioni su A e B, e una epsilon-transizione).

Utilizzare la procedura di costruzione dei sottoinsiemi per trovare il DFA equivalente.