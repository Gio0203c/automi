# Lezione 04
Grazie alla proprietà che abbiamo dimostrato nella scorsa lezione (ovvero che $\mathcal{L}(\text{DFA})=\mathcal{L}(\text{NFA})=REG$) possiamo utilizzare degli NFA per descrivere le proprietà viste in precedenza

Ad esempio, per quanto riguarda la chiusura rispetto all'unione:

![[lez04_01.drawio.svg|700x423]]
Dati due NFA, $N_{1}$ e $N_{2}$, costruiamo un NFA $N$ tale che $L(N)=L(N_{1})\cup L(N_{2})$. Per fare ciò, consideriamo un NFA formato da tutti gli stati di $N_{1}$ e di $N_{2}$, e vi aggiungiamo un nuovo stato (che farà da nuovo stato iniziale) $q_{0}$ con 2 $\mathcal{E}-$archi, uno che porta allo stato iniziale di $N_{1}$ e l'altro allo stato iniziale di $N_{2}$.

In questo modo il NFA eseguirà parallelamente sia la computazione di $N_{1}$ che di $N_{2}$ e accetterà se uno dei due accetta.

Formalmente, definiamo: 
- $Q=Q_{1}\cup Q_{2}\cup \{q_{0} \}$ 
- $F=F_{1}\cup F_{2}$
- $\forall q\in Q,\ a\in\Sigma_{\mathcal{E}}$: 
$$\delta(q,a)=\begin{cases}\delta_{1}(q,a),&q\in Q_{1}\\\delta_{2}(q,a),&q\in Q_{2}\\ \{q_{0}^{1},q_{0}^{2}\}, &q=q_{0},\ a=\mathcal{E}\\ \emptyset, &q=q_{0},\ a\ne\mathcal{E} \end{cases}$$
##### Concatenazione
###### Teorema - Chiusura rispetto alla Concatenazione
Dati due NFA $N_{1}$ ed $N_{1}$, per $L_{1}$ ed $L_{2}$ costruiamo un NFA per $L=L_{1}\circ L_{2}.$ Per fare ciò, consideriamo un NFA formato da tutti gli stati di $N_{1}$ e di $N_{2}$.

![[lez04_02.drawio.svg|700x515]]
Lo stato iniziale sarà lo stesso di $N_{1}$, mentre gli stati finali saranno solo quelli di $N_{2}$. Colleghiamo ciascuno degli stati finali di $N_{1}$ allo stato iniziale di $N_{2}$ attraverso un $\mathcal{E}-$arco.

In questo modo, quando la computazione avrà raggiunto uno degli stati finali di $N_{1}$ proseguirà dallo stato iniziale di $N_{2}$

Formalmente, definiamo: $N=(Q,\Sigma,\delta,q_{0},F)$, dove:
- $q_{0}=q_{0}^{1}$
- $Q=Q_{1}\cup Q_{2}$
- $F = F_{2}$
- $\forall q\in Q,\quad \forall a\in\Sigma_{\mathcal{E}}$
$$\delta(q,a)=\begin{cases}\delta_{1}(q,a),&q\in Q_{1}, q\notin F_{1}\\ \delta_{1}(q,a),&q\in F_{1}, a\neq \mathcal{E}\\\delta_{1}(q,a)\cup\{q_{0}^{2} \},&q\in F_{1}, a= \mathcal{E}\\ \delta_{2}(q,a), &q\in Q_{2}\end{cases}\quad\blacksquare$$
##### Star di Kleene
###### Teorema - Chiusura rispetto alla $*$
Dato un NFA $N$, tale che $L(N)=L$ devo costruire un NFA $N^{*}$ tale che $L(N^{*})=L^{*}$, ovvero l'automa deve poter riconoscere tutte le possibili concatenazioni ripetute di stringhe in $L$ (inclusa la stringa vuota).

Per iniziare, l'automa deve poter accettare la stringa vuota. Pertanto aggiungiamo un nuovo stato $q_{0}'$, che sarà sia il nuovo stato iniziale sia uno degli stati finali dell'automa $N{^{*}}$.

Da questo nuovo stato iniziale, deve essere possibile raggiungere $q_{0}$ attraverso un $\mathcal{E}-$arco per poter iniziare la computazione.

Infine, a ciascuno degli stati finali di $N$ va aggiunto un $\mathcal{E}-$arco verso $q_{0}$ in modo tale che una volta letta una stringa appartenente ad $L$ l'automa possa ricominciare la computazione da $q_{0}$ per poter leggere eventuali ulteriori concatenazioni di stringhe in $L$

![[lez04_03.drawio.svg|700x293]]

Formalmente, definiamo $N^{*}=(Q',\Sigma,\delta',q_{0}',F')$, dove:
- $q_{0}'$ è il nuovo stato iniziale.
- $F'=F\cup\{q_{0}'\};\ Q'=Q\cup\{q_{0}' \}$
- $\forall q\in Q', \forall a\in \Sigma_{\mathcal{E}}:$
$$\delta(q,a)=\begin{cases}\delta(q,a), & q\in Q, q\notin F\\ \delta(q,a), & q\in F, a \neq \mathcal{E} \\ \delta(q,a)\cup\{q_{0} \}, &q\in F, a=\mathcal{E} \\ \{q_{0}\}, & q=q_{0}',a=\mathcal{E} \\ \emptyset & q=q_{0}',a\neq\mathcal{E}.\end{cases}\quad\blacksquare$$

## Espressioni Regolari
In aritmetica è possibile utilizzare dei simboli come $+$ e $\times$ per costruire **espressioni**.

Allo stesso modo, attraverso **operazioni regolari** è possibile costruire **espressioni regolari**, come ad esempio:
$$(0\cup 1)0^{*}$$
Le **espressioni regolari** sono state introdotte da Kleene negli anni '50 e sono una notazione per rappresentare insiemi di stringhe. 

Sono state sviluppate in modo indipendente dagli automi, ma la teoria della computazione ha unificato i due concetti.

Mentre il valore di una espressione aritmetica è un numero, il valore di un espressione regolare è un **linguaggio**.

Nell'esempio precedente:
- L'espressione $(0\cup1)$ individua il linguaggio $\{0 \}\cup\{1 \}=\{0,1 \}$
- La parte $\{0 \}^{*},$ individua il linguaggio $\{0 \}^{*}$ cioè il linguaggio delle stringhe fatte da un numero qualunque (anche 0) di zeri.
- Infine $(0\cup 1)0^{*}$ rappresenta l'operazione di concatenazione $\circ$ tra linguaggi. Quindi il valore dell'espressione è il linguaggio:
$$\{0,1 \}\circ\{0 \}^{*}$$
Le espressioni regolari sono importanti quando si usano algoritmi che cercano patterns in stringhe di testo.

Definendole formalmente:
Sia $\Sigma$ un alfabeto. Una **espressione regolare** su $\Sigma$, che indichiamo con $re(\Sigma)$, è definita ricorsivamente:
- **Caso Base:**
$$\begin{cases} \emptyset\in re(\Sigma) \\ \mathcal{E}\in re(\Sigma) \\ a\in re(\Sigma),&a\in\Sigma\end{cases}$$
	- $\emptyset$ è un espressione regolare
	- $\mathcal{E}$ (la stringa vuota) è un espressione regolare
	- $a$ (un singolo carattere) è un espressione regolare
- **Caso Induttivo:**
$$\begin{cases}R_{1}\cup R_{2} & R_{1},R_{2} \in re(\Sigma)\\ R_{1}\circ R_{2} & R_{1},R_{2}\in re(\Sigma) \\ (R_{1})^{*} & R_{1}\in re(\Sigma)\end{cases}$$
Induttivamente, le espressioni regolari più complesse sono ricavate dai casi base mediante unione, concatenazione e star.

Ogni espressione regolare ha associato un linguaggio $L(r)$ tale che $r\in re(\Sigma)$

- **Caso Base:**
$$\begin{cases}L(r)=\emptyset, &r=\emptyset\\ L(r)=\{\mathcal{E} \}, &r=\mathcal{E} \\ L(r)=\{a \}, &r=a \end{cases}$$
- **Caso induttivo:**
$$\begin{cases}L(r)=L(R_{1})\cup L(R_{2}) &\text{se }r=R_{1}\cup R_{2}\\ L(r)=L(R_{1})\circ L(R_{2}) &\text{se }r=R_{1}\circ R_{2}\\ L(r)=(L(R_{1}))^{*} &\text{se }r=R^{*}_{1}\end{cases}$$
Esempi: Assumiamo di avere l 'alfabeto $\Sigma=\{0,1 \}$:

- $0^{*}10^{*}=\{w: w \text{ contiene esattamente un } 1\}$.
- $\Sigma^{*}1\Sigma^{*}=\{w: w \text{ contiene un numero }\ge 1$ di $1\}$.
- $\Sigma^{*}001\Sigma^{*}=\{w: w \text{ contiene } 001$ come sottostringa$\}$.
- $(0\cup1000)=\{$ogni occorrenza di $1$ è seguita da '$000$'$\}$.
- $(0\cup\mathcal{E})(1\cup\mathcal{E})=\{\mathcal{E},0,1,01\}$
- $1*\emptyset=\emptyset$
- $\emptyset^{*}=\mathcal{E}$
###### Teorema - Linguaggi ed Espressioni Regolari
Un linguaggio è regolare se e solo se esiste una espressione regolare che lo descrive. In particolare $$REG\equiv L(re).$$
La dimostrazione nella prossima lezione...