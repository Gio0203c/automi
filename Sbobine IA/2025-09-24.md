# Lezione 01
 Ok, allora, benvenuti al corso di automi. Siete tutti studenti di informatica o ci sta qualche eccezione? Tutti informati? Benissimo. Allora, piacere di conoscervi, io sono Daniele Venturi.
 Sono un docente qui al Dipartimento di Informatica, se cercate il mio nome trovate la mia pagina personale, trovate tutti i miei contatti e tutto quanto è necessario, tra cui la pagina dedicata a questo corso. Qui c'è una pagina dove ci sono tutte le informazioni su questo corso,
 inclusi la bibliografia, quindi il corso sarà alla lavagna, la lezione moderna della lavagna, quindi caricherò poi sul sito le cose che io scrivo alla lavagna e le metterò mantenendo un diario delle lezioni di quello che viene fatto l'altra volta, le potrete trovare sul sito.
 Il libro di testo è fatto veramente bene, è un libro veramente scritto bene, molto famoso nell'ambito dell'informatica teorica, è un libro storico. L'autore è Sipster, si chiama Introduzione e Autoria della Computazione, se non sbaglio, trovate tutti i riferimenti sul sito. Diciamo che seguirò quel libro quasi in maniera molto vicina, almeno per due terzi del corso.
 L'ultima parte, la parte di complessità, è un po' old fashion nel libro del Sipster, quindi sebbene quasi tutte le cose che faremo non ci stanno, però sono un po' compresse e un po' complesse, proprio più complicate da leggere, non è una lettura da fare sotto la spiaggia.
 Molto di più digeribile. Quindi per quello, diciamo, c'è anche un altro libro che potrebbe essere consigliato sul sito, o comunque gli appunti delle lezioni. Comunque quasi tutto sarà sul sito, però a meno di pochissime eccezioni. Come argomenti, dico. Va bene? Ok, ricevimento, non ho uno slot di ricevimento, però lo faccio quando voglio.
 Scrivete una mail e se avete dubbi, diciamo, possiamo o discuterne a lezione o comunque fissare un appuntamento se è necessario. Va bene? Ok. Esame. Ok? Parliamo di esame. Esame su questo corso. Esame, questo corso è scritto. Ok? Scritto in tre parti.
 Tre parti. Beh, una su Otomi, una su Calcolo Abitale, una su Calcolo Abitale. Ci sono tre argomenti nel corso e quindi l'anno d'esame è, diciamo, un macro-party, no? Per ogni parte, diciamo, ci saranno due sottoparti. Una parte sarà una domanda di teoria e una parte sarà un esercizio. Ok? Domanda di teoria sarà, diciamo, la riproduzione dei concetti che abbiamo studiato nel corso, esattamente come l'abbiamo spiegato, senza, diciamo, nessuna variazione.
 Cioè, qui una cosa che vorrei raccontare io me la dovete raccontare voi. Mentre la parte scritta e la parte esercizio sarà invece, diciamo, risolvere un piccolo problema che riguarda appunto questi argomenti e vedremo esempi di questi problemi durante il corso. Cioè, in particolare, diciamo, questo è uno di quei corsi in cui, come anche altri corsi, diciamo, in cui capire la teoria è una cosa, no? Capire come si fanno esercizi è un'altra, no?
 Perché magari, cioè, sono modi di ragionare a cui non siamo magari abituati, no? Non è immediato, no? Ok? Quindi, il consiglio che vi do, diciamo, nell'esperienza di insegnare questo corso ormai da diversi anni, è quello di iniziare subito a fare esercizi. Anche perché, diciamo, gli altri argomenti sono, cioè, compartimenti stabili. Cioè, una volta che hai capito come funziona l'automa stati finiti, basta. Cioè, finito non è che poi cambiano. Da qua a tre mesi. Quindi vuol dire che puoi già cominciare a fare esercizi sugli automi stati finiti.
 E, diciamo, come consiglio, cominciate subito. Nel senso che io faremo degli esempi, ovviamente, a lezione, però degli esercizi a volte da fare a casa, diciamo. Però non è, cioè, non stiamo al liceo, no? Cioè, quindi comunque, cioè, io vi darò dei suggerimenti, poi sarete voi a dover cercare di fare il vostro percorso da studenti ormai quasi magistrati. Detto questo, avremo anche tre momenti di esercitazione in classe, dove faremo solo esercizi. Ok? Quindi faremo tre esercizi.
 Infatti, una alla fine di automi, una alla fine di calcolabiliare. Vabbè. Ok. Quindi, detto questo, bene. Penso che non vi devo dire nient'altro sulla parte logistica, a meno che non avete domande. A parte l'aula, che è piccola. Mi sentite bene dal fondo? Beh, almeno, diciamo, l'aula non è decente, no? Ho visto molto di peggio. Bene.
 Ok. Ok. Allora, cominciamo, diciamo, parlando di, cioè, di che parleremo in questo corso. Ok? Cioè, cosa faremo in questo corso? Cosa faremo in questo corso? Ok. Questo è un corso veramente importante, no? Perché lo faccio io, diciamo. Ma perché, cioè, da informatici non si può,
 non si può non sapere qualcosa di teoria della complessità, cioè, e di calcolabilità. È un corso molto affascinante, se vi piace, diciamo, la teoria. Ci sono anche implicazioni pratiche, cioè, ovviamente, stiamo parlando di calcolabilità, cioè, quindi, ovviamente, la pratica è, ovviamente, la motivazione. Cioè, non è che stiamo a studiare le curve ellittiche, no?
 Cioè, stiamo comunque studiando il computer, cioè, quello che un computer può fare e quello che non può fare. Ok? Però, di fatto, diciamo, chi ha mosso i primi passi in quest'ambito, no? Sono le persone che per la prima volta si sono chiesti quali sono i limiti della computazione. Una domanda affascinante, no? Cioè, prima hanno inventato il computer e poi si sono chiesti ma che ci possiamo fare col computer e cosa non ci possiamo fare. Ok? Questo è un po',
 diciamo, è una domanda affascinante. Quindi, in questo corso, vedremo come si fa e cosa sappiamo di questa domanda e quanto siamo ignoranti sulla questione. Vedremo, ci sono tante cose che non sappiamo ancora, ok? Ci sono tante cose che sappiamo e tante cose che non sappiamo. Va bene? Quindi, la domanda fondamentale, la domanda, ok? Quali sono,
 quali sono le limitazioni intrinseche intrinseche della computazione? Va bene? Ok, questa è una cosa che è partita dagli anni 30, no? I padri sono stati Turing, Gödel, ok? Tutti questi sindaci.
 I signori qua. E, in particolare, diciamo, cioè, l'unico modo che tu puoi usare per, per, appunto, capire qual è il limite della computazione è avere un modello matematico che significa computazione. Cioè, se non lo definisci, come fai a dimostrare che una cosa la può fare e una non la può fare, ok? Cioè, quindi, il formalismo matematico, logico, diciamo, poi ci sono vari modi di fare questa cosa, è il modo che è necessario per fare questa cosa.
 Va bene? Ok. E ci parleremo, diciamo, di tre cose, no? Quindi, in, quindi, ovviamente, tre parti, no? Come il corso, diciamo, anche si chiama. Cioè, la prima sarà la teoria degli automi. Teoria degli automi. Ok? Cioè, qui vedremo la prima definizione di un modello di computazione semplice, più semplice che ci sta, no? Perché, ovviamente, diciamo, qui c'è un po' un
 trade-off, no? Cioè, nel senso che, cioè, da una parte, il computer è super casino, cioè, fai un modello matematico del laptop, cioè, non è una cosa facile. Però, cioè, la brillantezza, nel fatto, veramente, queste persone sono state brillanti, no? Perché chi ha studiato queste cose e le ha, diciamo, definite perché è riuscito a trovare un linguaggio per descriverle in una maniera semplice, no? Che, però, d'altra parte, è anche potente abbastanza da calcolare,
 quello che un computer potrebbe fare, no? Però senza definire tutti i dettagli che non servono. Cioè, ha tolto tutte le cose che non servono, no? Cioè, come se ha fatto, diciamo, la definizione minima per poter dire qualcosa di interessante, perché, ovviamente, se la definizione è complicata, poi non la so, no? Cioè, se la definizione è troppo semplice, però, potrebbe essere che sì, ok, ho fatto sta cosa, però poi il computer vero fa un'altra cosa, giusto, no? Cioè, c'è questo problema, no? È una cosa delicata se ci metto. Quindi, ok, vedremo le prime definizioni partendo da un modello di computazione
 molto semplice, ok? Che non è, infatti, così potente da calcolare, da, diciamo, rappresentare tutto quello che un computer può fare. Però, può rappresentare qualcosa, ok? Cioè, alcune cose che vengono implementate nel mondo reale obbediscono a questo modello, ok? Cioè, quindi, comunque, è un modello reale. Però è una cosa per iniziare, no? Diciamo, è il primo passo, infatti, no? Cioè, lo possiamo vedere come il primo passo
 per capire modelli semplici di computazione, ok? Questo si chiama, infatti, l'automa a stati finiti, no? Cioè, ci sono applicazioni reali, ok? Applicazioni di questo modello sono, per esempio, gli algoritmi che riconoscono, che estraggono pattern,
 dai dati, per esempio, no? Per il riconoscimento di alcune sequenze, ok? Cioè, ti do un testo e estrai certe sequenze, no? O anche, diciamo, i parser dei compilatori, dei linguaggi di programmazione, ok? Questo è un altro esempio, ok? Quindi, parser compilatori oppure, diciamo,
 elaborazione, elaborazione, testi, per estrarre, per estrarre, o riconoscere, diciamo, dati, ok? Questo è un esempio, no? Cioè, ovviamente, il fatto che il modello di computazione sia semplice, però ti permetta ancora di fare qualcosa che è importante in pratica, è un vantaggio a questo punto, no? Perché, cioè, vuol dire che se è semplice, è pure più efficiente da implementare, no? Cioè, infatti, non è che puoi fare tutto,
 abbiamo bisogno del super computer, no? Cioè, alcune cose sono talmente facili che basta un modello di computazione più semplice e anche può essere implementato in maniera più semplice, ok? Questo si usa tutti i giorni, no? Ok? Bene, quindi questo è il primo macro-argomento e vedremo un sacco di cose, cioè, qui c'è un mondo, diciamo, no? Cioè, a partire da questa definizione, ci sta un mondo di cose che possono essere fatte con gli automi, ok? E però, cominceremo a
 esplorare un po' quali sono già i confini della computazione, perché vedremo che, sebbene in questo modello ci sono tante cose che si possono fare, ce ne sono alcune che non si possono fare, ok? Cioè, questo lo vedremo, cioè, questo modello non potrà mai risolvere certi problemi, ok? Bene. Una cosa importante, diciamo, è che quando faremo questo, non ci importerà niente delle risorse, cioè, ok? Non è che diremo tempo, poco tempo,
 tanto tempo, tanto spazio, poco spazio, ok? No, per il momento non ci importa di questo. Però, il modello sarà limitato in alcune caratteristiche che, anche se le risorse possono essere, diciamo, infinite, non è sufficiente per fare certe cose, ok? Intensicamente. Va bene? Ha senso? Ah, quindi, motivati, diciamo, da questa osservazione, cioè, da questo fatto che scopriremo,
 andremo a cominciare a parlare di computabilità, ok? Cioè, computabilità significa che cosa si può risolvere e che cosa, invece, non si può risolvere. Ci sono problemi che non si possono risolvere e per quale modello di computazione, ok? Cioè, quindi, computabilità, diciamo, o computabilità, o calcolabilità, diciamo.
 E corrisponde, invece, al calcolatore, no? Cioè, qui, considereremo, considereremo il modello di calcolo molto più potente. E questa è la macchina di Turing. Ok?
 Cioè, se tu sai scrivere un algoritmo in Python che risolve un problema, puoi pure fare una macchina di Turing che fa quella stessa cosa. Certo, lo farà in maniera più arzicopolata, no? Perché Python è semplicemente un modo per farlo,
 in maniera ottimizzata, di fatto, ok? Però pure la macchina di Turing lo può fare. Solo che deve fare alcune cose che sarebbero, diciamo, come direbbero gli inglesi, un po' cumbersome, no? Cioè, delle cose strane, no? Perché il modello di computazione è semplice. Perché è semplice? Perché se è semplice, allora lo posso analizzare per dimostrare delle cose, no? Se il modello è super complicato ed è impossibile da trattare, no? Ok? Cioè, questo train, come vi dicevo, no? Quindi è un modello che è semplice, però più generale, diciamo, dell'autonomia,
 no? Però abbastanza semplice per permetterci di dire cose interessanti, no? Ad esempio, il fatto che esistono problemi che nessun computer può risolvere. Una cosa pazzesca, no? Cioè, pensa a questi quando hanno scoperto questa cosa, no? Quindi esistono problemi che nessun computer, dove computer per noi sarà macchina di Turing, ok? Può risolvere.
 Va bene? E... Ad esempio, diciamo, uno poi potrebbe pensare, no? Vabbè, sì, questi problemi saranno strani. O ce ne saranno pochi, non lo so, e saranno tutti strani, no? Invece no. Ok? Cioè, esempio, esempio, stabilire se un programma termina. Ok? Questo è famosissimo. Si chiama
 problem, stabilire se un programma termina. Ok? Io scrivo programma, però in realtà il programma sarà una macchina di Turing, no? Quindi capire se una macchina di Turing termina è un problema che non è risolvibile da nessuna computer, da nessuna macchina di Turing, ok? Questo è un esempio, no? E ce ne saranno tantissimi. Cioè, questa è l'altra cosa sorprendente, che una volta che ne hai trovato uno, ne puoi trovare...
 a piacimento. Ok? Cioè, quindi ci saranno un sacco di problemi che un computer non può risolvere. Ok? E vedremo tantissimi esempi. Ok? E un'altra volta, questo è importante, questo è indipendente dalle risorse. Ancora no. Cioè, non è che dico, non lo può risolvere perché c'ha troppo poco tempo, c'ha troppo poco spazio. No! Ci potrebbe avere tutto il tempo che può, tutto lo spazio, non lo può risolvere, basta, cioè, ok? Va bene, cioè, quindi, indipendentemente...
 indipendentemente... dalle risorse. Ok? Cioè, non ci occuperemo proprio delle risorse. Fino a quel momento. Ok? Fino adesso. Non li mettiamo proprio in mano. Ok? Ci siamo? In realtà, diciamo, questo ha alcune implicazioni che sono poi profonde. Cioè, queste, secondo me, sono veramente le pietre miliari dell'informatica, no? Cioè, adesso... Cioè, il fatto che, per esempio,
 poi, una volta che hai capito queste cose, le puoi usare per andare a rivisitare cose che altri hanno fatto usando altri linguaggi, no? E la cosa forse più famosa di questo esempio è il fatto che, come esistono i problemi che non possono essere risolti? Esistono affermazioni matematiche che non possono essere dimostrate. Suona simile, no? Cioè, ci sono i problemi che non possono essere calcolati,
 ci sono le dimostrazioni... le affermazioni che non possono essere dimostrate. Sembra simile, no? E la cosa interessante... e questo è famosissimo, no? Cioè, questo si chiama il teorema di incompletezza di Gödel. Ok? Cioè, questo è un... è veramente una pietra miliare della matematica, no? Cioè, è una cosa pazzesca. E... se non che... quindi, diciamo, vediamo anche... scrivo qui, me lo appunto, diciamo, il teorema di...
 Gödel, ok? Ok. E... cioè, Gödel era un logico, no? Uno faceva logico. E a un certo punto... a sospettare che... se tu prendi un sistema matematico, no? Cioè, adesso... questo vuole un'altra volta. Cioè, per poter dire che c'è una cosa che non puoi dimostrare, prima di tutto devi fissare un sistema matematico. E come... è la stessa cosa di dire... per dimostrare che ci sono problemi che non si possono risolvere, prima devi fare il modello della computazione. Cioè, vedi che c'è un parallelo tra queste due cose?
 Ok. Quindi, questo qui dice, ok, se c'è... mettiamo... fissiamo un certo sistema matematico, dove possiamo dimostrare cose, e qui che significa? Insieme gli assiomi, no? Cioè, i matematici hanno gli assiomi, e dagli assiomi derivano tutte le... tutti i teoremi, no? In teoria, del... dell'algebra, che ne so, della geometria, no? Ok. E... fissato un tale sistema, che ha certe proprietà naturali, che c'erano tanti sistemi, tipo, per esempio, l'aritmetica di Peano,
 studiato, avete sentito, diciamo, in qualche altro corso, o nella vostra vita, e... esistono, sì, affermazioni che non si possono dimostrare, ok? Cioè, non si possono dimostrare, non perché sono false, cioè, non si può dire che sono vere, né che sono false, cioè, che rimangono indecidibili, rimangono... ok, gli spiegate, non è completo, infatti si parla di competenza, no? Cioè, puoi fare un'affermazione lì, cioè, tu vorresti avere una cosa che... cioè, io ho una teoria matematica, no? Faccio un'affermazione usando quel linguaggio, o è vera o è falsa, no?
 No, no, non è così. Non si può, non si può fare. Ok. Questo è sorprendente. Adesso, il problema di questa cosa è che, per dimostrare questa cosa, devi fare un corso di logica, ok? Non so, quanti di voi hanno fatto logica? Logica? Si fa sta roba a logica? Ma hai già fatto logica, finita. O c'è al terzo anno, diciamo? E al terzo anno c'è il corso di logica matematica? Logica matematica, ok.
 È facoltativo. Facoltativo. E immagino lì, forse, si farà roba di questo tipo. Benissimo. Cioè, infatti, ci vuole un corso intero per imparare a fare sta cosa, no? Cioè, perché non è... Allora, la cosa bella, diciamo, una delle cose belle dell'informatica, appunto, è anche, diciamo, della teoria, no? Che poi, se uno fa una teoria che ha senso e che permette di dimostrare cose, diciamo, di un certo tipo, la puoi utilizzare per spiegare cose che vengono da altri campi.
 Per esempio, le dimensioni tra discipline, no? E vedremo, infatti, vedremo che il teorema di impossibilità di Kether si può dimostrare con la macchina di Turing. Cioè, è fantastica, sta roba. E la dimostrazione... Cioè, una volta che hai capito tutta sta cosa della calcolabilità della macchina di Turing, cioè, pure questo... Cioè, adesso non voglio dire che questo è cakewalk, no? Cioè, non è... Il corso di logica è difficile, questo è una passeggiata. Non è così, no? Cioè, pure qua, ti vogliono due terzi del corso di automio per capire come funziona la macchina di Turing.
 Cos'è l'alting problem, eccetera, eccetera. Però, una volta che hai capito questo, ok? Il teorema di Kether è apportato, diciamo, ok? Non devi capire tutta la logica per capire il teorema di Kether, ok? E si può... Ve lo farò vedere, ok? Spero di riuscire a farlo vedere. Va bene? Parleremo di questa cosa qui nella seconda parte del corso. Ok. Nella terza parte del corso...
 Ok? Complessità. Che significa complessità? E qui pure vedremo che ci saranno delle domande affascinanti. Complessità, che è anche un po' la parte più moderna, diciamo, della teoria della computazione, anche se... Non so, ormai ho una cinquantina d'anni, se non di più. Complessità vuol dire... Cominceremo a mettere in mezzo le risorse.
 Quante risorse? Ok? Cioè... Quantificheremo... Quantificheremo... Le risorse. Ok? Cioè, le risorse, che significa della computazione, no? Spazio e tempo, fondamentalmente. Ok? Per lo meno, diciamo. Cioè, sono altre... Però, noi ci occuperemo prima di tutto
 principalmente di quelle basilari che sono spazio e tempo. Quindi, cioè, capito? Cominceremo a chiederci, no? Cioè, ok, ci sono problemi che possono essere risolti indipendentemente dallo spazio e dal tempo, no? E... Ma tutti i problemi, invece, che possono essere risolti, possono essere risolti in poco spazio e in poco tempo? Cioè, per esempio. C'è una domanda che c'ha senso. Cioè, questo deriva dal fatto che la gente, in realtà, cioè, da millenni, no? Da millenni si è accorta che ci sono problemi che non si risolvono. Ok? Cioè...
 Sembrano esistere... Esistere... Problemi... Diciamo, qui devo essere più preciso, no? Non sa risolvere, però non sono i problemi di quelli di sopra che sono impossibili da risolvere. Non sa risolvere in poco tempo. Perché in tanto tempo, lui ce lo sa risolvere. Ok? Cioè, sembrano esistere problemi, diciamo, difficili, no? Difficili da risolvere in modo efficiente. Ok? In modo efficiente.
 Ok? Faccio un esempio. Esempio. Esempio è una cosa migliore. Quello che si chiama, diciamo, the factoring problem. Ok? Factoring problem. Factorizzazione. Ok? La factorizzazione dei numeri. Ok? Questo è un problema matematico. Semplice. Ok? Tutti lo capiscono. Cioè, io prendo n uguale p per q. Ok? Dove p
 e q sono primi. Diciamo, di n bit. Ok? Cioè, li considero in binario. Per semplicità, no? Ok? Cioè, perché stiamo facendo calcolabilità, no? Quindi, cioè, io voglio fare un algoritmo, lo voglio codificare, voglio fare un codice python, no? Che mi fattorizza n uguale p per q. Quindi, diciamo, quindi ci sono due modi, no? Diciamo, di, in effetti, vedere
 questa cosa, no? Cioè, da una parte c'è il problema di dire come faccio a generare un primo di n bit. Ok? Ma questo è una cosa non banale. Ok? Cioè, questo richiede un sacco di idee in matematica, no? Cioè, poi i matematici hanno cominciato a studiare queste cose già centinaia di anni fa, no? Hanno visto che, per esempio, no? I matematici gli piacciono un sacco i numeri primi e dicono ci sono un sacco di numeri primi. Ok? Sono infiniti,
 non solo sono infiniti, sono pure densi, no? Cioè, nel senso che ce ne sanno tantissimi. Ok? E tutte queste cose i matematici le sanno molto bene. E quindi, per esempio, una cosa che i matematici sanno fare molto bene è testare la primalità. Cioè, tu mi dai un numero e io ti dico se è primo o non è primo. Ok? E sto numero potrebbe essere pure di n bit dove n uguale, non lo so, n uguale 1024? Ok? 1024 bit. Cioè, 2 alla 1024.
 Capito? Non lo puoi scrivere. Ok? Cioè, questo è un numero gigantesco, no? Eppure i matematici hanno trovato degli algoritmi che in tempo breve, dove breve significa, infatti, un numero di passi, diciamo, no? Passi della computazione. Che non va come 2 alla 1024, no? Perché quello sarebbe esponenziale. Ok? No. Nella dimensione dell'input, no? Ma va in 1024.
 Ok? Cioè, logaritmico. Ok? Allora, vedi, questa differenza qui, ecco, questa è la teoria della complessità. Cioè, quante risorse ho bisogno, di quante risorse ho bisogno in funzione della dimensione dell'input per risolvere certi problemi. Ok? Testare la primalità, secondo fa. Ok? Non è banale. Non lo vedremo. Ok? Questa è una cosa che mi guarda più, diciamo, la teoria dei numeri. E non parleremo di questo. Però per darvi un esempio. Cioè, adesso, credetemi che si può fare. Ok? Siccome posso testare la primalità, no? Ok?
 Posso anche generare numeri primi, casuali, di quanto il bit mi pare a me. Ok? Perché? Perché io che faccio? Prendo un numero a caso, ok? Di n bit. E poi controllo se è primo. Ok? È efficiente questo. Siccome i primi sono tantissimi, ok? Beh, se mi ha detto male, ne prendo un altro. E rifaccio il test in continuo, diciamo. Siccome sono così tanti i primi, alla fine, a un certo punto, ho successo.
 Ok? Quindi posso generare i primi grandi. Ok? Quindi, primo, diciamo, mistero. Non mi dispiace, non vi dirò questo come si fa, però questo non ha molto a che fare, diciamo, con la teoria della computazione. È un problema molto specifico, diciamo, di computazione. Non parleremo di questo. Però, questo perché ve lo sto raccontando? Per dirvi che, quindi, è possibile generare i primi a piacere grandi. A questo punto, dati due primi, P e Q, a piacere grandi,
 oppure moltiplicare in maniera efficiente. Cioè, quindi, non solo c'è un algoritmo che mette in genere, ma c'è pure un algoritmo che calcola il prodotto, no? Vabbè, questo è facile. Cioè, è come pure in Python, no? Puoi scrivere e ti rendi conto che se tu gli dai il codice, cioè, che implementa la moltiplicazione, quella degli elementari, no? Questo codice è efficiente. Ok? Efficiente significa che, ancora una volta, cioè, se i primi hanno dimensioni 2 alla 1024, il numero di passi è 1024, ancora una volta, ok? Cioè, è una cosa binary, no?
 La lunghezza binaria, diciamo, dell'interno. Ok? Quindi, vedi, questo ci dice, esistono problemi facili. Ok? Testare se un numero è primo è facile. Cioè, facile che significa, in teoria della complessità, significa tempo di esecuzione polinomiale nella dimensione dell'interno. Ok? Quindi, diciamo, quello che sto dicendo qui è che calcolare n è facile.
 Quindi, tempo polinomiale, questo poi lo capiremo come si definisce. Però, per adesso, diciamo, nella dimensione del link. Ok? Adesso per darvi un'idea, no? Cioè, quindi, ancora una volta, tempo polinomiale nella dimensione del link, è una generalizzazione di quello che ho detto, che se c'è 1024 bit, ci vogliono 1024 passi, e non 2 alla 1024, ok? Quindi, esistono problemi facili. Ok?
 Facili. Questi sono quelli che fanno i teorici della complessità. Prendono tutti i problemi che esistono al mondo e li dividono in classi. Ci sono quelli facili, quelli difficili, quelli non lo so. Ok? Va bene? Cioè, questa è l'idea, no? Quindi, la classe di tutti i problemi facili è la classe che si chiama P. Ok? Cioè, questa P maiuscola sarebbe la classe, cioè l'insieme, di tutti i problemi che sono facilmente
 e sono risolvibili, infatti, da una macchina di Turing con tempo di esecuzione polinomiale nella lunghezza del link. Ok? Questo vuol dire che traduzioni, diciamo, in gergo, sono efficienti, sono risolvibili in maniera efficiente. Ok? Vedremo dopo, ovviamente, la definizione precisa di questa cosa che ho detto. Ok? Adesso non sappiamo neanche cos'è una macchina di Turing, però, a livello intuitivo, no? Significa, esiste un algoritmo che lo posso implementare e in tempo efficiente, in modo efficiente, risolvere questo problema. Va bene? Ok.
 Adesso, però, se ti chiedo, invece, di risolvere il problema inverso, cioè, sempre, a partire, che questa è la fattorizzazione, quindi, questa è la moltiplicazione. La moltiplicazione sta in P, ma la fattorizzazione, invece, è un problema più difficile. Ok? Cioè, tipo, io, quindi, genero P, genero Q, faccio il prodotto tutto efficiente, ti sparo N e ti dico, vai, trova P e Q. Ok? Va bene? Adesso, tu, dipende da quante risorse c'hai. Cioè, perché P e Q esistono per forza.
 Si può scomporre in modo univo con il prodotto di primi, no? Eh? La roba lì, no? Quindi, va bene, provali tutti, no? Cioè, li provi tutti, cominci dal primo, poi il secondo, primo, poi dopo. Eh? Li provi tutti. A un certo punto lo trovi. Cioè, P l'hai trovato. Peccato che adesso, se P adesso è generato in modo che la sua dimensione, veramente, è circa 1024 bit, no? Cioè, non è P uguale a 3. Vabbè, se uno dei due primi è 3, lo trovi subito. Però, se io posso generare N in modo che,
 proximately, no? Il size di tutti i due primi è circa radice di N, no? Eh? Ok? Eh, lo provo, ti va? E quindi, cioè, sono talmente tanti, no? E sono talmente grandi che tu, cioè, non ce la fai. Però, ci metti un numero di passi che adesso diventa esponenziale. Ok? Esponenziale. Quindi, quella è un'altra classe di problemi. Che si chiama expo, infatti, no? Cioè, numero di passi esponenziale, expo. Ok? Va bene? Quindi,
 però, cioè, non è che c'è una dimostrazione che dice, cioè, sì, ok, tu sai fare solo quello. Cioè, nel senso, tu provi tutti, expo, vabbè, ok. Ma magari c'è un altro modo, no? Cioè, chi ci dice che c'è un altro modo. Cioè, si dà il caso che i matematici sono affascinati da questa domanda così semplice, cioè, gli deve piacere per forza. E quindi, che fanno? Loro la provano a risolvere da centinaia di anni. Ok? Tutti ci hanno provato. E tutti i geni, no? Eulero, Gauss, tutta questa gente qua,
 loro lo provavano a fattorizzare, no? E quindi, i teorici dei numeri di oggi hanno fatto della roba pazzesca, no? Cioè, hanno cominciato a tirare fuori i cumuliti e tutte cose pazzesche per cercare di fattorizzare in maniera più efficiente di quello che solo fa la brute force e si prova tutti i primi. E hanno ottenuto dei risultati strabilianti. Ok? Strabilianti in teoria. Ok? Cioè, in pratica, cambia niente. Cioè, nel senso che il miglior algoritmo che fattoria
 fattorizza, no? Oggi, ha complessità che non è esponenziale, però è subesponenziale. Subesponenziale significa, invece di essere 2 alla n, è 2 alla alfa n, dove alfa è una costante minore di 1. Più o meno siamo lì, no? Ok? Cioè, ovviamente, dietro a questa cosa che ho detto c'è un mondo. Per fare questo algoritmo subesponenziale ci sono delle idee brillanti, pazzesche, no? Che ovviamente non vedremo, non fanno parte di questo corso. Però, il fatto sta che
 alla fine, cioè, non è polinomiale. Ok? Va bene, neanche con costanti astronomiche, cioè, non è polinomiale, basta. Non lo sappiamo. Ok? Quindi, sospettiamo che forse questo problema non si può risolvere in maniera efficiente. Boh, chi lo sa? Ok? Questa è la domanda che si cominciavano a fare questi teori della complessità, no? Però questi, allora, hanno osservato, invece, un'altra cosa, no? Che diceva, cioè, perché questo non lo sappiamo, no? Se il problema è facilmente risolvibile in maniera efficiente, è una cosa.
 Ok? Però c'è un'altra cosa che sappiamo fare in modo efficiente, sempre di questo problema qui, per esempio, no? Sappiamo controllare se una soluzione è corretta in tempo efficiente. Questa è una bella, bella, bella osservazione, no? Cioè, dice, ok, però, allora, quindi, questo qui è, quindi, diciamo, fattorizzare n, quindi, bisogna scrivere tutte le cose che ho raccontato, fattorizzare n, sembra difficile, dico, sembra, no?
 Sembra difficile, con i migliori algoritmi, algoritmi, che hanno tempo, diciamo, sub-exponenziale, ok? Sub-exponenziale, sub-esponenziale nella dimensione del tutto.
 La forza bruta, cioè. In realtà è molto più intelligente, asintoticamente è molto meglio, però in pratica, ok? Non cambia molto. E... Ok, però, c'è un'altra osservazione, però. Osservazione, no? Osservazione. Dati P e Q, ok? P e Q candidati, diciamo. Candidati.
 Candidi. Dati. Cioè, diciamo, questa è una soluzione. Posso controllare efficientemente se è corretto. Ok? Cioè, c'è questa caratteristica. Perché se io gli do una soluzione,
 no? Cioè, io ti dico, vabbè, io l'ho trovata. Ci sono questi. P e Q. Controlla se sono giusti. Vabbè, allora tu che fai? Devi controllare se P è primo. Vabbè, se può fare. Se vuoi testare se P è primo. Devi controllare se Q è primo. E poi devi moltiplicare P per Q e devi controllare che è uguale a n. Ok? Quindi posso controllare. Giusto? Quindi, questo problema della fattorizzazione ha questa caratteristica. Data una soluzione puoi decidere il tempo Q.
 Efficiente. Se è giusta o sbagliata. Allora, ritornando a tutte le classi dei problemi che esistono nella teoria della complessità, questa si chiama NP. Ok? Questa è la classe NP. Ok? Quindi attenzione agli equivoci, no? NP non polynomial. No, questo è tutto sbagliato. C'è un motivo per cui si chiama NP. È un motivo molto più profondo che deriva da come si definisce questa classe. E si definisce storicamente in un modo che è equivalente
 a quello che vi ho raccontato io adesso, ma che invece usa tutta un'altra cosa. Usa un altro modello di computazione che si chiama non determinismo. La n è quello, non determinismo. Tutte cose che studieremo, no? Vedremo questo quando ci arriveremo. Quindi era soltanto per dirvi. Però questa è la classe NP. Ok? Quindi esistono problemi adesso, ok? Vedi? Quindi ci sono problemi che sono difficili, sembrano difficili da risolvere da delle risorse limitate. Ed esistono
 problemi però che allo stesso tempo, quindi non sappiamo se sono in P. Ok? Però sappiamo sicuramente che sono in NP. Ok? Adesso la domanda è, ma tutti i problemi che sono in NP, tutti, sono anche in P? Ok? Cioè P è uguale a NP? Ok? Qui arriviamo diciamo alla domanda chiave. P uguale NP? Questa è la domanda più affascinante e più
 importante del sapere, direi, di oggi, no? Cioè una delle, no? Sapete? C'è un famoso istituto matematico che si chiama il Clay Mathematical Institute, no? Che, diciamo, ha selezionato una serie di domande che sono quelle più pressanti, no? Dice che oggi non sappiamo la risposta, ma la risposta a queste domande ci avrebbe delle applicazioni così strabilianti, no? Che, diciamo, potrebbe cambiare la nostra comprensione del mondo, no? Cioè queste cose
 qua, no? Uno di queste è, diciamo, P uguale a NP, no? In palio un milione di dollari per tornare in questa domanda, no? Ok? Un milione di dollari non è niente, cioè se torni in questa, cioè, puoi fare della roba pazzesca, no? Cioè puoi rompere tutta la criptografia che esiste oggi, no? Puoi fare queste cose così, no? Potresti, diciamo, potresti. Va bene, cioè questa è una domanda fondamentale, no? Cioè si crede che questa risposta a questa domanda sia no, ok? Cioè la gente pensa,
 no, cioè deve esistere, secondo me, secondo i informatici teorici, deve esistere un problema, ok? Che sta in NP, ma non sta in P, cioè se le due classi sono uguali, sta almeno un problema che sta in NP, ma sicuramente non sta in P, ok? Non ho mai trovato nessuno, prego.
 Per una soluzione si può verificare il tempo, no? Ok? Esatto. Per adesso, no? Poi definiremo queste cose in maniera precisa, ok? Adesso è soltanto per darvi un fleco, no? E... Vabbè, quindi niente, cioè, questa domanda è aperta e la risposta no la so manco io, quindi non vedremo, diciamo, come si fa a rispondere, però, diciamo,
 studeremo un po', diciamo, le basi di teoria della complessità e vedremo quali sono i risultati principali che vanno in una certa direzione rispetto a dimostrare questa cosa o a confutarla, ok? Cioè vedremo delle cose che sono connesse a questa domanda, non danno una risposta piena, ma, dicono, danno delle indirizzi, no? Delle direzioni su come si può fare a dimostrare questa cosa, se non che, però, diciamo, sono tutti bloccati, cioè nel senso che...
 l'ultimo avanzamento in sta cosa è tipo 30 anni fa, no? Cioè è una cosa che ormai abbiamo finito le idee, no? Cioè abbiamo, non mi metto tra questi perché non sono... non faccio teoria della complessità nella vita, però, diciamo, so che le persone che fanno ricerca in questo sono appunto, devo dire, ecco, ci sembrano che ci siano delle barriere, delle barriere intrinseche, tanto che la cosa è paradossale, cioè nel senso che se riuscirò, diciamo, ogni tanto riesco alla fine del corso a parlare un po' di queste cose,
 questa cosa che secondo me è veramente una delle cose più affascinanti, no? E... cioè la gente è diventata così frustrata, no? Che non riesce a dimostrare che B non è uguale a NB, che ha cominciato a dimostrare perché è difficile dimostrare, cioè quella cosa di... ma è la dimostrazione, e ci stanno beve su peve, non so se è così, cioè... non sai che fare, diciamo, allora... No, adesso scherzo, sono cose comunque profonde, no? E ti dicono qualcosa, no? Però, cioè, per dire...
 quella cosa di B non la sappiamo dire. Va bene? E... questo. E... va bene, l'ultima cosa che vi dico, ci sta bene, ve la dico, però, diciamo, non ne parleremo in questo corso, è il fatto che poi queste cose che studieremo, diciamo, in teoria della complessità, valgono per un determinato modello di computazione, cioè quello della macchina, i Turing, e in particolare che segue le leggi della fisica classica, no? Ok?
 E... e niente, quindi, qualcuno ha postulato l'esistenza di una macchina, cioè di un computer, no? Che invece di usare i bit, usa gli stati quantistici. Ok? Cioè, quindi non è il bit 0,1, ma è una roba quantistica che tu fino a che non la misuri, non lo sai, e stai con tutti i possibili stati che hai.
 E... e quindi, cioè, i teorici hanno cominciato a dire, ah, se ci sta P, allora ci sta pure QP, non so come lo chiamano, cioè, quelle classi di problemi che possono essere risolti in tempo coloniale dalla macchina Turing quantistica, cioè questa è una che massifica i quantum bit, no? E insomma, questo qui che ha inventato sto modello, a un certo punto,
 negli anni 90 si è accorto che se sta macchina Turing quantistica soddisfa certe proprietà, ma lui può fattorizzare, capibile, no? Cioè, questo qui ha fatto un algoritmo quantistico che fattorizza in tempo polinomiale. Ok? Cioè, quindi, se cambiamo il modello di computazione, cambiano pure, diciamo, quindi, quello che sappiamo dire su determinati problemi. Noi non studieremo la computazione quantistica in questo corso, però, diciamo,
 continuerete il percorso, poi, alla magistrale, ci sono corsi che fanno quantum computing, anche nel nostro dipartimento, nel corso di laurea in informatica magistrale. E, vabbè, quindi, questa è una cosa affascinante, no? Perché, comunque, è affascinante perché, cioè, questo ha fatto un modello teorico, no? E, quindi, cioè, siccome adesso si dà il caso che la fattorizzazione sia un problema che è particolarmente importante per tutte le persone,
 cioè, tu dici, vabbè, ma questo problema, che me frega? Cioè, gliene frega solo ai matematici, che non sono capaci a risolvere la fattorizzazione. No, si dà il caso, invece, che poi sono arrivati i crittografi, no? E i crittografi hanno detto, ah, questi problemi difficili li possiamo usare per fare crittografia, no? Cioè, hanno avuto quest'idea, che, eppure, diciamo, è stata un'idea molto influente, e, quindi, diciamo, per esempio, uno dei primi problemi che hanno preso per fare crittografia è stato proprio factoring, per fare certo tipo di crittografia, no?
 Amazon, che voi fate per comprare la roba con la carta di credito, sono crittografate usando fattorizzazione, no? Cioè, quindi, insomma, c'è un po' di interesse a rompere questo problema della fattorizzazione, perché se lo puoi rompere vuol dire che puoi craccare tutti i codici del mondo, no? Cioè, adesso è un po', diciamo, riduzionista, questa cosa non è proprio così, non è che c'è solo la fattorizzazione, però è uno che, sicuramente, è stato, diciamo, quasi l'unico per decine di anni,
 old fashion, però, diciamo, ancora rimane in auge il problema della fattorizzazione, quindi sono tutti preoccupati che quanto un computer possa, cioè, quello ha fatto l'algoritmo che fattorizza, e, vabbè, allora costruiamolo, no? Cioè, adesso, giustamente, no? Dice, eh, lo dobbiamo costruire. E, beh, se non che, non lo sappiamo costruire. Cioè, non siamo capaci, no? Adesso, cioè, se leggete i giornali, sapete che tutti quanti parlano di quanto è compiuto, cioè, IBM, poi arriva Google, ho fatto il super,
 quanto il computer è fighissimo, tanti Qubit, poco rumore, tutta sta roba qua. Però, a semmetere ho fatto, no? Cioè, di fatto, qual è l'esperimento reale che ha implementato l'algoritmo di quel tizio lì degli anni 90, che si chiama Shorn, che ha fatto la fattorizzazione per fattorizzare, l'hanno implementato, no? Usando il best computer che ci poteva esistere, l'hanno fatto qualche anno fa, e hanno fattorizzato 21.
 Questo è il record, 21. E, vabbè, io adesso, cioè, non mi sbilancio, perché non mi occupo di computazione quantistica, ok? Quindi, non lo so. Quello che succederà tra i miei 50 anni, non lo so. Però, conosco gente che proprio ci sta dentro, e ho sentito dire cose diverse. Ho sentito dire gente che dice, sì, sì, sì. C'è un giorno, una barcelletta, no? Che si racconta, diciamo,
 tra i nerd che parlano di computer quantistici, no? Si dice che il computer quantistico è sempre tra 5 anni, no? I prossimi 5 anni. Ok? Sono tipo i 15 anni che si dice che tra 5 anni è il mio computer quantistico. E, niente, quindi, c'è gente che dice che non arriverà mai. Ci sono dei limiti interi, comunque il rumore è impossibile, non si farà mai. C'è gente che dice, no, no, ci stiamo quasi. Ok, cioè, non lo so, quindi non so a chi credere. Io pure non lo so.
 Però, diciamo, questo è lo stato dei fatti ad oggi, no? Se non che, però, diciamo, queste cose sono anche poi importanti nel mondo, no? Cioè, non è che, cioè, perché appunto, cioè, la criptografia usa la fattorizzazione. Tutti quanti cipriamo e mandiamo cose private usando la fattorizzazione. Quello ha fatto il computer quantistico, cioè, l'algoritmo quantistico. Sì, ok, non abbiamo ancora costruito, però forse dovremmo cominciare a fare qualcosa. Infatti, chi fa gli standard del criptografio, già da 3-4 anni, ha cominciato a dire no.
 No, no, no. Cioè, almeno, creiamo delle alternative che siano robuste anche in presenza di un computer quantistico. Perché la cosa interessante è questa, che esistono problemi che invece non sappiamo risolvere manco con un computer quantistico ideale, cioè, quello che ancora non abbiamo costruito. Ok? Cioè, per alcuni problemi, pure i matematici hanno studiato per millenni, no? E quelli non li sappiamo, cioè, sappiamo fare l'algoritmo quantistico, però quello va come quello classico. Cioè, non c'è nessun...
 Lo sappiamo, magari c'è un altro algoritmo, cioè, però, per alcuni problemi non abbiamo nemmeno un algoritmo quantistico. Allora, chi fa gli standard del criptografio ha cominciato a dire ok, usiamo questi problemi, no? E standardizziamoli, perché così siamo pronti, no? E sai, cioè, se devi cambiare tutta la criptografia del mondo, cioè, non è che lo fai oggi e lo dici e domani lo fai, no? Cioè, ciò vogliono 20 anni, no? Quindi, allora, cominciamo già adesso. Anche se quanto un computer ancora sembra una minaccia un po', forse lontana. Va bene? Ok. Ok, ho finito.
 Ho finito di raccontare tutte le storie che vi volevo raccontare. A questo punto, diciamo, questo è un po' l'overview di quello che faremo nel corso. E... E... E quindi iniziamo. Iniziamo da... Dai, vado. Ok. E oggi abbiamo tre ore, no? Cioè, cominciamo un po' e poi faremo una pausa, ovviamente. Ci sono domande?
 Ci sono domande? Prego. Sì. No, questo, purtroppo, non è così semplice la questione. E... Diciamo, quindi la domanda è, no, se P fosse uguale a NP, quanto un computer, pure se l'ho costruito, un punto via, no? E... Purtroppo non è così, cioè, la risposta dipende, no? Cioè, ovviamente, se P fosse uguale a NP,
 in maniera pratica, quindi non solo, diciamo, teoricamente asintomica. Cioè, il problema è poi che passare, diciamo, da queste definizioni che sono molto generali, no? E... E... E quindi, per essere generali, non guardano ai numeri concreti, non guardano a un comportamento asintomico. Cioè, di fatto, questo che significa? Che se P è uguale a NP, no? Vuol dire che ogni problema con la fattorizzazione è NP. Quindi esiste un algoritmo che fattorizza, no? E questo c'ha tempo di esecuzione che è monominaline.
 Cioè, monominali in N è positivo. N elevato a una cosa, no? Se quella cosa è una costante astronomica, ok? Molto elemento. Cioè, capito? Cioè, quindi, le costanti potrebbero fare... Potrebbero essere vero che è più o meno... Quindi, magari, quando... Io, invece, te lo faccio una costante molto più... Non è detto? No, aspetta. Ok. E... Che volevo dirvi? Domande? Altre domande? Ok.
 Io penso che siano argomenti super interessanti, no? Cioè, almeno, diciamo, ovviamente, a livello, non lo so, filosofico, alto livello, sono sicuramente argomenti affascinanti. Diciamo, d'altra parte, cioè, sarò onesto, diciamo, questa è un forzo che comunque richiede... Cioè, non è facile da digerire. Cioè, formalizzare le cose, cioè, definizioni, teoremi, insomma, è una cosa che richiede... Prego. Troppo, una domanda, ma le slide le carica da qualche parte? Certo.
 Sì, non le chiamerei slide, no? Perché, diciamo, io dico... Cioè, io dico sempre, diciamo, io, ovviamente, le carico, no? Perché ce l'ho qua, non mi costa niente, le metto sui... Però è come se facessi lezione alla lavagna, no? E facessi la foto, diciamo, della lavagna. Quindi, non ho la pretesa di chiamarle slide, perché, cioè, a me si dice, ma sai che slide... Cioè, è giusto, se uno lo vede all'esterno, dice, ma questo che slide ha fatto? Non le chiamerei slide. Però, sicuramente, le metterò, diciamo...
 Quello che piace a me per fare il modo con cui io faccio i corsi, diciamo, che è un po' come piaceva a me quando facevo i corsi quando ero studente, era che io mi prendevo gli appunti, no? E quello che mi bastava per fare l'esame era quello che avevo scritto sul mio quaderno, no? E un po', cioè, questo ce l'ho, cioè, quindi è un difetto mio, no? Penso così di nascita, no? E quindi, cioè, faccio in questo modo che se tu scrivi praticamente tutto, il libro, non comprarlo, cioè, perché alla fine è...
 Spero di riuscire a fare questo, cioè, questo è il mio obiettivo, no? Perché comunque poi è un corso, diciamo, che è abbastanza teorico, no? Cioè, è un corso di teoria, no? Cioè, teoria della computazione, no? Secondo me, per questi corsi, diciamo, scrivere le cose e, diciamo, digerirle insieme agli studenti ogni volta, no? Secondo me, sì, è faticoso, no? Però è molto meglio della slide sparata lì, che poi sta dormendo, non lo so, è... Quindi, sì, comunque sì, saranno online, non le chiamo slide,
 però ci saranno e comunque sul libro c'è tutto, cioè, il libro pure è un'altra cosa che... Poi dipende che tipo di studente sei, no? Però il libro è fatto veramente bene, no? Cioè, se tu sei uno che si mette lì, fa gli esercizi, si chiude e capisce, è certo difficile, cioè, pure un po' frustrante, forse, però, cioè, è veramente scritto tutto, è fatto veramente in maniera precisa, no? Però la lezione, secondo me, è un plus pazzesco, cioè, venite a lezione, no?
 Magari qualcuno invece legge il libro, perché si libera qualche posto, no? No, cioè, secondo me, la lezione è un'altra, no? Perché c'è qualcuno che queste cose te le racconta e, diciamo, le assorbi in maniera graduale, no? Non lo so, sai quando è il momento giusto di fermarti e fai le domande quando non capisci, o fai un altro con la domanda e tu capisci meglio, cioè, queste cose qua, cioè, secondo me, va bene, è poi il bello dell'università, no? Va bene.
 E... Ok, quindi, diciamo, sarà lavoro abbastanza duro, cioè, un po' duro, eh? E... cioè, quindi, in particolare, cioè, non ci sono pre-requisiti, però, cioè, dall'altra parte, non è che ti devi... vabbè, molto devo sapere chissà che, no? Cioè, anzi, tutti i corsi che avete fatto, sicuramente, metodi matematici, questa roba qua, cioè, non è che devi sapere grossi cose, cioè, diciamo, al massimo ci sta qualche prova per intuizione, ci stanno linguaggi e stringhe binarie,
 potenze, concatenazioni, tutte cose che, diciamo, avete... cioè, sicuramente avete le basi, no? Però, diciamo, è difficile digerire perché devi fare un modello, devi definire le cose precisamente, no? Cioè, per essere preciso devi essere giusto, no? Ok? Va bene. Perfetto. Quindi, diciamo, il primo argomento, parliamo di automi, no? Iniziamo con gli automi. Sicuramente, il primo argomento che trattiamo, che trattiamo negli automi, è quello dei linguaggi regolari, ok?
 Ok? Cioè, come dicevo, definiamo il primo modello che consideriamo, no? Il primo modello, il primo modello, che è quello che si chiama automa, ha stati definiti. Ok? Questo, diciamo, infatti, in inglese,
 lo trovate scritto come DFA, ok? Dove la D, diciamo, ha un significato un po' più profondo, che si chiama deterministico. Vedremo adesso che significa, nemmeno dire che ve lo spiego adesso. Però F significa finite state, stati finiti, e A significa automa. Va bene? Quindi, automa ha stati finiti di tipo deterministico, no? Perché c'è pure quello non deterministico, ok? Questa è esattamente la cosa che c'è, la differenza che c'è tra P e NP.
 La stessa N e D, diciamo, sono, diciamo, significano una cosa ben precisa, e avremo modo di vederla in dettaglio a breve. Come vedremo, è semplice, semplice, semplice perché ha due caratteristiche, diciamo, perché, diciamo, ha una quantità di memoria che di fatto è limitata, ok?
 E' semplice nel modo in cui proprio processa i dati, no? Ok? Cioè, cioè, tu quando pensi al computer, no? Cioè, il computer, allora, se legge un input, lo può mettere in memoria, poi lo può salvare, può prendere un bit, prima legge il bit 100, poi quello 0, poi lo sovrascrive da una parte, lo mette, no? Queste cose, l'automa non fa niente di tutto questo. L'automa, infatti, processa l'input così, boom, on the fly. Legge il primo, il carattere, poi il secondo, poi il terzo, l'unica volta torna indietro, ok?
 Cioè, quindi, ecco, questa, però, questa semplicità, d'altra parte, come dicevo, siccome ci sono cose che può fare molto bene l'automa, questo è importante perché allora poi, appunto, lo posso usare per fare i parser, lo posso usare per fare i riconoscitori di pattern di testo, no? Ok? Queste cose qui, e lo posso fare in maniera efficiente, non c'è bisogno di fare cose complicate che vanno avanti e indietro, che hanno una memoria. Leggo, decido, ok? Questo è semplice, diciamo, processa input,
 bit a bit, in modo sequenziale. Ok? Dico, bit a bit, se il linguaggio è in bit, cioè, se l'input è in bit, potrebbe pure non essere in bit. E, diciamo, per capire anche un po', dal punto di vista pratico, che corrisponde a un'automa, facciamo un esempio.
 Lo trovate anche nel libro, questo esempio. Cioè, abbastanza istruttivo, no? Un esempio fisico, diciamo, no? Cioè, è quello del dispositivo, dispositivo, apertura, porta, automatica, no? Cioè, quel sensore che sta lì e che decide quando la porta si apre e quando la porta si chiude, no? Ok? Cioè, questo, diciamo, di fatto, lo puoi vedere come una cosa di questo tipo.
 Cioè, questo è praticamente, è un algoritmo che tu devi, devi programmare in modo che quando succedono certi eventi, fa certe cose, no? Ok? Cioè, tipo, la porta è chiusa, cioè, stavamo davanti, apro, prendi, ok? La porta è chiusa, non c'è nessuno, ma è chiusa. Ok? Cioè, queste cose qua, no? Allora tu li puoi prendere tutte le possibilità, no? Le scrivi in una tabella e hai fatto, no? Ok? Cioè, questa è l'idea, no?
 La porta va così, chiusa. Poi c'è il tizio lì davanti, cioè, quindi c'è il tizio davanti, questa è la porta, e qua non c'è nessuno, allora questo fa così, che siccome c'era questo qui qua davanti, la porta non si apre. Ok? Va bene? E... E... E niente, cioè, per esempio, ne so, se sta così,
 e se la porta è aperta e non c'è nessuno, la porta si chiude, no? Giusto? Ok. Allora, adesso puoi fare questa tabella, no? Cioè, puoi fare una tabella, adesso, cioè, ve la accenno, questa tabella, però, diciamo, adesso, diciamo, non è così importante, diciamo, completarla tutta, no? Però, penso che ci siamo capiti, no? E... Cioè, come posso dire, no? Allora, non c'è nessuno, no? Oppure... E...
 Ops. Diciamo, qua sopra, non c'è nessuno. Oppure, c'è qualcuno davanti. Ok? Oppure c'è qualcuno dietro. E... Oppure, tutto è duro. Ok?
 Va bene? E qui, c'è un... Un... Cioè, se, per esempio, è... è chiuso e non c'è nessuno, rimane chiuso, no? Ok? Se... è chiuso e c'è qualcuno davanti, va in aperto, no? Ok? Eccetera, eccetera, eccetera, no? Cioè, mi posso mettere tutti a seconda, poi, di quello che voglio fare, no? Ok? Quindi, alla fine, però, cioè, è come se posso fare questa cosa qua, no? Cioè, ho... Quindi, c'è una tabella, no?
 Posso fare tutta la tabella. Ok? Quindi, adesso, di fatto, e... Siccome c'è una tabella, la posso anche rappresentare in un altro modo. Ok? E... Infatti... E... Cioè, di fatto, quindi, la porta può stare in due stati. O sta aperta, o sta chiusa. Ok? E... Ci sono delle transizioni, no? Tra questi stati, che sono quando la porta sta aperta e diventa chiusa, o sta chiusa e diventa aperta, oppure sta aperta e rimane aperta, oppure sta chiusa e rimane chiusa. Ok?
 Questi sono gli eventi che causano i passaggi di stato, no? Ok? Cioè, sono gli input. Ok? È come se, quindi, il programma ha i suoi stati. E, a seconda di quello che legge come input, fa dei passaggi di stato. Ok? Cioè, infatti, lo potrei... Lo posso disegnare così. Cioè, adesso, lo disegno in maniera alternativa, così. Aperto, chiuso. Quindi, c'è lo stato. Lo stato, solitamente, si rappresenta così, con un cerchio, no? Ok? A questo punto, ci sono le frecce, no? Che dicono...
 Se è aperto e non c'è nessuno, ok? Diventa chiuso. Ok? E... Se, invece, è chiuso e c'è qualcuno davanti, diventa aperto. Ok? E ce ne sono altre, no? Adesso, io, cioè, non ce le voglio neanche scrivere tutte, no? Perché, poi, non voglio perdere...
 20 minuti a disegnare gli stati qua. Però, potrei provare a esserci delle frecce così, no? Ok? Va bene? Eccetera, eccetera, no? Scrivo eccetera. Eccetera, no? Non l'ho completato tutto, ok? Perché... Lascia un po' il tempo che trovi. E... Però, eh... Però, diciamo, questo è il primo esempio di un'automat. Ok? Cioè, un'automat. Quindi...
 È una cosa che, appunto, è... A livello informato. Cioè, qui siamo a livello... Stiamo cercando di avere un'intuizione per capire come lo dobbiamo definire. Ok? Questo è un modello di computazione. Quindi, c'erano degli stati. Ok? Un numero finito di stati. E... E... A seconda di quello che legge, farà dei passaggi di stato. Ok? Ci sarà uno stato speciale. Esatto. Che si chiama lo stato di accesso.
 Ok? Cioè, quindi... Questo perché... Perché... Vogliamo dire... Eh... Vogliamo capire... Dato un linguaggio... Quindi, parleremo di... Parleremo di linguaggi. Ok? Cioè, i linguaggi saranno insieme di stringhe di un certo tipo, con certe proprietà. Ok? Tipo, tutte le stringhe... Che... Cominciano con zero. E finiscono con uno. Ok? Tutte le stringhe binarie...
 Che cominciano con zero e finiscono con uno. È il linguaggio. Tutte le stringhe binarie che hanno lo stesso numero di zero e lo stesso numero di uno. È un altro linguaggio. Ok? Si parla di linguaggi. Ok? In... In... Informatica teorica. Cioè, sono insiemi di stringhe. Insiemi di input con certe caratteristiche. Che tu vuoi riconoscere. Ok? Dicevamo, no? L'applicazione del riconoscere i pattern nei flussi di dati. Ok? Tu vuoi riconoscerlo. Che significa vuoi riconoscere? Vuol dire che... Vuoi fare un semplice algoritmo. Un'automa. Ok?
 Che... Legge l'input on the fly. Così. E alla fine, dopo che ha finito... Decide. Sta dentro al linguaggio o no. Ok? Questo è l'automa. Ok? Quindi... Sì. Con certe caratteristiche. Per adesso. Adesso l'ho detto così in maniera... All'acqua di rosa. Poi lo definirò adesso. Cos'è un linguaggio. Ok? Però, diciamo, in generale... Astraendo. Ok?
 Una cosa di sopra. Astraendo. Ancora non sto dando definizioni. Non sto cercando di portarvi lì, diciamo, piano piano. Astraendo un'automa. Un DFA. È fatto così. Sarà fatto così, no? Ad esempio, se il linguaggio è binario. Ok? Cioè, quindi... Legge una stringa. Sarà fatto in questo modo. C'era uno stato di inizializzazione. Diciamo, start. Inizia da qui, no? Poi...
 Ci sarà, per esempio... Gli stati si chiamano Q. Di solito. Come notazione, diciamo. Gli stati sono chiamati Q. Q1, Q2, Q3. Ok? Quindi c'è Q. E questo è uno stato. Cioè, quando inizia... Sta nello stato Q1. Ok? Di partenza. E... A questo punto... Ci potrebbe essere anche uno stato Q2. E ci potrebbe essere anche uno stato Q3. Ok? E...
 Ok? Sto facendo un esempio, eh? Cioè, ok, quindi... Prima vi faccio vedere un esempio di automa. E poi vi do la definizione di automa. Ok? Quindi un automa è una cosa che sarà fatta così. C'era degli stati. Q1, Q2 e Q3. Bene. Alcuni di questi stati possono essere speciali. Sono gli stati di accettazione. Ok? E sono questi qua. Quelli che, diciamo, di solito si fanno così, no? Cioè, tipo Q2 è uno stato di accettazione. Ok?
 Questo significa che... Quando quello ha terminato di leggere... Se sta in quello stato... In uno di quegli stati... Dice... Ah! Accetta. L'automa accetta. Ok? Cioè, l'automa decide se la stringa ha una certa proprietà. L'automa decide se deve aprire la porta o la deve chiudere. L'automa decide se... Il parser del compilatore ha rifatto bene la sintastica. Ok? Cioè, è la stessa... Ok? Quindi... L'automa...
 Ha questi stati. Poi... Ha... A seconda di quello che legge, fa cose diverse, no? Cioè, tipo... Per esempio... Se sta in Q1 e legge 0... Rimane in Q1. Ok? Non lo sto a inventare. Cioè, non è che è sempre così. Sto facendo un esempio. Potrebbe essere così, no? Sta in Q1. Legge 0. La stessa cosa che legge 0. Ok. Rimane in Q1. Ok? Se invece... Legge 1... Va in Q2. Ok? E poi... Continua, diciamo...
 A leggere, no? E... Se poi sta in Q2 e legge 1... Per esempio, rimane in Q2. Se legge 0... Va in Q3. Se sta in Q3 e legge 0 oppure 1... Va in Q2. Ok? Che ne so. Questo me lo sono inventato, no? Va bene. Cioè, quindi adesso... Che significa che... Cioè, diciamo alcune cose, no? Q1... Q2... Q3... Sono detti stati. Sono stati della...
 E... Q2... È... Stato... Di accettazione. Va bene? E... Gli archi... Sono dette... Sono le transizioni. Ok? E...
 Vediamo, per esempio... Facciamo un esempio. Supponiamo che, per esempio, quest'automa... Deve leggere... La stringa... 1... 1... 1... 0... 1... Ok? Va bene? Quindi questo che fa? E... Comin... Ah, questo qui... E...
 Adesso... Che fa? Cioè... Parte all'inizio... E... Poi... Bit a bit... Vedi che... Come transiscono gli stati... E... Alla fine... Vedi se arrivi nello stato di accettazione o no. Se arrivi nello stato di accettazione... Accetti. Per esempio, accetta quest'automa. Perché parte dal Q1. Poi... Legge 1... No? E va... In Q2. Ok? Legge da sinistra... Adesso. Ok? Va in... Q2. Poi... Legge 1... 1... Fino a che legge 1... Il Q2 rimane sempre in Q2. Poi va a 0... Che lo porta in Q3. E alla fine... Legge 1... Che lo porta... In Q2.
 Ha finito di leggere... Accetta. Ok? Se finiva di leggere... Cioè... Se ci mettevo un altro 0... Per esempio... Dopo... Allora... Si fermava in Q3... E non accettava. Va bene? Sì. Posso essere anche più di 1. Non insieme. Non conta. No. Esatto. Perché non ha finito di leggere. Ok? Quando finisce di leggere... Che stato sta? Se è di accettazione... Accetta.
 Quando non è di accettazione... Non accetta. Ma... Per esempio... Q3 non è di accettazione. No. Q3 non è di accettazione. Manco Q1. Cioè... Quindi... Se questo qui... Per esempio... Legge solo... 0... Non l'accetta 0. Perché... Parte... Q1... Ok? Legge 0... Rimane in Q1. Ha finito. Eh... Non accetta. Ma... Accetta vuol dire che... Da un output? No. L'output in questo caso... È soltanto un bit. Possiamo pensare come un bit. Quindi... In realtà... Quindi... Stiamo facendo... Stiamo cercando di risolvere...
 Un problema ancora più semplice. No? Cioè... Non solo stiamo facendo un modello... Di computazione semplice. Ma stiamo facendo un algoritmo... Che non calcola. Decide. Ok? Infatti si chiama decisore. No? Cioè... Decisore significa che lui... Gli dai input e tutto... E dice... C'ha qua la proprietà... O non c'ha. Ok? Questo significa... O accetta o rifiuta. Non è che scrive la roba... Oppure... Ok? Come vedremo... Eh... Beh... Gli algoritmi invece... Possono pure calcolare le funzioni. No? Cioè... Infatti... Poi quando parleremo di macchina di Turing... Vedremo che...
 Infatti... Le macchine di Turing... Non solo possono decidere... Ma possono pure calcolare... Le funzioni. Però allora... Ci devono avere un output... Non devono avere la possibilità... Di scrivere un output. Questo... L'automan ce l'ha... La possibilità di scrivere l'output. Lui legge... E... Cambia gli stati... E alla fine... Accetta o rifiuta. Basta. Finito. Domande? Tutto chiaro? Ok. Allora... Vi do la definizione... E poi ci fermiamo... Per una pausa. Ok? Adesso vi do la definizione...
 Di automa. Ok? Cioè... Definizione... Questo è... L'automa. Cioè abbiamo detto... DFA. Ok? E... E la definizione recita... Un DFA... È... Una tupla. E... Che chiameremo fatta così. È fatta da una serie di cose, no? Q... Sigma... Delta... Q...
 Zero... E F. Va bene? Che cos'è un automa? È questo. Una tupla. Q... Sigma... Delta... Q... Zero... E F. Dove? Q... Sarebbe l'insieme... Finito... Degli stati. E... Sigma... Sarebbe... E...
 L'alfabeto dell'input. L'alfabeto... Alfabeto... Input. Cioè sarebbe l'insieme... E... Finito... Simboli... Dei simboli... In input. Ok? Cioè sarebbe l'alfabeto, no? Ok? Sigma... Delta... È una funzione... Che prende uno stato...
 E... Un carattere sigma... E mi porta... In un altro stato. Ok? Cioè delta... Sarebbero le transizioni. Cioè quelle che abbiamo... Come abbiamo visto qua... In questo disegno, no? Quindi... Cioè per ogni stato... Io so che se leggo zero... Faccio una cosa. Se leggo uno... Ne faccio un'altra. Questa è la delta. Cioè la delta... È una funzione... Questo lo vuoi formalizzare... Come una funzione... Che prende in input... Un possibile stato. Q... Quindi... È un possibile carattere... Sigma...
 Quindi va... Il dominio è Q per sigma... No? E mappa... In Q. Perché ti dai in output uno stato. Giusto? Cioè ad esempio, no? Nel caso precedente... Eh... Vabbè... Vi faccio vedere dopo l'esempio. Quindi delta è questo... Q0... Q0... Stato iniziale... E F... È contenuto in Q... No? Ed è l'insieme...
 Degli stati finali. Stati... Finali... Anche detti di accettazione. Va bene? Basta. Questa è la fine della definizione. Ok? Cioè quindi... Un DFA... È una funzione... Q, sigma, delta... Q0, F... Dove Q è l'insieme finito degli stati. Sigma è l'insieme finito dei simboli... In input delta... È la funzione di transizione. Ok? Cioè quella che mi dice... Dato uno stato... Quando leggo un simbolo...
 Q0 è lo stato iniziale... E F è l'insieme di stati finali. Ok? Quindi ad esempio... Eh... Nell'esempio precedente... Posso tornare qua forse? Eh... Vabbè... Ve lo commento diciamo, no? Beh... Anzi ve lo posso anche scrivere qua. Cioè... Quindi vabbè... Ovviamente, no? Cioè in questo caso qua... In questo caso qua... Gli stati... Q sarebbero Q1, Q2 e Q3. Poi... Sigma è 0.
 Giusto? Cioè... Sigma... Uguale 0, 1... E... Q... Sarebbero... Q1, Q2... Q3? No? Eh... Q0 sarebbe Q1. Giusto? Perché quando inizia stai... E poi c'è la delta, no? Posso dire di qual è la delta? 0, 1... Eh...
 Q1... Q2... Q3... E' una tabella sta delta. Tutte le transizioni. No? Cioè per esempio... Se sto... In Q1... E leggo 0... Rimango in Q1. Se sto in Q1... E leggo 1... Vado in Q2. Se sto in Q2... E leggo 0... Vado in Q3. Se sto in Q2... E leggo 1... Vado in Q2. Sbagliato?
 Eh... Giusto. Sbagliato qualcosa? No. Ok. Se sto in Q3... E leggo 0 o 1... Vado sempre in Q2. Ok? Cioè la delta non è altro che... Una tabella... Eh... Che mi dice tutte le cose. F... E... E' uguale a Q2. Ha senso?
 Sì, era un esempio arbitrario. In questo caso. Esatto. Avevo fatto un esempio... Sono partito da un esempio... Per spiegare la definizione. Però come vedremo... Infatti... Cioè questa è un'ottima domanda, no? Cioè nel senso... Che in realtà... Eh... Cioè noi vorremmo... Progettare degli automi... Che fanno certe cose. Allora quando dobbiamo progettare... Un'automa che fa certe cose... Noi progettisti dobbiamo decidere... Ok... Questo è Q0... F è così... Le transizioni sono così... Così... Così... Così... Così... Perché se no non va bene. Ok? Cioè però questo... Non viene da... Va bene?
 Facciamo un break.
 Ok? Questo si chiama... Il linguaggio riconosciuto dall'automa. Sì, sì, sì. Ok? Vorremmo avere un modo preciso... Per definire questa cosa. Va bene. E... Sì. Un po' rimane... Cioè ne segui... Una vicina... Sì, sì. E... Un'automa. Sì. Insieme.
 Il string... Riconosciute... Da M... Si denota... L in M. Ok? Ovvero... Il linguaggio...
 Riconosciuto... Ok? Quindi... Questa è... Il modo di dire... No... Abbiamo definito... L'automa. Ok? A questo punto... Dato ogni automa... Ok? Dato ogni automa... Gli posso associare... Un linguaggio. Ok? Cos'è? Il linguaggio associato... A quello che si chiama... L in M. E cos'è il linguaggio associato all'automa? È semplicemente...
 L'insieme di stringhe... Che quell'automa riconosce. Che quell'automa accetta. Ok? Cioè quindi... Un'automa... Riconosce... Accetta... Tante stringhe. Può accettare tante stringhe... Ma riconosce un solo linguaggio. Perché il linguaggio... È l'insieme di tutte le stringhe... Che lui... Accetta. Va bene? Sì. È chiaro. Potrebbe anche essere... Può essere... Che... L...
 È uguale a... L'insieme di U. Non è scontato. Potrebbe essere... Che non riconosce nessuna stringa. Va bene? Scusi prof. Sì. Riconosciute da M su... Si denota. Ah, si denota. Si denota. Si denota con la linea. Adesso però lo definiremo in maniera più precisa. Cioè io... Invece di scriverlo così... In maniera verbosa... Cioè daremo una definizione precisa... Di quello che significa... Il linguaggio... Delle stringhe... Associate... A un automa. Come si fa a definire, no?
 Questa è una definizione... A parole, no? Va bene? Cioè ad esempio... Ehm... Esempio... Se non sbaglio... Ehm... Il linguaggio precedente... Sui automa... DFA precedente... Precedente... Ehm...
 Dovrebbe essere, no? Che... Il linguaggio precedente... Ehm... Ha il linguaggio... Delle stringhe... Delle stringhe... W... Tali che... W contiene... Almeno...
 Un... Un... Uno... E... Numero pari... Di zero... Segue... Ultimo... Uno. Ok? Dovrebbe essere così. Cioè... W all'iniziale delle stringhe... Che contiene... Che contiene almeno un uno... E numero pari di zero... Che segue l'ultimo uno. Questo qua.
 Ok? Contiene almeno un uno. Ok? Perché... Se non c'è almeno un uno... Può dire... O è buona... O è fatta... Tutti i zeri. E infatti... Tutti i zeri... Non viene mai accettato. Quindi ci deve stare... Almeno un uno. Ok? E inoltre... Se guardi l'ultimo uno... Cioè... Quando sta in Q2... Devi stare per forza in Q2... Perché... Ha letto almeno un uno... E... Se... Ehm... Se leggi uno... Ci rimani sempre... Se leggi zero... Poi io... E leggi l'altro uno...
 Poi ci ritorni... Quando sei arrivato all'ultimo uno... Questo può essere eseguito... Soltanto dal numero pari di zero. Cioè... Non sarà... Una stringa che finisce... Con uno zero... Non sarà mai accettata... Da quest'automa. Ok? Mai. Va bene? Si può vedere questa cosa. In realtà... Questa cosa... Si può pure dimostrare... In maniera precisa. Cioè... Di solito... Cioè... Questa è anche una cosa importante. Cioè... Quando fai un'automa... Ok? Ehm... Lo fai... Perché segui il tuido... E...
 Ti basi su certi input... No? E capisci come deve... Come deve... Transitare... No? Tra i diversi stati... A seconda degli input... Di quello che legge... No? Però... Cioè... Spesso non è così facile... Dire no... Questa è l'automa... E questo riconosce... Questo linguaggio qua... No? Quindi una cosa... È dirlo così... Ha senso... E una cosa invece... È dimostrarlo. Cioè... Dimostrarlo significa... Dimostrare che... Se l'input ha quella forma... L'automa accetta.
 Non solo... Se l'automa accetta... Allora l'input ha quella forma. Ok? Se e solo se. Ok? Cioè... Le istanze sì... Sono accettate. Le istanze no... Non sono accettate. Questo significa dimostrare... Che un'automa è corretto. Ok? E questa è una cosa importante. Va bene? Vedremo degli esempi... Quando faremo esercizi. Ok? Di questa cosa. Va bene? Cioè... Per adesso... Ve l'ho detto così... A parole. Però... Questa cosa che ho raccontato... Si può in realtà dimostrare. In maniera più precisa. Cioè... Dato quest'automa... Quello è il linguaggio che riconosce. Ok? Accetta tutte e sole...
 Le stringhe. Ok? Tutte e sole quelle stringhe. Questo è il concetto di linguaggio. Cioè... Il linguaggio... Sono tutte e sole le stringhe... Che l'automa accetta. Va bene? Per esempio... Adesso... Vi lascio un piccolo esercizio. Esercizio... Secondo voi... Dato quest'automa...
 Uno... Due... E... Zero... Uno... Zero... Uno... Questo è... M... L di M... Uguale... Punto in troia. Cioè... Secondo voi... Come lo descriverei... Stesso linguaggio... L di M. Provate a descrivere... L di M... Di quest'automa. Va bene? È un esercizio.
 Ok? C'è il dato in automa... Che il linguaggio riconosce. Va bene? Ok. Cerchiamo di definirlo adesso... In maniera un po' più... Più precisa. Va bene? E... Per farlo... Cioè... Per dare una definizione... Per definire... Eh... Precisamente... Il linguaggio... Il... Il linguaggio... Introduco...
 La... Funzione... Di... Transizione... Estesa. Ok? Ok? Introduco... Cioè... Perché... Voglio formalizzare questa cosa... Che... Il linguaggio è l'insieme di stringhe... Accettate dall'automa. Che significa? Vuol dire che... È l'insieme di tutte quelle stringhe... Tale che... Se eseguo l'automa...
 Su quella stringa... Ci sarà un passaggio di stati... No? Tale che alla fine... Mi porterà... A uno stato di accettazione. Voglio definirla... Cioè... Voglio dare una definizione precisa... Di questa cosa... Per definire esattamente... Cos'è un linguaggio. Usando soltanto... La definizione di automa. La definizione che abbiamo da... Per farlo... Devo poter ragionare... Sulla funzione di transizione... Non quando leggo un solo carattere... Perché la funzione di transizione... È un solo carattere. Adesso voglio ragionare... Invece... La funzione di transizione... Quando leggo due caratteri... Tre caratteri... Quattro caratteri... La voglio estendere...
 A tanti caratteri. Ok? Questa si chiama... Funzione di transizione estesa. Ok? E infatti... Nella nota con delta star... Che va... Da... Q per... Sigma star... In... Q1. Ok? Cioè... Invece di prendere... Quindi la funzione di delta... Prende... Un Q... E un sigma. No? E ti dice... Qual è il prossimo Q. La funzione di delta star... Invece... Dice... Sto nello stato Q. E poi... Leggo... Qualsiasi sigma.
 Star. Cioè... Un potere che legge... 1, 1... 1, 0, 0... 1, 1, 1... 1, 1, 1, 1, 1... Ok? Qualsiasi cosa. E ti dice... In che stato vai a finire. Ok? Quindi stai... Compattando... Più passaggi di stato... Su più simboli... In un solo... In una sola computazione. Ok? Perché questo è utile... Perché a questo punto... No? Come definirò... Tutte le stringhe... E che accetta... Saranno tutte quelle... Dalle che mi portano... Delta star... Dallo stato iniziale... Allo stato finale.
 No? Ok? Questo sto cercando di fare. Ok? E... E la posso definire... In maniera ricorsiva. No? La definisco così. Dico che... Delta star... È fatta così. Cioè che... Quando c'è un simbolo solo... Delta star... Cioè... Nel caso banale... Diciamo... Delta star di Q epsilon... È semplicemente... La delta di Q epsilon. Ok? E... La delta di Q epsilon...
 È semplicemente... Delta star... Di Q... E poi... Diciamo... Ax... No? Questa è definita come... La delta... Star... In maniera ricorsiva... Dello stato... Di... Scusate... Di... Dello stato delta di Qa... No? Virgola x. Ok? Dove in questa definizione... X appartiene a sigma star. Mentre A... Appartiene a sigma. Ok? Cioè... Quindi la delta...
 Delta star... Abbiamo detto... Prende uno stato... E un insieme di simboli. No? Questi insiemi di simboli... Scriviamoli... Scriviamoli come... Il primo simbolo... E poi tutto il resto. No? Ok? Il primo simbolo è A. Quindi A... È un solo simbolo. X... È tutto quello che viene dopo. Insomma... Allora... Come faccio a capire la delta star... Di Q... Ax? Beh... Semplicemente... Faccio prima la delta di Qa. E quello è il prossimo stato. E poi ricorsivamente... Applico delta star... Adesso... A quel risultato... E poi x. Ok?
 Prendo x. Adesso... Leggo il primo carattere. Come è definita delta star... Di Q primo x? Ci sarà Bx primo. Non lo so. È continuo. A un certo punto... È voto. Allora vado nel caso base della ricorsione... E ho finito. Ok? Esatto. Il processo... Lo faccio semplicemente... Applicando la delta... Volta per volta. Carattere per carattere. No? È una definizione ricorsiva. Se sto facendo semplicemente questo... E...
 Ok? Benissimo. Quindi questa è la prima cosa. L'altra cosa importante... Altro concetto... Che serve per definire questa cosa... Altro concetto... È la cosiddetta configurazione. Ok? Cioè la configurazione... È... Come se fosse... Diciamo... Una fotografia... Dell'esecuzione... A un certo punto. Ok? Cioè la configurazione... È la fotografia...
 Cioè ti dice... È... Di fatto è una coppia... Una coppia... Che sta in... Q per sigma star. Ok? Sigma star è l'insieme... Di stringhe... Di carattere dell'alfabeto... Di lunghezza arbitraria. No? Perché sarebbe la potenza... Per qualsiasi... L'unione... Di tutte le possibili potenze.
 Di qualsiasi lunghezza. Comprese la strega vuota. Ok? Comunque... Questa cosa... Adesso... Quando poi... Subito dopo aver fatto questa cosa... L'ho data per scontata... Perché penso che l'avete... Già incontrato... In altri corsi. La star... La star di Klein... Come vuoi dire... Eh? No, non è così. Eh? Non avete mai visto star? Eh? Ah, c'è bravo!
 No, no. Questa è un'altra cosa. Va bene. Non vi preoccupate... Perché tanto comunque adesso... Quando parleremo poi... Di... Quali linguaggi di FA riconoscono... Definiremo formalmente... Come si fa a fare... Prendo un linguaggio... L'unione di linguaggi... La potenza dei linguaggi... E anche star. Ok? Quindi lo ridefiniremo. Ok? Cioè per adesso... Dovete pensare a... Sigma pensate 0,1.
 Ok? Per esempio... 0,1 star... Sono tutte le possibili stringhe binarie... In una qualsiasi lunghezza. Ok? Fino a infinito. Ok? Anche quella vuota. Cioè per esempio... La strega vuota... Poi... 0... Da solo... 1 da solo... 0,0... 0,1... 1,0... 1,1... 0,0,0... 0,0,1... 0,0... 0,1,0... Ok? 1,1,1... Poi 4... Poi di 5... Poi di 6... È l'unione di tutte le possibili potenze... Infatti per n viene finito. Ok? Sono tutte le stringhe binarie...
 Di qualsiasi lunghezza. Arbitrarie. Di qualsiasi lunghezza. Ok? Infatti un DFA... Questa è una cosa importante. Cioè il DFA... Riconosce linguaggi fatti di stringhe... Di lunghezza infinita. Perché non lo so a pregori... Quante è la lunghezza della stringa. Non è che posso fare un DFA... Che legge soltanto 10 bit... 20 bit o 50 bit. Perché domani voglio fare... Un terabyte. Dopodomani 10 terabyte. E tra 10 anni chi lo sa. Ok? Quindi lui funziona... Indipendentemente da quant'è la lunghezza dell'input. Non lo sa.
 In pratica certo sarà finito. Però in principio può essere infinito. Ok? Va bene? E lui le riconosce tutte... Quelle che hanno quella proprietà. E qualsiasi lunghezza. Non solo quelle di lunghezza 10. Perché è inutile. Ok? Cioè quindi il DFA... Fa una cosa... Che non è banale. Perché riconosce linguaggi... Di cui ci sono stringhe... Di qualsiasi lunghezza. Ok?
 Sì. Sì. Il linguaggio contiene... Stringhe di qualsiasi lunghezza. Ok? Potenzialmente fino al finito. Però lei quando eseguirà l'automa... La stringa ce l'ha sempre. La lunghezza finita. Ok? Perché l'automa deve iniziare... E se no... L'automa andrebbe avanti all'infinito. Ovviamente. Però... Questo significa che... Qualsiasi sia la lunghezza... E l'automa...
 lo sai quando lo progetti quello l'automa riconosce quel linguaggio si riconosce tutte le stringhe che hanno quella proprietà indipendentemente dalla loro lunghezza cioè non lo sai ma è una coppia delta star delta star ok
 quale stato in realtà quello che si ottiene con la sequenza di stati partendo dal primo carattere allo stato iniziale primo carattere poi quando lo stato eccessivo secondo carattere sta facendo tutti i pezzetti uno dopo l'altro ok quindi la configurazione invece dicevamo è una coppia u per sigma star ok che ti dice che ti dice questa coppia che contiene lo stato cioè in che stato stai adesso e che cosa devi leggere dopo
 1 e 2 Ok 1 lo stato e 2 cosa rimane da leggere cosa resta da leggere Va bene c'è un esempio Dato x in
 Sigma star ok allora è la configurazione iniziale E sarà 0 x Quella iniziale all'inizio in che stato sta l'automa 0 e definizione che
 gli rimane da legge x tutto x cioè l'input quella è la configurazione iniziale no ok Dopodichè che fa l'automa legge il primo simbolo vede quello che gli dice la delta e va in q1 ok quindi la sua configurazione sarà q1 e tutto quello che gli rimane cioè x è il primo simbolo e così via in qualsiasi adesso lo lancio no e poi lo fermo e faccio una foto in che stato sta
 ok sta in questo stato e che gli resta da leggere va bene ha senso quindi sono una serie di configurazioni no e adesso a questo punto è un passo di posso dire quello che fa un passo di computazione no ok un passo di computazione un passo di computazione computazione porta da
 una configurazione A un'altra Ok cioè e Il passo di computazione è un singolo passo di computazione del dfm cioè quindi quello sta in una stato c'è una configurazione è stato e deve leggere che a quel punto passa a un'altra configurazione
 Cioè passa in un altro stato e gli rimane da leggere un'altra cosa Adesso siete d'accordo che prese tutte le coppie stato configurazione cioè non tutte hanno senso per il dfa perché dipende dalla delta Cioè se io prendo una configurazione e ne prendo un'altra Cioè non è detto che queste rispettano la computazione del dfa giusto la rispettano soltanto se a partire dalla prima la delta mi dice che vado poi nella seconda giusto
 Ecco quindi vuol dire che possiamo prendere tutte le configurazioni e metterle in relazione Secondo il dfa c'è una relazione cioè ci sono quelle che sono spiegabili a partire dalla delta quelle che c'entrano niente e quelle che non stanno in relazione Quelle che stanno in relazione e quelle che non stanno in relazione Ok cioè Il passo di computazione è rispettando però la delta quindi rispettando La delta che significa questa
 Significa che c'è una relazione che sia a binaria una relazione binaria Questa è la roba che avete studiato da qualche parte di grazia Cioè che diremo che P virgola ax ok Sta in relazione questa è la relazione ok secondo m con q x Se e solo se se e solo se quindi
 Questo mi dice che due relazioni quando è che due configurazioni sono in relazione secondo m Beh se è vero questo che nella configurazione di partenza sono nello stato p e devo leggere ax Quando sto nello stato p e leggo a vado nello stato q e mi rimane da leggere x Quindi stanno in relazione se e solo se la delta per esempio di pa è uguale proprio a q no?
 Non è uguale a q allora mica è vero che dalla configurazione di sinistra passa a quella di destra giusto Quindi questa è la mia relazione se è vero che delta di pa è uguale a q no? Dove ovviamente devo dire Che p e q sono stati in q A appartenente a sigma Che altro devo aggiungere? E x appartenente a sigma Ok devo quantificare tutto
 Cioè p è uno stato q è un altro stato A è un carattere x è una striga E c'è questa relazione se è vero che delta di pa è uguale a q Se delta di pa non è uguale a q non stanno in relazione Ok quindi prese tutte le configurazioni ci stanno quelle che stanno in relazione e quelle che non stanno in relazione Va bene? E adesso
 La delta mi dice un singolo passaggio da ogni stato a un altro stato se leggo qualcosa Giusto? La delta star mi dice invece Mi comprime tanti passaggi di stato in una botta sola no? Non con un solo simbolo ma con una striga Giusto? Adesso come Posso considerare un singolo passo di computazione Che è questa qui Cioè le configurazioni che stanno in relazione
 Secondo un singolo passo Posso estenderlo Star Come ho fatto con la delta Per dire Tanti passaggi di configurazione uno dopo l'altro tutti insieme Ok? Cioè Esatto Esatto Adesso per come l'ho definito è uno solo di passaggio Adesso lo voglio estendere a tanti passaggi Eppure questi non è che sono tutti possibili Però Come faccio a fare questa cosa? Basta che Basta che considero quella che si chiama la chiusura riflessiva e transitiva di questa relazione
 Una cosa un po' tecnica Però quando avete studiato le relazioni Da qualche parte sicuro l'avete studiato Avete studiato la chiusura per transitività e riflessività Che ora non mi ricorderete Però in realtà diciamo È un modo formale per dire una cosa semplice Voglio dire che Voglio dire che Cioè è transitiva Che significa? Cioè è transitiva Significa che Se da questa configurazione Passo a quest'altra configurazione E da quest'altra configurazione Passo a quest'altra configurazione
 Vabbè allora da quella posso passare all'ultima È transitiva Ok? In più è riflessiva Perché C'è la possibilità Che se non leggo niente Rimango tosto Ok? Questa è l'idea Ok? Va bene Cioè ve la definisco Cioè Posso Posso Posso comprimere tutto quello che sta in mezzo Così posso dire Che cos'è il linguaggio adesso accettato dal DFA? È quello per cui Se leggo lì
 Passo dallo stato iniziale A uno che sta Tra quelli che accettano E l'ho messo tutti insieme là dentro Capito? Questa è l'idea Cioè quindi La posso estendere La posso estendere Questa relazione Diventa così Considerando La Chiusura Riflessiva
 E transitiva Ok? Questo in realtà Che significa? Significa questo Significa questo Proprietà 1 Riflessiva Cioè Qx Per definizione È sempre in relazione con se stesso Ok? Questo perché appunto Se sono in uno stato E non leggo niente Rimango in quello stato Ok?
 Quindi questa è diciamo La transizione banale Quella vuota Ok? La proprietà riflessiva Sì La seconda proprietà Invece è quella transitiva Cioè che è quella che mi dice Come va il calcolo di M Cioè se Q Per esempio Questo qui Q A B Y Che è quella cosa che dicevo prima Delle tre configurazioni Se è vero questo Ok? Che Q A B Y È in relazione
 Con P B Y Ok? Cioè quindi Se è vero che Dalla prima configurazione Posso passare Alla seconda configurazione Ok? Questo che sta scritto qua Cioè mi trovo nello stato Q Ok? E devo leggere ancora La stringa Carattere A Carattere B Y Che sarà una sequenza di caratteri Ok? Adesso Il passo di computazione singolo Cioè la delta singola Mi dice Guarda se stai in Q E leggi A Vai in B Ok?
 P scusate Vai in P Ok? Quindi ci sarà P E devi leggere ancora B Y Ok? Questo è un passaggio Di configurazione E allo stesso tempo Però è vero anche che Adesso P B Y È in relazione Secondo M Con Adesso Quello che ho chiamato qua R Y Giusto? Allora Per estensione No? Anche Q A B Y È in relazione
 Ma estesa Perché adesso sono due passi Secondo M Con R Y Ok? È transidia Sto nascondendo Tutto quello che sta in mezzo Ok? Va bene? Dove adesso Ovviamente avremo che Avremo qui In questo caso Q P Ed R Sono stati A E B Sono simboli E Y È una stringa Qualsiasi Ok? Mi trovate?
 Cioè qui ho semplicemente Definito Il passo di computazione No? E Ho definito Il passo di computazione Singolo Ok? E poi lo ho esteso Per caratterizzare Tanti passi Di computazione Tutti di seguito Ok? Va bene? Per fare questo Ho preso quello singolo E ci devo mettere La proprietà riflessiva Perché
 Poi sta sempre fermo Quello stato lì Se non leggi niente E la proprietà transidia Perché se posso passare Da questa configurazione A questa E poi da questa A un'altra E allora Cioè queste devono stare In relazione Ok? Attenzione Sì Non mi impiara L'estensione Perché L'estensione Significa che Significa che Cioè lei Sta prendendo Sta dicendo Quale coppia Di configurazioni Sono in relazione Ok? Si chiama estensione Perché all'inizio Lei considera
 Dentro la relazione Cioè l'insieme Di coppie Che sono in relazione Sono solo quelle Che riguardano Un singolo passo Della computazione Adesso lo sta estendendo Perché ce ne sta mettendo Del più dentro Ci mette pure Tutte quelle Per cui vale La transitività Cioè Prima Capito? Se ci sono per esempio Tre configurazioni Ok? Se La prima configurazione È in relazione Con la seconda E la seconda Con la terza La prima Non sta in relazione Con la terza Perché La delta Non mi dice Che dalla prima Posso passare alla terza Dalla prima Posso solo passare
 Alla seconda E dalla seconda Alla terza Quindi la prima Alla terza Non sono in relazione Però sono in relazione estesa Perché lì ci ho messo Tutte quelle Per cui vale La transitività Capito? Quindi la sto estendendo Mettendoci dentro Tutte quelle Che possono Fare più passi Insieme Indipendentemente Dall'inforo di base Chiaro? Sì Si chiama Reazioni Cioè Il simbolo di relazione Essere in relazione Sì Esatto
 Cioè Questo ci porta a dare Una definizione Super Succita Di linguaggio Ok? Linguaggio Accettato Linguaggio E Linguaggio Accettato In una maniera Molto Molto compatta Cioè Diremo che Diciamo Che X Appartenente A sigma star È accettato
 Da M M È il nostro DFA No? Q Sigma Che altro ci sta? Delta Q0 E F Ok? Se Se Adesso Vedi Ho un modo preciso Per dirlo In una botta sola Ok? Super compatto Cioè Delta star Di Q0 X Appartiene a F
 Ok? Oppure Posso In altro modo Posso dirlo così Che La configurazione iniziale Q0 X È in relazione Estesa Transitiva Con Q Epsilon Epsilon sarebbe La stringa vuota Stringa Vuota Dove Q Appartiene a F
 Ok? Cioè Lo posso dire in due modi Vedi? Questa cosa Mi permette di dirlo In maniera Formale Cioè sto dicendo Che cos'è il linguaggio? Prima dovevo dire Il linguaggio È l'insieme di stringhe Accettate dal DFA Ok? Come si fa a scrivere? In inglese In italiano Si scrive come lo dicono Ma qual è la definizione? Come sono fatte queste stringhe? Che proprietà soddisfano? Eh? Che significa Che un DFA Le accetta? Significa Delta star Q0 X È accettato Giusto? Oppure significa
 Che Q0 X Come configurazione È in relazione Estesa con Q Epsilon Cioè Finito le leggi E Q è un stallo finale Ok? Cioè In altre parole In altre parole L di M È l'insieme Delle stringhe X Appartenenti a Sigma star Tali che Delta star Di Q0 X Appartiene a F Ok? O La cosa adesso Va bene Cioè adesso
 È super compatto Cioè È stato un po' Diciamo Ha richiesto un po' Di formalizzare Questa cosa Le relazioni La chiusura Eccetera eccetera Però una volta Che hai capito quello È potente No? Cioè Questa è la potenza Della matematica Prima una cosa Che potevo dire Solo a parole Non si capiva bene Come la facevo A caratterizzare Dal punto di vista Della definizione No? Giusto? Adesso Ho trovato Un modo Per scriverlo Con una riga Ok?
 C'ha senso? Va bene? Vi faccio un esempio E qua ci fermiamo Ok? Faccio un esempio Cioè Un piccolo esempio Giusto per Per Concretizzare Queste definizioni Che vi ho dato Sulla delta estesa Eccetera eccetera Ok? Faccio un esempio No?
 Zero Zero E uno Eppure uno Ok? Ok? E adesso Che posso dire Di questa cosa? Posso dire Per esempio Q1 Virgola Zero Uno Uno Ok? Questa è una configurazione Giusto?
 Questa è Questa è Ho sbagliato la freccia Ho fatto Non deterministica Aspetta La freccia Dall'altra parte Qui giusto Ma pure in Q1 Con gli zeri Pure ho sbagliato la freccia Perché sennò Rimane sempre Yes Ok
 Ok Va bene Abbiamo anticipato Spoiler Ok? Spoiler Computazione deterministica So in uno stato Se leggo una cosa Posso andare solo in uno stato Ok? Computazione non deterministica So in uno stato Leggo una cosa E posso andare in due stati Allo stesso tempo Ok? Allora è Solo non deterministica È solo È come se fosse parallelo No Vabbè Questo però È il non determinismo E lo vedremo Tra qualche occasione Invece no Se so in uno stato Posso andare
 Andare solo In uno solo singolo stato Quindi è deterministica Questa è la V di TFA Ok? Qui Q1 Leggo zero Rimango in zero Leggo uno Vado in Q2 Q2 Leggo uno Rimango in Q2 Leggo zero Rimango in Q1 Ok? E adesso Se vedo Q1 E poi virgola Zero Uno Uno Questo sarà In relazione Con Quando leggo Zero E sto in Q1 Rimango in Q1 Giusto? Quindi è Q1 Uno Uno
 Quindi è in relazione Perché quando sto in Q1 E leggo zero Vado in Q1 E leggo E rimane da leggere Uno Questo Qui a sua volta Sta in relazione Sto in Q1 E leggo Uno Vado in Q2 E mi rimane da leggere Uno Giusto? È normale? Sì Eh Adesso posso continuare Adesso Se sto in Q2 E leggo Uno Rimango in Q2 E è Epsilon Giusto?
 Vi trovate? Sì Ovvero Delta star Di Q Sì Da Q1 Prima Leggo zero E rimango in Q1 Poi il secondo L'ho fatto Quando sto in Q1 E leggo uno Vado in Q2 Giusto? Sì
 Va bene? Ok? Quindi la delta star Di Q1 Zero Uno Uno È uguale a Q2 F Giusto? E siccome Q2 Appartiene a F E E W Uguale Come Zero Uno Uno Appartiene a L di F Ok?
 Vi trovate? Sì Sì Non ho capito bene Cosa sarebbe Cosa? Non ho capito bene Cosa sarebbe Sì Sì A partire? Ah no Non intendevo La stringa vuola La F è un portino La F è un portino La stringa vuola Ah Per convenzione La stringa vuola La stringa vuola
 La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola La stringa vuola Ci siamo? Domande? Prego Cioè anche qui Diciamo quello che posso scrivere qua Pure che
 È che Q1 Virgola 0 1 1 È in relazione estesa No? Con Q2 epsilon Sì Sì Sì Beh qua devi cercare di capire Quali Quali stringhe
 IFA 100 E come sono fatte Questo Vedremo delle tecniche Per fare questo Cioè adesso Non è Non è necessario Questo piccolo esempio Però vedremo Andiamo Andiamo
 Allora facciamo così Aspetta Allora per adesso Va bene La lezione è finita Chi vuole andare Può andare Chi vuole fare domande Può prendere qualche domanda
 Dai Ciao Ciao Ciao Ciao Ciao Ciao Ciao Ciao
 Ciao Ciao Ciao Ciao
 Ciao Ciao Ciao Ciao
