# Lezione 02
Nella lezione precedente abbiamo definito l'automa a stati finiti (DFA) come un primo modello semplice di computazione e definito cosa significa che un automa riconosce un linguaggio.

Ogni automa ha associato un linguaggio (l'insieme di tutte le stringhe che riconosce). L'insieme di tutti questi linguaggi forma una classe molto importante, quella dei **linguaggi regolari**
###### Definizione - Linguaggio Regolare
Un linguaggio viene definito **regolare** se esiste almeno un DFA $M$ che lo riconosce. In formule:
$$REG=\{L\subseteq\Sigma^{*}: \exists \text{ DFA }M\ \text{tale che } L(M)=L\}$$

Sebbene i DFA possano riconoscere una vasta gamma di linguaggi, essi hanno dei limiti. Verrà dimostrato che *non tutti* i linguaggi sono regolari, ovvero esistono linguaggi per i quali non è possibile un DFA che li riconosca.

È importante anche notare che, per un dato linguaggio, possono esistere molteplici DFA in grado di riconoscerlo. Dal punto di vista della correttezza, qualsiasi DFA che riconosca esattamente il linguaggio specificato è una soluzione valida. I

Esempio: 
Progettiamo un DFA che riconosca il seguente linguaggio: $$L=\Big\{x\in\{0,1 \}^{*}:x={1||y},\ y\in \{0,1 \}^{*}\Big\}$$dove:
- $||$ è l'operatore di concatenazione ("$1$ concatenato $y$"). 
- $\{0,1 \}^{*}$ significa "una stringa lunga da $0$ a $n$ caratteri fatta di $0$ e $1$"
In altre parole, stiamo cercando di trovare un DFA che accetti tutte le stringhe che iniziano con $1$ (indipendentemente da cosa c'è dopo). 

Un possibile DFA è il seguente:
![[lez02_01.drawio.svg|522x328]]

Lo stato iniziale è $q_{0}.$
- Se il primo simbolo letto è '$1$', l'automa si sposta nello stato $q_{1}.$ Poiché la condizione è soddisfatta, $q_{1}$ deve essere uno **stato di accettazione.** Una volta in $q_{1}$ qualsiasi simbolo successivo non cambierà la condizione, quindi l'automa rimarrà nello stato di accettazione.
- Se il primo simbolo letto è '$0$', la stringa non appartiene al linguaggio. L'automa si sposta nello stato $q_{2}$ che non è uno stato di accettazione. Qualsiasi simbolo successivo non cambierà la condizione. Questo tipo di stato spesso è chiamato **stato pozzo** (o **trap state**).

Come convenzione, a volte si omette di disegnare lo stato pozzo. Se da uno stato, per un certo input, non è disegnata alcuna transizione, si assume implicitamente che l'automa vada in uno stato pozzo non accettante.

Applicando questa convenzione, il DFA sopra può anche essere disegnato così:
![[lez02_02.drawio.svg|522x184]]

#### Prova di Correttezza
Dopo aver progettato un DFA, come possiamo essere sicuri che sia corretto? Bisogna fornire una **prova di correttezza**. In particolare dobbiamo dimostrare che:$$\text{Il DFA accetta  una stringa }x\iff x\in L$$
Per il nostro esempio, possiamo dimostrarlo per induzione sulla lunghezza della stringa di input $x.$

###### Prova di Correttezza dell'esercizio
Osserviamo che una volta raggiunto lo stato $q_{1}$ o $q_{2}$ l'automa non ne esce più. Formalmente:
$$\forall u\in \{0,1\}^{*}:\begin{cases}\delta^{*}(q_{1},u)=q_{1}\\\delta^{*}(q_{2},u)=q_{2}\end{cases}$$


Per induzione dimostriamo $x\in L$ se e solo se il DFA accetta $x.$

Dimostrazione:
1. **Caso base:** $|x|=0:$ 
   Se la cardinalità di $x$ è $0$, significa che $x=\mathcal{E}$ (la stringa vuota).$$\delta^{*}(q_{0},\mathcal{E})=\delta(q_{0},\mathcal{E})=q_{0}\notin F.$$La stringa vuota viene rifiutata. Questo è corretto perché $\mathcal{E}$ non inizia con '$1$'.
2. **Passo induttivo:** 
   Supponiamo che la proprietà sia vera per una stringa $w$ con cardinalità $|w|\le n.$$$\delta^{*}(q_{0},w)=\begin{cases}q_{0} & \text{se } w=\mathcal{E}\\ q_{1} & \text{se }w \text{ inizia con 1}\\ q_{2} & \text{se }w \text{ inizia con 0} \end{cases}$$Prendo $x$ tale che $|x|$ tale che $|x|=n+1.$ Posso interpretare $x$ come $x=au$, dove:$$\begin{cases}a\in\{0,1 \} & \text{è il primo simbolo}\\ u\in\{0,1 \}^{*} &\text{è una stringa di lunghezza }n\end{cases}$$Per definizione della funzione di transizione estesa:$$\delta^{*}(q_{0},x)=\delta^{*}(q_{0},au)=\delta^{*}(\delta(q_{0},a)x)$$
   Analizziamo i due casi per il primo simbolo $a$:
	1. Se $a=1$ la stringa $x$ inizia con '$1$' , quindi:$$\delta^*(q_0, x) = \delta^*(\delta(q_0, 1), u) = \delta^*(q_1, u)=q_{1}.$$ Poiché $q_{1}$ è uno stato di accettazione, la stringa viene accettata. Corretto.
	2. Se $a=0$ la stringa $x$ inizia con '$0$', quindi:$$\delta^*(q_0, x) = \delta^*(\delta(q_0, 0), u) = \delta^*(q_2, u)=q_{2}.$$Poiché $q_{1}$ non è uno stato di accettazione, la stringa viene rifiutata. Questo è corretto.
   La prova induttiva è completa e il DFA è corretto. $\blacksquare$
---
Esercizi
$L=\{x\in \{0,1 \}^{*} \text{ tale che } w_{H}(x) \ge 3\}$
dove $w_{H}(x)=\#1$ in $x\in\{0,1 \}^{*}$

$L=\{x\in\{0,1 \}^{*}: x=0^{n} \text{ con }n\in N \}.$

### Operazioni sui Linguaggi
Fissiamo $\Sigma=\{0,1\}.$ Per $n\in\mathbb{N},[n]=\{1,2,...n \}$

Siccome i linguaggi sono insiemi di stringhe posso considerare su di essi operazioni:
- Unione:$$L_{1}\cup L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ oppure }x\in L_{2} \}$$
- Intersezione:$$L_{1}\cap L_{2} = \{x\in\Sigma^{*}:x\in L_{1}\text{ e }x\in L_{2} \}$$
- Complemento:$$\overline{a} = \{x\in\Sigma^{*}:x\notin L_{1} \}$$
- Concatenazione: se abbiamo $$x=a_{1},...,a_{n};\quad {y}=b_{1},...,b_{m}$$ $$\begin{gather}xy=a_{1},...,a_{n},b_{1},...,b_{m}\in \Sigma^{*}; \quad n,m\ge0. \\ \mathcal{E}x=x\mathcal{E}=x\implies\begin{cases}x\mathcal{E}=x\\x(ya)=(xy)a\\x,y\in\Sigma^{*},\ a\in\Sigma. \end{cases} \end{gather}$$
Posso concatenare i linguaggi
$L_{1}\circ L_{2}=\{xy:x\in L_{1} \text{ e } y\in L_{2}\}$
$L_{1}\circ L_{2}\ne L_{2}\circ L_{1}$ non è commutativa

es.
$\Sigma=\{a,b\}$
$L_{1}={a,ab,ba}$
$L_{2}=\{ab,b\}$

$L_{1}\circ L_{2}=\{aab,ab,abab,abb,baab,bab \}$

La potenza è un caso speciale. Per le stringhe $x^{n}=x...x\quad n$ volte, con $x\in\Sigma^{*}$

Quindi $\begin{cases}x^{0}=\mathcal{E}\\x^{n+1}=x^{n}x \end{cases}$

Lo stesso per i linguaggi:
$\begin{cases}L^{0}={\mathcal{E}} \\L ^{n+1}=L^{n}\circ L\end{cases}$

es. $L=\{a,ab,ba\}$
$$L^{2}=\{aa,aab,aba,abab,abba,baa,baab,baba \}$$
La ${*}:$ 
$$L^{*}=\cup^{*}_{n\ge0}\ L^{n}=\{ \underset{L^{0}}{\underbrace{\{\mathcal{E}\}}} \cup L^{1}\cup L^{2} \cup... \}$$
es.
$L=\{a,b \}$
$L^{*}=\{\mathcal{E},a,b,aa,bb,ba,aaa,... \}$

Vogliamo studiare le proprietà di chiusura dei linguaggi regolari.

Se $L_{1},L_{2}\in\text{REG}$, posso dire che $L_{1}\cup L_{2}\in\text{REG}?$ e $L_{1}\cap L_{2}?$ e $\overline{L_{1}}?$ E $L_{1}^{*}??$

###### Teorema - $\text{REG}$ è chiusa per unione.
Intuizione: $L_{1}, L_{2}\in\text{REG}\implies\exists M_{1},M_{2}\in\text{DFA}$ tale che $L(M_{1})=L_{1}$ e $L(M_{2})=L_{2}$

Devo definire $M$ tale che $L(M)=L_{1}\cup L_{2}.$
Problema: Dato $x$ candidato non posso prima provare a vedere se $M_{1}(x)$ accetta. 

Idea: $M$ deve eseguire $M_{1},M_{2}$ in parallelo e accettare se e solo se uno dei due accetta.