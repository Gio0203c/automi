# Lezione 02
Nella lezione precedente abbiamo definito l'automa a stati finiti (DFA) come il nostro primo modello semplice di computazione, visto alcuni esempi e, soprattutto, abbiamo definito cosa significa che un automa riconosce un linguaggio.

Ora che abbiamo questi concetti, possiamo considerare la classe di tutti i linguaggi che possono essere riconosciuti da un DFA. Ogni automa ha associato un linguaggio (l'insieme di tutte le stringhe che riconosce). L'insieme di tutti questi linguaggi forma una classe molto importante.

### I Linguaggi Regolari

Questa classe di linguaggi è nota come **linguaggi regolari**. Si tratta di una classe fondamentale, importante per le applicazioni pratiche che abbiamo menzionato, come il riconoscimento di pattern e la costruzione di compilatori.

Diamo una definizione formale:
> Un linguaggio $$L$$ è detto **regolare** se esiste un DFA $$M$$ tale che $$L(M) = L$$. L'insieme di tutti i linguaggi regolari viene indicato con **REG**.

$$ \text{REG} = \{ L \subseteq \Sigma^* \mid \exists \text{ DFA } M \text{ tale che } L(M) = L \} $$

Una delle domande centrali del corso è esplorare i limiti della computazione. Vedremo che, sebbene i DFA possano riconoscere una vasta gamma di linguaggi, hanno dei limiti. Dimostreremo che **non tutti i linguaggi sono regolari**, ovvero esistono linguaggi per i quali non è possibile costruire un DFA che li riconosca.

### Progettazione di DFA

Ora vogliamo capire come si progetta un DFA per un dato linguaggio. Questo processo è simile alla progettazione di algoritmi: dato un problema (in questo caso, un linguaggio da riconoscere), dobbiamo creare una soluzione (un DFA) che rispetti determinate regole (numero finito di stati, funzione di transizione deterministica, stati di accettazione, ecc.).

È importante notare che, per un dato linguaggio, possono esistere molteplici DFA in grado di riconoscerlo. Dal punto di vista della correttezza, qualsiasi DFA che riconosca esattamente il linguaggio specificato è una soluzione valida. In questo corso non ci concentreremo sull'ottimizzazione, come la minimizzazione del numero di stati, ma piuttosto sull'uso del DFA come modello per comprendere i fondamenti della computazione.

Vedremo alcuni principi di progettazione, partendo da esempi semplici e passando a tecniche più strutturate, sfruttando le proprietà dei linguaggi regolari per costruire DFA per linguaggi complessi a partire da componenti più semplici.

#### Esempio 1: Stringhe che iniziano per '1'

Progettiamo un DFA che riconosca il seguente linguaggio sull'alfabeto $$\Sigma = \{0, 1\}$$:
$$ L = \{ x \in \{0,1\}^* \mid x \text{ inizia con il simbolo '1'} \} $$
Formalmente, potremmo scriverlo come $$L = \{ 1y \mid y \in \{0,1\}^* \}$$.

Il DFA deve accettare una stringa se e solo se il suo primo simbolo è '1'. Se il primo simbolo è '0', la stringa deve essere rifiutata, indipendentemente da ciò che segue.

Un possibile DFA è il seguente:
*   Lo stato iniziale è $$q_0$$.
*   Se il primo simbolo letto è '1', l'automa si sposta nello stato $$q_1$$. Poiché la condizione è soddisfatta, $$q_1$$ deve essere uno **stato di accettazione**. Una volta in $$q_1$$, qualsiasi simbolo successivo non cambia il fatto che la stringa è iniziata con '1', quindi l'automa rimarrà in questo stato accettante.
*   Se il primo simbolo letto è '0', la stringa non appartiene al linguaggio. L'automa si sposta nello stato $$q_2$$, che non è uno stato di accettazione. Qualsiasi simbolo letto successivamente non può cambiare questa condizione, quindi l'automa rimarrà intrappolato in $$q_2$$. Questo tipo di stato è spesso chiamato **stato pozzo** (o "trap state").

Ecco il diagramma di stati:
*   Stati: $$\{q_0, q_1, q_2\}$$
*   Stato iniziale: $$q_0$$
*   Stati di accettazione: $$\{q_1\}$$
*   Transizioni:
    *   $$\delta(q_0, 1) = q_1$$
    *   $$\delta(q_0, 0) = q_2$$
    *   $$\delta(q_1, 0) = q_1$$, $$\delta(q_1, 1) = q_1$$
    *   $$\delta(q_2, 0) = q_2$$, $$\delta(q_2, 1) = q_2$$

Come convenzione, a volte si omette di disegnare lo stato pozzo. Se da uno stato, per un certo input, non è disegnata alcuna transizione, si assume implicitamente che l'automa vada in uno stato pozzo non accettante.

#### Prova di Correttezza

Dopo aver progettato un DFA, come possiamo essere sicuri che sia corretto? Matematicamente, dovremmo fornire una **prova di correttezza**. Dobbiamo dimostrare che:
> Il DFA accetta una stringa $$x$$ **se e solo se** $$x \in L$$.

Questo implica due direzioni:
1.  Se $$x \in L$$, allora il DFA accetta $$x$$.
2.  Se il DFA accetta $$x$$, allora $$x \in L$$.

Per il nostro esempio, possiamo dimostrarlo per induzione sulla lunghezza della stringa di input $$x$$.
Innanzitutto, osserviamo che una volta raggiunto lo stato $$q_1$$ o $$q_2$$, l'automa non ne esce più.
Formalmente: $$\forall u \in \{0,1\}^*$$, $$\delta^*(q_1, u) = q_1$$ e $$\delta^*(q_2, u) = q_2$$.

Dimostriamo per induzione che $$\delta^*(q_0, x)$$ termina in $$q_1$$ se e solo se $$x$$ inizia con '1'.

*   **Caso base:** $$|x| = 0$$, ovvero $$x = \epsilon$$ (la stringa vuota).
    $$\delta^*(q_0, \epsilon) = q_0$$. Poiché $$q_0 \notin F$$, la stringa vuota viene rifiutata. Questo è corretto, perché $$\epsilon$$ non inizia con '1'.

*   **Passo induttivo:** Assumiamo che la proprietà sia vera per tutte le stringhe di lunghezza $$n \ge 0$$ e dimostriamola per una stringa $$x$$ di lunghezza $$n+1$$.
    Sia $$x = au$$, dove $$a \in \{0,1\}$$ è il primo simbolo e $$u$$ è una stringa di lunghezza $$n$$.
    Per definizione della funzione di transizione estesa:
    $$ \delta^*(q_0, x) = \delta^*(q_0, au) = \delta^*(\delta(q_0, a), u) $$

    Analizziamo i due casi per il primo simbolo $$a$$:
    1.  **Se $$a = 1$$:** La stringa $$x$$ inizia con '1'.
        $$\delta^*(q_0, x) = \delta^*(\delta(q_0, 1), u) = \delta^*(q_1, u)$$
        Dalla nostra osservazione iniziale, sappiamo che $$\delta^*(q_1, u) = q_1$$. Poiché $$q_1$$ è uno stato di accettazione, la stringa viene accettata. Questo è corretto.
    2.  **Se $$a = 0$$:** La stringa $$x$$ inizia con '0'.
        $$\delta^*(q_0, x) = \delta^*(\delta(q_0, 0), u) = \delta^*(q_2, u)$$
        Sappiamo che $$\delta^*(q_2, u) = q_2$$. Poiché $$q_2$$ non è uno stato di accettazione, la stringa viene rifiutata. Questo è corretto.

La prova induttiva è completa e il nostro DFA è corretto.

#### Esercizi
Provate a progettare DFA per i seguenti linguaggi su $$\Sigma = \{0, 1\}$$:
1.  $$L = \{ x \in \{0,1\}^* \mid x \text{ contiene almeno tre '1'} \}$$
2.  $$L = \{ x \in \{0,1\}^* \mid x \text{ è della forma } 0^n1 \text{ per qualche } n \ge 0 \}$$ (cioè, una sequenza di zero o più '0' seguita da un singolo '1').

Notazione: Fissiamo $\Sigma=\{0,1\}.$ Per $n\in\mathbb{N},[n]=\{1,2,...n \}$
### Operazioni sui Linguaggi

Poiché i linguaggi sono insiemi di stringhe, possiamo applicare loro le classiche operazioni insiemistiche. Dati due linguaggi $$L_1$$ e $$L_2$$:
*   **Unione:** $$L_1 \cup L_2 = \{ x \mid x \in L_1 \lor x \in L_2 \}$$
*   **Intersezione:** $$L_1 \cap L_2 = \{ x \mid x \in L_1 \land x \in L_2 \}$$
*   **Complemento:** $$\bar{L} = \{ x \in \Sigma^* \mid x \notin L \}$$

Oltre a queste, ci sono operazioni specifiche per i linguaggi:
*   **Concatenazione:** La concatenazione di due linguaggi $$L_1$$ e $$L_2$$ è l'insieme di tutte le stringhe ottenute concatenando una stringa di $$L_1$$ con una stringa di $$L_2$$.
    $$ L_1 \cdot L_2 = \{ xy \mid x \in L_1 \land y \in L_2 \} $$
    *Esempio:* Se $$L_1 = \{ a, ab \}$$ e $$L_2 = \{ c, d \}$$ allora $$L_1 \cdot L_2 = \{ ac, ad, abc, abd \}$$.

*   **Potenza:** La potenza $$n$$-esima di un linguaggio $$L$$, denotata $$L^n$$, è la concatenazione di $$L$$ con se stesso $$n$$ volte.
    *   $$L^0 = \{ \epsilon \}$$ (il linguaggio contenente solo la stringa vuota)
    *   $$L^n = L \cdot L^{n-1}$$ per $$n \ge 1$$

*   **Stella di Kleene (o chiusura):** La stella di un linguaggio $$L$$, denotata $$L^*$$, è l'unione di tutte le sue potenze. Rappresenta l'insieme di tutte le stringhe che si possono formare concatenando zero o più stringhe da $$L$$.
    $$ L^* = \bigcup_{n \ge 0} L^n = L^0 \cup L^1 \cup L^2 \cup \dots $$

### Proprietà di Chiusura dei Linguaggi Regolari

Una domanda fondamentale è: se applichiamo queste operazioni a linguaggi regolari, il risultato è ancora un linguaggio regolare? Se la risposta è sì per un'operazione, diciamo che la classe dei linguaggi regolari è **chiusa** rispetto a quell'operazione.

Cioè, se $$L_1, L_2 \in \text{REG}$$, possiamo dire che:
*   $$L_1 \cup L_2 \in \text{REG}$$?
*   $$L_1 \cap L_2 \in \text{REG}$$?
*   $$\bar{L_1} \in \text{REG}$$?
*   $$L_1 \cdot L_2 \in \text{REG}$$?
*   $$L_1^* \in \text{REG}$$?

Studiare queste proprietà è utile non solo dal punto di vista teorico, ma anche pratico. Se sappiamo che i linguaggi regolari sono chiusi rispetto all'unione, per costruire un DFA per $$L_1 \cup L_2$$ possiamo progettarne uno per $$L_1$$ e uno per $$L_2$$, e poi usare una procedura generale per "fonderli" in un unico DFA per l'unione.

#### Chiusura rispetto all'Unione (Teorema)

**Teorema:** La classe dei linguaggi regolari è chiusa rispetto all'operazione di unione.

**Intuizione della prova:**
Siano $$L_1$$ e $$L_2$$ due linguaggi regolari. Per definizione, esistono due DFA, $$M_1$$ e $$M_2$$, tali che $$L(M_1) = L_1$$ e $$L(M_2) = L_2$$. Vogliamo costruire un nuovo DFA, $$M$$, tale che $$L(M) = L_1 \cup L_2$$.

Data una stringa di input $$x$$, il nuovo automa $$M$$ deve accettarla se $$M_1$$ la accetta OPPURE se $$M_2$$ la accetta.

L'idea di eseguire prima $$M_1$$ e poi, se questo rifiuta, eseguire $$M_2$$ sulla stessa stringa, non è implementabile con un DFA. Il motivo fondamentale è che un DFA processa l'input in una singola passata, da sinistra a destra. Una volta letta l'intera stringa per essere testata su $$M_1$$, l'input è stato "consumato". L'automa non ha la capacità di "riavvolgere" l'input e ricominciare la lettura per $$M_2$$.

La soluzione è **simulare $$M_1$$ e $$M_2$$ in parallelo**.
Costruiremo un automa $$M$$ i cui stati tengono traccia simultaneamente dello stato corrente di $$M_1$$ e dello stato corrente di $$M_2$$.
*   Ogni stato di $$M$$ sarà una coppia di stati $$(q_i, p_j)$$, dove $$q_i$$ è uno stato di $$M_1$$ e $$p_j$$ è uno stato di $$M_2$$.
*   L'automa $$M$$ accetterà la stringa se, al termine della lettura, si troverà in uno stato $$(q_i, p_j)$$ dove $$q_i$$ è uno stato di accettazione di $$M_1$$ OPPURE $$p_j$$ è uno stato di accettazione di $$M_2$$.

In questo modo, con un unico passaggio sull'input, possiamo determinare se almeno uno dei due automi originali avrebbe accettato la stringa. La costruzione formale di questo automa prodotto sarà l'oggetto della prossima lezione.