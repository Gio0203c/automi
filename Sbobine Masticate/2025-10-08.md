# Lezione 05
Abbiamo introdotto le **espressioni regolari** come un modo alternativo per definire i linguaggi. Un'espressione regolare è costruita ricorsivamente a partire da casi base e operazioni induttive:
*   **Casi base:**
    *   $$\emptyset$$ (rappresenta il linguaggio vuoto).
    *   $$\epsilon$$ (rappresenta il linguaggio contenente solo la stringa vuota).
    *   $$a$$ (rappresenta il linguaggio contenente solo il simbolo $$a$$), per ogni $$a \in \Sigma$$.
*   **Operazioni induttive:** Date due espressioni regolari $$R_1$$ e $$R_2$$:
    *   **Unione:** $$R_1 \cup R_2$$
    *   **Concatenazione:** $$R_1 R_2$$
    *   **Stella di Kleene:** $$R_1^*$$

Ad ogni espressione regolare è associato un linguaggio. La domanda fondamentale è come questa classe di linguaggi si relazioni con i linguaggi regolari (quelli riconosciuti dai DFA/NFA).

**Teorema di Kleene:** Un linguaggio è regolare se e solo se può essere descritto da un'espressione regolare.

Questo teorema stabilisce un'equivalenza fondamentale: espressioni regolari e automi a stati finiti descrivono esattamente la stessa classe di linguaggi.

**Dimostrazione**

La prova si compone di due parti.

##### 1. Da Espressione Regolare ad Automa ($$L_{RE} \subseteq REG$$)

Dobbiamo dimostrare che per ogni espressione regolare $$R$$, esiste un NFA $$N$$ che riconosce il linguaggio $$L(R)$$. La prova segue la struttura ricorsiva della definizione di espressione regolare.

*   **Casi base:** Costruiamo facilmente degli NFA per le espressioni regolari atomiche.
    *   **Per $$R = a$$:** Un NFA con uno stato iniziale, una transizione etichettata con $$a$$ verso uno stato finale, e nient'altro.
    *   **Per $$R = \epsilon$$:** Un NFA con un solo stato che è sia iniziale che finale.
    *   **Per $$R = \emptyset$$:** Un NFA con uno stato iniziale non finale e nessuna transizione.

*   **Casi induttivi:** Assumiamo, per ipotesi induttiva, di avere già degli NFA per le espressioni regolari $$R_1$$ e $$R_2$$. Possiamo costruire NFA per le loro combinazioni usando le costruzioni di chiusura che abbiamo già visto:
    *   **Per $$R = R_1 \cup R_2$$:** Usiamo la costruzione dell'unione con un nuovo stato iniziale e due $$\epsilon$$-archi.
    *   **Per $$R = R_1 R_2$$:** Usiamo la costruzione della concatenazione, collegando gli stati finali del primo NFA allo stato iniziale del secondo con $$\epsilon$$-archi.
    *   **Per $$R = R_1^*$$:** Usiamo la costruzione della stella, aggiungendo un nuovo stato iniziale accettante e $$\epsilon$$-archi per permettere la ripetizione.

**Esempio:** Costruzione di un NFA per l'espressione regolare $$(ab \cup a)^*$$
1.  Si costruiscono NFA per $$a$$ e $$b$$.
2.  Si combinano per ottenere un NFA per la concatenazione $$ab$$.
3.  Si combina l'NFA per $$ab$$ con quello per $$a$$ usando la costruzione dell'unione, ottenendo un NFA per $$ab \cup a$$.
4.  Infine, si applica la costruzione della stella a quest'ultimo NFA.

Questo processo, applicato ricorsivamente, permette di convertire qualsiasi espressione regolare in un NFA equivalente.

##### 2. Da Automa a Espressione Regolare ($$REG \subseteq L_{RE}$$)

Questa è la parte più complessa. Dato un NFA (o un DFA), dobbiamo derivare un'espressione regolare che descriva lo stesso linguaggio. Per farlo, introduciamo un nuovo concetto: l'**NFA Generalizzato (GNFA)**.

**NFA Generalizzato (GNFA)**
Un GNFA è simile a un NFA, ma con una differenza chiave: **le etichette sugli archi non sono singoli simboli, ma intere espressioni regolari**.

Per semplificare la procedura di conversione, mettiamo il nostro automa in una **forma canonica** senza perdita di generalità:
1.  Esiste un unico **stato iniziale** con solo archi uscenti.
2.  Esiste un unico **stato finale** con solo archi entranti, diverso da quello iniziale.
3.  Ogni stato (eccetto quello finale) ha un arco verso ogni altro stato (eccetto quello iniziale), inclusi gli auto-loop.

Possiamo sempre trasformare un NFA in questa forma aggiungendo un nuovo stato iniziale e un nuovo stato finale collegati con $$\epsilon$$-archi, e aggiungendo archi etichettati con $$\emptyset$$ per le connessioni mancanti.

**La Procedura di Conversione**
L'idea è di rimuovere progressivamente gli stati interni del GNFA, uno alla volta, aggiornando le espressioni regolari sugli archi rimanenti per preservare il linguaggio riconosciuto.

1.  **Inizio:** Si parte dal GNFA in forma canonica con $$k$$ stati.
2.  **Passo ricorsivo:** Se $$k > 2$$, si sceglie uno stato interno $$q_{rip}$$ da rimuovere. Per ogni coppia di altri stati $$(q_i, q_j)$$, si aggiorna l'arco da $$q_i$$ a $$q_j$$. Il nuovo percorso da $$q_i$$ a $$q_j$$ deve tenere conto sia del percorso diretto preesistente, sia di tutti i nuovi percorsi che passavano attraverso $$q_{rip}$$.
    Se le espressioni regolari erano:
    *   $$R_1$$ (da $$q_i$$ a $$q_{rip}$$)
    *   $$R_2$$ (da $$q_{rip}$$ a $$q_{rip}$$, l'auto-loop)
    *   $$R_3$$ (da $$q_{rip}$$ a $$q_j$$)
    *   $$R_4$$ (da $$q_i$$ a $$q_j$$, il percorso diretto)
    La nuova espressione regolare sull'arco da $$q_i$$ a $$q_j$$ diventa: $$R_4 \cup (R_1 R_2^* R_3)$$.
3.  **Fine:** Si ripete il processo fino a quando rimangono solo lo stato iniziale e quello finale. L'etichetta sull'unico arco che li connette è l'espressione regolare equivalente all'automa di partenza.

**Esempio di conversione:** La lezione ha mostrato un esempio dettagliato di come applicare questa procedura passo-passo, partendo da un semplice NFA, convertendolo in forma canonica, e poi rimuovendo gli stati uno ad uno fino ad ottenere l'espressione regolare finale.

### I Limiti dei Linguaggi Regolari: Il Pumping Lemma

Finora abbiamo visto la grande potenza espressiva dei linguaggi regolari. La domanda naturale che sorge è: **tutti i linguaggi sono regolari?**

La risposta è **NO**. Esistono linguaggi che nessun DFA (e quindi nessun NFA o espressione regolare) può riconoscere. Lo strumento principale che useremo per dimostrare che un linguaggio non è regolare è il **Pumping Lemma**.

**Intuizione**
Consideriamo il linguaggio $$L = \{0^n1^n \mid n \ge 0\}$$. Questo linguaggio contiene stringhe come $$\epsilon$$, `01`, `0011`, `000111`, etc.
Per riconoscere una stringa di questo tipo, un automa dovrebbe in qualche modo "contare" il numero di zeri iniziali per poi assicurarsi che siano seguiti da un numero identico di uno.
Tuttavia, un DFA ha un numero **finito** di stati, che rappresenta la sua memoria finita. Non può contare un numero arbitrariamente grande di zeri. Se il numero di zeri $$n$$ supera il numero di stati del DFA, l'automa sarà costretto a "dimenticare" il conteggio esatto, rientrando in uno stato già visitato. Questo "ciclo" è l'idea centrale del Pumping Lemma.

**Il Pumping Lemma**
Il Pumping Lemma formalizza questa intuizione. Afferma che se un linguaggio $$L$$ è regolare, allora deve esistere una "lunghezza di pompaggio" $$p$$ tale che qualsiasi stringa $$s$$ in $$L$$ di lunghezza almeno $$p$$ può essere scomposta in tre parti, $$s = xyz$$, con le seguenti proprietà:
1.  Per ogni $$i \ge 0$$, la stringa $$xy^iz$$ è ancora in $$L$$. (La parte centrale $$y$$ può essere "pompata").
2.  $$|y| > 0$$. (La parte da pompare non è vuota).
3.  $$|xy| \le p$$. (Il ciclo si verifica entro i primi $$p$$ caratteri).

Per dimostrare che un linguaggio non è regolare, usiamo il Pumping Lemma per contraddizione. Assumiamo che il linguaggio sia regolare, quindi il lemma deve valere. Dobbiamo poi trovare una stringa specifica nel linguaggio, di lunghezza maggiore di $$p$$, che violi una delle condizioni del lemma, qualunque sia il modo in cui viene scomposta.

Vedremo come applicare rigorosamente questa tecnica nella prossima lezione per dimostrare che linguaggi come $$\{0^n1^n\}$$ non sono regolari.
