# Lezione 03
 In particolare abbiamo definito classe di linguaggi regolari per tutti i linguaggi che sono riconosciuti da DFA. Quindi tutti i linguaggi perché esiste un DFA che riconosce quei linguaggi.
 Come vedremo queste proprietà di chiusura per i linguaggi regolari valgono per tutte le operazioni. Unione, intersezione, negazione,
 concatenazione e potenza. Quindi partiamo dalle cose semplici perché invece la concatenazione e la star sarà un po' più complicata e infatti richiederà di cambiare il nostro modello di computazione in una maniera che dimostreremo però essere equivalente.
 Cioè vogliamo dimostrare che la classe reg è chiusa per unione. Cioè che significa? Che abbiamo detto l'altra volta intuitivamente che un DFA che riconosce L1 e un DFA che riconosce L2 dobbiamo costruire un DFA che riconosce L ovvero l'unione di L1 e L2.
 Il DFA, quello che devo definire deve essere un DFA. Non posso prima controllare se X sta in L1 e poi se non ci sta controllo se X sta in L2 e ho finito. Perché il DFA invece deve leggere l'input da sinistra a destra, non può tornare indietro, ha una memoria finita eccetera eccetera. Quindi avevo detto l'idea era quella di dire in qualche modo dobbiamo
 per risolvere questo problema dobbiamo tenere traccia di quello che stanno facendo entrambi i DFA. Cominciamo da sappiamo che all'inizio il DFA 1 sta nello stato iniziale 1 il DFA 2 sta nello stato iniziale 2. Lo stato iniziale diciamo quindi del DFA che stiamo costruendo sarà praticamente terrà traccia che tutti e due stanno nello stato iniziale 1. Quindi questo ci suggerisce che uno stato uno stato
 per il nostro DFA finale sarà una coppia di stati dei due DFA 1 per M1 e 1 per M2. Dopodiché carattere per carattere dobbiamo andare a tenere traccia di quello che sta succedendo cioè quindi se il DFA 1 quando legge X quando legge A il primo carattere di X si muove in Q2 allora il DFA dovrà tenere traccia che il primo automano
 sta in Q2 che cosa fa il secondo allo stesso tempo eccetera eccetera. Quindi questo suggerisce diciamo la seguente la seguente dimostrazione. Adesso dimostriamo il teorema. Per dimostrare il teorema cominciamo a scrivere sia M1 il primo DFA cioè M1 sarà tipo supponiamo Q1 che sono gli stati
 di M1 sigma per semplicità supponiamo che l'alfabeto sia lo stesso ci sarà una delta 1 ok poi ci sarà uno stato iniziale non so chiamiamolo Q0 1 ok cioè per dire questo è lo stato iniziale dell'automa 1 e poi ci saranno gli stati finali F1 ok quindi questo è il nostro M1
 e M2 sarà la stessa cosa cioè Q1 Q2 sigma abbiamo detto lo stesso per semplicità delta 2 Q0 2 F2 ok questi sono i nostri due DFA dati no? e questi sono tali che tali che appunto L di M1 è proprio uguale a L1
 ok sono i due DFA dati perché appunto partiamo dall'ipotesi che L1 e L5 sono regolati ok quindi esistono questi due DFA per ipotesi ok nella prova devo costruire devo costruire M ok chiamiamolo Q sigma delta 0 F tale che
 L di M è proprio uguale a L1 unito a L2 ok ok quindi per fare questo devo descrivere Q sigma delta Q0 F ok allora l'idea sarà appunto quella che vi dicevo cioè per tenere traccia di quello che stanno facendo entrambi gli DFA ok tutto quello che devo fare è appunto definire nel mio automa F
 M M uno stato con una coppia di stati in modo che così quando il DFA M sta in uno stato io so qual è lo stato di M1 e qual è lo stato di M2 cioè ne tengo traccia allo stesso tempo no? quindi avremo questa è la nostra idea naturale che appunto Q Q è uguale a
 Q è uguale a scriviamo così R1 R2 tale che R1 appartiene a Q1 e R2 appartiene a Q2 ok cioè o vuol dire che o un altro modo per dirlo questo diciamo è R1 product è Q2 cioè è la stessa cosa ok cioè Q sono tutte le coppie possibili R1 R2 dove R1 è Q1 R2 è Q2
 ok quindi sono tutte le possibili coppie ok questo è lo spazio degli stati no? altro modo per scrivere Q1 croce Q2 è la stessa cosa eh sigma è lo stesso abbiamo già detto in realtà questo teorema si può generalizzare pure se fosse vero diciamo che eh sigma M1 fosse avesse sigma 1 e M2 avesse sigma 2 ok per caso sigma sarebbe l'unione
 e adesso devo definire la delta ok la definisco così no? la delta la delta ok che prende diciamo che va da Q per sigma in Q ok quindi prendo una coppia di stati e un carattere e ti da una coppia di stati ok la definirò così cioè delta di R1 R2
 ci sono due stati no? virgola A sarà uguale la delta ok delta di coppia di stati R1 R2 virgola A perché adesso uno stato è una coppia di stati no? che cosa sarà? sarà semplicemente uguale a eh deve essere un elemento di Q ovvero una coppia di stati no? cioè sarà una coppia di stati il primo stato sarà delta 1 di R1
 A ok il secondo stato è delta 2 di R2 ok ha senso? domande? è chiara la logica? eh si sto confrontando sto tenendo traccia di
 cioè uno step di computazione no? solo per per arbitrariamente avrei potuto chiamarli QJ UI QJ il bravo avrei dovuto mettere poi 1 e 2
 R1 è un arbitrario stato di è un arbitrario elemento di Q1 R2 è un arbitrario elemento di Q2 la delta prenderà una coppia ok? esatto esatto delta 1 è la delta di M1 delta 2 è la delta di M2 giusto? che sono definite sono appunto la delta 1 prende uno stato di Q1
 di M1 no? e la delta 2 prende invece uno stato di Q2 ha senso? si sembra la cosa giusta da fare no? cioè questo praticamente ci dice che prendiamo un qualsiasi stato del nostro DFA rappresenta una coppia di stati 1 per M1 1 per M2 quando il nostro DFA legge un carattere che fa? tiene traccia di quello che su quel carattere farebbe il DFA1 e farebbe il DFA2 quindi va in un nuovo stato che è una coppia di stati ok?
 che sono appunto decisi dalla delta 1 e dalla delta 2 perché la delta 1 e la delta 2 mi dicono esattamente che cosa fa M1 e cosa fa M2 giusto? ok stiamo dicendo solo questo e a questo punto poi è lo stato finale F no? cioè adesso qui dobbiamo stare un attimo attento a definire F no? cioè F deve essere definito così no? cioè deve essere l'insieme degli R1 R2 ok? tali che R1 appartiene a F1
 oppure oppure R2 appartiene a F2 ok? questo è equivalente a dire praticamente F1 R2 ok? cioè che significa questo no? cioè quali sono gli stati accettanti
 quali sono gli stati accettanti del mio DFA? quando è che il mio DFA deve accettare? deve accettare quando o esatto quando o M1 accetta X o M2 accetta X ok? quindi questo che significa? siccome adesso per noi però uno stato è una coppia di stati quegli accettanti saranno tali che o il primo stato della coppia di stati è accettante per M1 ok? e allora un altro stato può essere qualsiasi cosa cioè che sarebbe
 F1 product Q2 no? F1 product Q2 vuol dire il primo stato che sarebbe lo stato di M1 è accettato l'altro è una cosa qualsiasi questo va bene in quel caso devo accettare ok? unito alla cosa simmetrica cioè vabbè ho scritto diciamo F2 per Q1
 per scrivere F1 per F2 mantenendo l'ordine cioè oppure quando è che devo accettare? se il primo stato di quell'altro è una cosa arbitraria cioè quindi l'altro ancora non è accettato ho finito di leggere l'input e l'altro ancora non è accettato perché sta in Q1 però l'altro invece sta in uno stato finale quindi questo vuol dire che nella computazione che ho fatto in parallelo di M1 e M2 M2 è accettato quando ha finito di leggere
 F1 non ho perché sta in Q1 però in quel caso io devo accettare perché questo significa che M2 avrebbe accettato avrebbe accettato X giusto? ha senso? quindi questo questo è quanto ok? adesso diciamo vi faccio una domanda
 e lo lascio per esercizio da finire diciamo se fosse stato se fosse stato L uguale L1 intersegato L2 che avreste fatto? per vedere se stiamo sulla stessa cosa cioè se adesso ripercorriamo la dimostrazione fino a questo punto assumendo che la chiusura non è per L1 unito a L2 ma è per L1 intersegato a L2
 che sarebbe che cambierebbe? F cambierebbe come sarebbe finito? F1 più L2 esatto ok avrei dovuto avrei dovuto usare avrei dovuto usare F1 uguale è chiaro perché? no? perché in quel caso
 non basta che M1 accetta oppure M2 accetta ma sia M1 che M2 non accetta quindi vuol dire che F deve essere prodotto tra cartesiani ok? va bene? allora diciamo adesso dal punto di vista formale per dimostrare per finire la prova del teorema dovresti dimostrare adesso che questo è corretto cioè la correttezza
 come dico sempre quando descrivete un DFA dovresti dimostrare la correttezza cioè in questo caso diciamo è a volte queste dimostrazioni sono un po' come dire no? cioè cioè stai dimostrando una cosa che è chiaro che è vero però diciamo formalmente lo dovresti dimostrare vi do diciamo delle tracce su come fare questa cosa ok? non è molto difficile ok? però diciamo dovrebbe essere chiaro già da questa descrizione infatti se voi leggete il libro il libro non lo fa perché è talmente
 chiaro che funziona che è che quasi non c'è bisogno no? di fare una cosa super formale usando induzione no? però diciamo c'è un'intuizione chiara che si può comunicare a parole quasi in questo caso cioè ovvero il fatto che che cosa sta facendo questo DFA? sta eseguendo tutti e due i DFA in parallele cioè sta tenendo traccia carattere per carattere dello stato del primo DFA e dello stato del secondo DFA accetta se e solo se uno dei due accetta e sta riconoscendo l'unione cioè cioè
 è veramente quasi tautologico no? siete d'accordo? siamo tutti d'accordo? cioè la dimostrazione del libro è finita ok? però diciamo se lo volessi dimostrare in maniera matematica che cosa faresti? cioè dovresti dovresti usare induzione usare induzione ad esempio per dimostrare che questa cosa per dimostrare
 la seguente proprietà la seguente proprietà ovvero che cioè se io ho delta star la delta star la delta star cioè che come definire la delta star di Q come abbiamo chiamato uno di zero
 perché non stai zitto? uno zero ish ok? scusate cioè nello stato iniziale no? quello che abbiamo come l'abbiamo chiamato lo stato iniziale l'abbiamo chiamato Q zero ok cioè la la mia delta star di Q zero virgola ish ok? cioè questa sarebbe la delta star di Q uno zero Q due zero virgola ish
 ok? cioè sì per fare queste prove di solito per induzione si usa sempre la funzione estesa no? cioè quindi se ci pensate intuitivamente cioè questa è una cosa chiara no? sarà chiara cioè una volta che ho scritto l'equazione sarà chiaro che è vero vi lascio per esercizio di mostrarlo con usando induzione ok? è un buon esercizio ok? dovete soltanto fare un esercizio per ricordare come si fa l'induzione però diciamo la cosa che dice questa cosa è sarà questo chiaramente vera
 ovvero che se io prendo la delta star vi ricordate no? la delta star è quella che ti permette di di fare la traccia della computazione non solo per un singolo carattere ma per un x qui x appartenente a sigma sì l'ho messo al contrario sì sì sì l'ho messo zero uno due esatto ok voglio dire no? quindi la mia delta star per ogni sigma no?
 per ogni x in sigma star di lunghezza arbitraria ok? per questo dovessi usare l'induzione perché x ha lunghezza arbitraria no? potrebbe essere infinita la cosa seguente è vera cioè qual è la delta star di stato iniziale x? vabbè sarà la delta star uno dello stato iniziale uno x virgola delta star due del stato iniziale secondo stato iniziale x no? ricordatevi q zero è una coppia di stati no? cioè q zero è lo stato iniziale di m è una coppia di stati q zero uno q zero due
 questa deve essere uguale sarà sicuramente uguale a delta uno star q come l'abbiamo chiamato zero uno virgola x e anche delta due star di q zero due virgola x ok? cioè è chiaro che questo è vero ancora una volta cioè per definizione no? perché appunto la delta guarda com'è definita la delta cioè guarda com'è definita la delta
 fa esattamente questo cioè la delta di una coppia di stati sul singolo carattere fa delta uno del primo stato carattere delta due del primo stato carattere eppure la delta star farà la stessa cosa no? cioè è banale no? ok se volete proprio essere precisi lo dovete dimostrare per induzione no? perché questo deve essere vero per tutte le stringhe di lunghezza infinita ok? l'unico modo per dimostrare questo è usare l'induzione o un modo diciamo il modo più semplice per dimostrare questo è usare l'induzione cioè lo fai vedere prima per x vuoto e per x vuoto è chiaramente vero no?
 diventa banale poi assumi che sia vero per ogni x di lunghezza n prendi un x di lunghezza n più uno metti da parte il primo carattere applica la definizione di delta star e ti viene esattamente questa cosa ok? ve lo lascio per esercizio ok? deliberatamente perché così lo provate a fare da soli ok? una volta che hai fatto vedere questo la prova ok questo esercizio esercizio provatelo
 ok? una volta che hai dimostrato questo la prova segue facilmente la correttezza segue immediatamente ovvero diciamo no? la correttezza che significa? significa che appunto per ogni x appartenente
 a sigma star abbiamo che x appartiene a l di m se e solo se x appartiene a l1 ok? cioè questa è questa è quello che dobbiamo dimostrare no? cioè la correttezza è sempre un se e solo se no? cioè se il dfa accetta x allora x sta nell'unione direzione 1 direzione 2 se x sta nell'unione allora il dfa accetta x
 questo significa il dfa accetta tutti e soli gli elementi che stanno nell'unione ok? e rifiuta tutti quelli che stanno fuori dall'unione ok? sono sempre in due direzioni eh quindi diciamo questo adesso lo puoi vedere così diciamo no? cioè da una parte allora c'hai che se x appartiene a l di m allora abbiamo che la delta star di q0 no? abbiamo chiamato q0
 x e appartiene a f ok? giusto? ma adesso la delta star di q0 x che significa appartiene a f? cioè ricordiamo che è la definizione di f no? cioè f era era era f1 per q2 unito a q1 per f2 giusto?
 adesso siccome la delta star sarà una coppia di stagioni pq giusto? abbiamo che dove ovviamente diciamo dove abbiamo che chiamiamo a pq no? avremo che diciamo p sarà uguale alla per la cosa che abbiamo detto sopra no? p sarà uguale alla delta star di q0
 1 virgola x giusto? e q sarà uguale alla delta star 1 questa è delta star 1 questa è delta star 2 di q 0 2 virgola x no? ok? va bene? quindi questo significa che abbiamo che è delta 1 star q0
 1 o come diciamo senza scherzo quello uguale prima di pq fa riferimento a questo qui allora quella è quella è q cioè chiamiamo pq l'output di cioè che vuol dire che x che vuol dire che x sta in l vuol dire che quando parto dal suo stato iniziale e applico la delta star su x ottengo uno stato finale per l ok? che significa? questo stato finale per l è una coppia di stagioni
 tutti gli stati finali tutti gli stati di l di m sono coppie di stati no? chiamiamoli pq no? per il lemma precedente avremo che p è questo e q è questo ok? ah beh uno di questi due è finale per definizione di f no? cioè ovvero abbiamo che o p appartiene a f1 oppure q appartiene a f2 ok? ovvero vuol dire che x appartiene a l1 oppure x appartiene a l2
 ok? ed è esattamente la definizione di di unione ok? è esattamente la definizione di di unione posso salire un po' veloce? si saliti si ok quindi sto dicendo per que quell'osservazione no? se p è se la delta star di q0 x mi da due stati ok? assumiamo che questo stato sia finale cioè pq sia uno stato finale significa che o p è finale
 in f1 o q è finale in f2 ma p finale in f1 significa che allora delta 1 star di q01 x è accetta no? cioè vuol dire che o x sta in l1 o x sta in l2 ok? che è esattamente quello che dovevamo dimostrare ok? d'altra parte diciamo l'altra direzione pure è semplice no? cioè se succede che x appartiene a l1 supponiamo avremo che la delta star di q01 x
 appartiene a f1 ok? sappiamo che la delta star di q0 x è uguale alla delta star 1 no di q01 x per la delta star 2 un'altra volta di q02 x è sempre la cosa di prima ok? e questo sarà dentro f1 per q2
 ok? ovvero l m m accetta x no cioè vedi se è vero che x sta in l1 allora la delta star di q01 x sta in f1 per definizione ma la delta star di q01 x è la coppia delta star 1 delta star 2 e la prima quindi sta in f1 adesso giusto? questa qui sta in f1 e quindi vuol dire che
 questo sta contenuto in f no? cioè questo è contenuto in f e quindi m accetta x ok? stessa cosa stessa cosa se x appartiene a l2 ok? cioè se x appartiene a l1 accetta se x appartiene a l2 m accetta yes ma quale è un appartiene o un che? contenuto no quello a sinistra o a destra?
 appartiene no? perché appunto appartiene perché abbiamo scritto sopra delta star di q01 x appartiene a f1 va bene? ok? cioè qui tutto qua no? nel senso cioè questo è come lo fareste a dimostrare in maniera formale ok? dove vi ho lasciato per esercizio di dimostrare questa semplice proprietà che è chiaramente vera ok? però ancora una volta va bene diciamo secondo me farlo come esercizio per cercare di sporcarvi un po' le mani
 cioè di solito poi quando vai a fare gli esercizi le prove di correttezza sono ancora più semplici perché gli automi sono più semplici cioè questo è un modo abbastanza più complicato no? va bene? domande? ok quindi questo è vero per l'unione è vero pure per l'intersezione vi lascio un altro esercizio esercizio
 per dimostrare che il red è anche chiusa per complemento va bene? qui abbiamo visto unione abbiamo visto intersezione intersezione è praticamente uguale abbiamo detto dobbiamo soltanto cambiare come definiamo gli stati finali manca il complemento lo lascio per esercizio
 è ancora più semplice ecco va bene? adesso invece quello che vogliamo fare proprio scusa potrebbe tornarsi alla dimostrazione dell'unione sì che domanda? vorrei fare la foto la foto ma intanto la metto sul sito c'è un due qui sotto c'è un due se vuole fare la foto può fare no sotto qua questa sera io la carico sì sì
 durante la pausa se viene qua sì sì ok? domande? sì perché no? ci siamo più a fa? ok adesso vogliamo invece parlare cioè vogliamo adesso vogliamo ora trattare la concatenazione no ok
 ovvero dati diciamo l1 l2 regolari ok vorremmo dimostrare che l1 concatenato l2 pure è regolare ok? questo è quello che vorremmo fare
 cioè che significa che che significa che l1 concatenato l2 è regolare? cioè questo significa che dato x devo capire diciamo devo capire come spezzare x in
 se possibile diciamo in x1 concatenato x2 diciamo come scriviamo di solito x1 x2 tale che x1 appartiene a l1 x2 e x2 appartiene a l2 ok? lo devo spezzare sì cioè io ho un x no? e devo stabilire se x sta nella concatenazione tra l1 e l2 che significa?
 ci sta se solo se x si può suddividere in due parti x1 e x2 dove x1 sta in l1 e x2 sta in l2 ok? adesso questo sembra difficile perché come faccio con un dfa a capire come si spezza cioè ricordatevi che io non posso fare altro che andare da sinistra a destra cioè non è che posso dire provo a spezzare nel primo modo poi nel secondo cioè sembra in qualche modo
 complicato ok? sembra molto più complicato va bene però in effetti uno potrebbe cominciare a pensare faccio tante cose in parallelo e in effetti diciamo questo modo di ragionare secondo me è poi quello che ha portato alla definizione di un concetto fondamentale che facilita molto questa questa dimostrazione cioè come vedremo questa dimostrazione sarà semplice con gli strumenti giusti cioè ok? lo strumento giusto che è quello che introduciamo adesso è quello che si chiama il non determinismo ok?
 questo ha portato diciamo la risposta a questa domanda quindi sembra complicato sembra complicato per risolverlo per risolvere questo problema introduciamo il
 non determinismo che sembrerà diciamo quasi un cheat cioè nel senso che adesso varierò e cambierò il modello
 e dico vabbè ok non lo so fare allora cambio il modello e ecco cambiando il modello vedrete che sarà facilissimo fare ok? e se non che ovviamente sto imbrogliando ma veramente in realtà non starò imbrogliando perché vedremo che la computazione non deterministica e quella deterministica sono uguali sono la stessa cosa cioè ho cambiato il modello ma ho definito un modello che in realtà è lo stesso non l'ho cambiato però ho introdotto uno strumento che mi permette di ragionare in una maniera molto più potente ok? e di risolvere
 un problema come quello sopra in maniera immediata va bene? e questo concetto di non determinismo sarà fondamentale ok? vedremo che vedremo che appunto determinismo e non determinismo sono equivalenti per i TFA no? però vedremo poi che appunto cioè il punto cruciale della computazione è che quando invece passeremo diciamo quando passeremo
 alle macchine di Turing e soprattutto quando metteremo in campo le risorse memoria tempo eccetera questo gap tra determinismo e non determinismo porterà infatti al problema più grande da informare non sapremo rispondere a questo a questa relazione della computazione deterministica e non deterministica però per il caso degli TFA soprattutto perché non ci sono in mezzo anche le risorse finora sarà in realtà
 ok? va bene? allora non determinismo è una cosa un po' magica quasi cioè sembra una cosa quasi veramente una magia no? cioè voi intuitivamente ok? è un po' una magia una magia dal punto di vista della computazione ovvero cioè quello che diciamo adesso
 finora ok? finora finora la computazione è deterministica ok? la computazione computazione è deterministica ok? ovvero ovvero se D è un TFA e nello stato diciamo nello stato
 e D legge diciamo A appartenente al signo nello stato nello stato Q appartenente al Q allora però mi scusi potrebbe rileggere la prima frase perché non so se riesce bene questa finora la computazione è deterministica finora la computazione è deterministica la computazione è deterministica
 ok? ovvero cioè sto spiegando che significa se D è un TFA e D legge A in sigma un carattere e sta nello stato Q allora D D può andare in un solo stato può andare in un unico unico altro stato stato P appartenente ok? cioè questo significa computazione deterministica
 cioè io sto in uno stato leggo una cosa vado in un altro stato ok? cioè per esempio non è mai possibile che io sto in uno stato leggo uno e vado in due stati ok? la computazione non deterministica invece è il contrario cioè vuol dire questo è possibile non determinismo significa proprio nel caso non deterministico
 diciamo quando D o quando diciamo l'automa potremmo chiamarlo l'automa l'automa è in Q e legge A può andare in diversi stati
 ok? cioè è come se praticamente cioè lui sta computando ok? infatti questo potrebbe succedere pure all'inizio però diciamo lasciamo perdere adesso come ci siamo arrivati a quello stato sto in uno stato ok? non so come ci sono arrivato sto a quello stato lì leggo un carattere e posso fare due cose allo stesso momento ok? cioè è come se avessi fatto un thread di computazione parallela lo puoi vedere così lo puoi vedere che tu stai
 in uno stato a questo punto ti sdoppi ok? ti sdoppi o di più più di due ci potrebbero essere più tre ok? questi thread procedono in parallelo cioè il thread numero uno va nello stato P1 il thread numero due va nello stato P2 poi il thread primo il primo thread continua nello stato P1 e ancora si può biforcare nello stato P1 il thread due continua nello stato P2 ok? è come se sto esplorando
 tanti rami no? ok? eh? no non è tantissimo è sempre classico però eh è classico però però è magico nel senso perché è magico? cioè perché vedremo cioè fino adesso vabbè ok faccio le cose in parallelo però il punto fondamentale sarà la condizione di accettazione cioè quando è che accetto? accetto se eh almeno un ramo
 ok? questa sarà la cosa fondamentale cioè è molto potente cioè mi permette di nel caso non deve esistere dividere la computazione parallelizzarla in tanti modi possibili e accettare fin tanto che ce ne sia almeno una che accetta cioè l'unico caso in cui rifiuto è se li rifiutano tutti ok? questa è è l'idea adesso ve lo scrivo a provare ma lo disegniamo in maniera formale ma vedrete che la definizione formale sarà semplice in realtà no? perché avete capito l'intuizione quindi la prima cosa quando la domo
 e legge a quando ha i diversi stati diciamo per esempio P1 P2 eccetera ok? eh inoltre sono anche ammessi sono ammessi i cosiddetti epsilon archi perché so questi epsilon archi? è semplicemente un modo formale per dire non solo ti puoi sdoppiare quando leggi una cosa ma ti puoi sdoppiare pure se non leggi niente ok? cioè posso dire ok
 ora sto in questo stato e mi sdoppio prima di leggere qualsiasi altra cosa ok? cioè ovvero si possono aprire questi diciamo consentono di aprire di aprire rami di computazione rami di computazione di computazione senza leggere
 diciamo paralleli paralleli senza leggere nulla ok? cioè io quindi per esempio potrei avere e vedremo degli esempi cioè potrei avere uno stato iniziale ok? da questo stato iniziale esce un epsilon arco che va in uno stato e un epsilon arco che sta in un altro stato questo significa che appena quello inizia sta già
 ci sono già due rami ok? uno parte dallo stato iniziale uno parte dallo stato iniziale due ok? ho sdoppiato la computazione senza manco leggere niente e lo posso fare a partire da qualsiasi altro stato ok? posso avviare un thread parallelo questo si chiama sarebbe l'epsilon arco senza leggere nulla ok? come se fosse un input particolare come se fosse un input particolare che è un modo per formalizzare questa cosa esatto esatto si chiama epsilon arco ok? dopodichè l'ultima altra cosa che devo dire
 accettazione è quella che ho già detto accettazione accetto se e solo se esiste almeno un ramo un ramo che accetta una domanda si una volta che appunto noi abbiamo biforcato la strada si saremo costretti per tutta la vita dell'automa ad avere due
 andamenti dell'automa non si può riunire magari il mondo nel sesto stato beh diciamo gli stati sono sempre quelli cioè nel senso che può essere che un ramo esplora degli stati un altro ramo esplora degli stati ma questi stati sono intersecati cioè non sono separati questo non lo dice nessuno però questo non sarà importante però la cosa importante sarà che lei potrà esplorare cammini diversi e basta che uno di questi cammini
 si accettanti affinché lei accetti questa è la differenza non è che i cammini riguardano stati separati gli stati sono sempre quelli va bene? quindi può succedere decisamente che diversi rami abbiano stati con comunque va bene? cioè diciamo se lo volessimo disegnare diciamo in pratica
 abbiamo questo cioè questo è lo stato diciamo della computazione deterministica a partire da un stato quando è un altro stato quando è un altro stato quando è un altro stato e poi accent
 ok? questa sarebbe praticamente questa è la computazione deterministica ok? cioè la computazione deterministica è fatta così parto da uno stato iniziale leggo questa è la foto della computazione una traccia di computazione su un particolare input diciamo quindi su un particolare input passo questo stato a un altro poi a un altro poi a un altro è una cosa sequenziale ok? sempre
 un solo passaggio questa è la computazione deterministica la computazione deterministica non deterministica invece dal punto di partenza si può biforcare no? come dicevo arbitrariamente no? ok? e ogni cammino si può ancora biforcare questo si può biforcare questo pure questo magari no questo si ok? e ognuno di questi cammini no?
 ok? ognuno di questi cammini no? potrebbe succedere qui potrebbe succedere qui ok? non lo so potrebbe finire così ok? ognuno di questi cammini potrebbe fermarsi cioè non è che ci hanno tutti la stessa lunghezza ovviamente no? va bene? ok?
 e cioè il motivo per cui non hanno tutti la stessa lunghezza è il fatto che appunto spesso quando poi disegni diciamo il disegno dell'NFA dell'automa non deterministico si chiamerà NFA non deterministic finite state automata e come vi avevo detto già per il caso di DFA non sarà vero che la DFA
 è sempre definita per tutti gli input no? cioè potrebbe essere quello stai in uno stato e il disegno mi dice in questo stato non c'è scritto niente no? e quindi un cammino muore subito potrebbe succedere questo non devi arrivare alla fine per accettare o rifiutare perché in maniera compatta abbiamo detto se la DFA è indefinita by default fai immediatamente reject vi ricordate questa cosa? va bene lo vedremo adesso con degli esempi comunque domande? cioè questa è la cosa che voglio definire
 ok? cioè la voglio definire e la voglio voglio dimostrarvi che in realtà non ho cambiato niente cioè in realtà non ho cioè sembra che ho cambiato tante cose però in realtà un DFA può fare la stessa cosa che fa un NFA ok? va bene però sarà cruciale diciamo il caveat sarà che non mi interessano le risorse ok? questo sarà
 abbastanza fondamentale il fatto che non stiamo contando le risorse per adesso ok? allora definiamo prima la la questione ok? la definizione di NFA che è come dico non deterministic final state automata questo è un NFA è
 è una roba del tipo Q sigma delta Q0F cioè uguale a prima ok? cioè un NFA pure è Q sigma delta Q0F dove dove praticamente è Q sigma Q0F sono come
 negli F3A ok? cioè non ha cambiato niente l'unica cosa che cambia è la delta di fatto ok? quindi Q è l'insieme degli stati sigma è l'alfabeto Q0 è lo stato iniziale F è l'insieme degli stati finali identico ok? mentre invece questa è l'unica differenza
 mentre invece l'unica differenza appunto è questa che è delta di Q per sigma epsilon vediamo dove sigma epsilon sarà sigma unito epsilon ok? cioè perché sto ammettendo gli epsilon archi ok? questo è il modo formale di dire ci sono gli epsilon archi cioè adesso la delta prima differenza prende uno stato e un carattere oppure epsilon cioè ho aggiunto l'epsilon archi
 in questo modo e adesso questo dove va? adesso prima andava in un solo stato ok? adesso va in un insieme di stati ok? quindi un insieme di stati sarà un sottoinsieme di Q e come si indicano tutti i possibili sottoinsiemi di Q si chiama insieme delle parti di Q ok? qui di Q qui di Q
 qui di Q sarebbe lì insieme delle parti insieme di tutti i possibili possibili sottoinsiemi ok? questo è qui di Q ok? cioè questa è l'unica differenza cioè ovvero che appunto è un modo
 formale per dire il DFA sta in uno stato e va in un insieme di stati sì significa semplicemente sigma unito il carattere speciale epsilon cioè che significa che ci possono essere gli epsilon archi cioè vuol dire che perché se vi ricordate no? come disegno l'NFA l'arco vuol dire che quello che faccio quando leggo qualcosa adesso sto ammettendo di leggere epsilon ok? lo sto ammettendo
 esplicitamente e l'epsilon è una cosa speciale che mi permette di fare qualcosa senza leggere niente sì sì ma è fatto apposta questa cosa perché lei non legge niente quindi è come se leggesse il carattere uomo quindi questo clash di notazione è è voluto ci sono domande? questa è tutta la definizione ok? cioè in realtà abbiamo cambiato solo questo
 che sono ammessi anche gli epsilon archi e quindi formano infatti l'epsilon arco è la stringa vuota è la stessa cosa perché la stringa vuota vuol dire che lei non legge niente quindi infatti è fatto apposta che si chiama epsilon perché infatti la stringa vuota vuol dire che lei non sta leggendo niente è come se fosse un arco marcato quindi lo percorro sempre lo posso percorrere sempre perché lì ci posso andare senza nessuno è voluto questa scelta di epsilon
 è uguale? no sigma e q non hanno niente a che fare uno con l'altro q sono gli stati sigma è l'alfabeto alfabeto a b c d e f g q invece sono gli stati stato primo stato stato iniziale stato finale sigma e epsilon sono semplicemente l'alfabeto unito il simbolo speciale epsilon tutto qua cioè questo è quello che mi permette di fare
 epsilon arco se non ci fosse l'epsilon sarebbero solo l'alfabeto non posso marcare un carattere con epsilon un arco con epsilon ok se io sono in uno stato q se passo epsilon se apro un altro ramo si e rimango in q si no io no rimango in q transizione in un altro stato quindi senza passare è come se quindi lei sta nello stato q c'è un epsilon arco che lo porta a p vuol dire c'è un ramo di computazione che sta ancora in q
 e legge il prossimo carattere che deve leggere allo stesso tempo si è creato un ramo di computazione che ora sta in p e legge il prossimo carattere che deve leggere ok ma questo adesso lo vediamo facciamo un sacco di esempi lo vedremo però diciamo dal punto di vista formale la definizione è solo questa ok tutti gli altri dubbi sono leciti ovviamente c'è una cosa che dice ho capito la definizione per capirla dobbiamo
 significato che nell'alfabeto sigma epsilon sto includendo il carattere sigma e il carattere epsilon lo potrei chiamare zero però lo chiamo epsilon solo che è buono epsilon è la sigla vuota ok va bene
 vediamo domande ad esempio questo start
 ciao giovanni
 ok sta facendo un esempio prendiamo il linguaggio L delle stringhe binarie di lunghezza più di un'area che ne hanno un 1 in terz'ultima posizione ok 1 in terz'ultima posizione
 ok voglio fare un'automa ok che mi determina se la stringa x che è di lunghezza arbitraria c'ha sempre un 1 in terz'ultima posizione ok no non l'ho usato non c'è scritto
 non c'è scritto non c'è scritto non c'è scritto non c'è scritto
 non c'è scritto non c'è scritto in questo esempio in questo esempio ne ho usata una sola va bene ok potevo usare tutte e due va bene allora perché questo automa conosce intuitivamente questo linguaggio vediamo una domanda domande ok qual è l'idea di questa automa ok
 l'idea di questa automa è che tu che tu puoi fare sempre questo cioè tu e tu ok inizi in q1 abbiamo notato ho chiamato q1 la stata iniziale q1 è la stata iniziale ok vedi che c'è ho usato il non determinismo perché l'ho usato il non determinismo perché appunto quando sto in q1 quando leggo 1 faccio due cose sto spezzando la computazione c'è un ramo di computazione che rimane in q1
 che rimane in q1 vi trovate su questo? quindi è non deterministico cioè si vede proprio dalla figura la figura vi permette di subito questo non è un DFA questo è un NFA sicuro ok il DFA non la può fare ok adesso qual è l'idea molto istitutiva di questo NFA è questa che praticamente gli ultimi gli ultimi tre stati ok come se lo potessi vedere come un thread di computazione che
 che accetta quando appunto c'è un 1 in terz'ultima posizione no? ok cioè prova a controllare se appunto è arrivato alla fine della stringa e succede che c'è un 1 in terz'ultima posizione perché infatti vedi se per esempio adesso faccio un esempio ok se x fosse 1 0 0 ok supponiamo per semplicità no? ok allora
 ovviamente come? come? dove sta? 0 1 dove sta? 0 1 star L la fa bene
 x è una stringa ragazzi ok x è una stringa non può essere un stato il linguaggio è il linguaggio di stringhe ok ci siamo? attenzione ok quindi sto dicendo se x fosse 1 0 0 vedi infatti cioè quell'ultimo thread quel q2 q3 q4 è quello che proprio dice infatti accetta x no? perché sta in 1 legge 1 ma anche 2 lasciamo vedere le frecce di sopra ok
 legge 1 e fa il q2 siccome adesso adesso non mi importa che cosa succede allora quindi qualsiasi cosa legge va in q3 qualsiasi cosa legge va in q4 se è finito accetta ok giusto? cioè questa è la logica di quegli ultimi di quegli ultimi 3 stati ovviamente o 4 diciamo quello stato iniziale posso capire con quella cosa lì se è il terz'ultimo ok adesso il potere dell'NFA mi permette di dire controllo sempre
 ogni carattere è il terz'ultimo ok cioè parto dal primo il primo è il terz'ultimo adesso supponiamo che per esempio x invece fosse quindi questo lo accetta ovviamente lo accetta con una base forse invece è 1 0 0 0 ok per fare un altro esempio quindi 1 0 0 0 ok ci siamo? pure il fondo lo vedete? vedete 1 0 0 0 ok 1 0 0 0
 ok adesso 1 0 0 0 no? non va bene no? e infatti che succede che infatti che succede che quel cammino di computazione adesso quando lui inizia no? quando lui inizia è come se provasse a dire il primo carattere è il terz'ultimo carattere ed è uguale a 1 e la risposta è no infatti che fa? quando fa quel cammino di computazione
 va a destra lui parte legge 1 e va in q2 legge 0 e va in q3 legge 0 e va in q4 ah poi legge 0 e non fa niente e rifiuta perché quando sta in q4 e legge 0 muore non ha finito di leggere questa è quella cosa che vi ho detto che quando poi disegniamo un automa non disegniamo tutte le brecce no? ok cioè formalmente se avessi dovuto definire la delta su tutti gli input avrei dovuto mettere da q4 qualsiasi cosa leggi vai nello stato pozzo nello stato pozzo ci rimani per sempre no? ok
 ma non c'è bisogno eh? ma non c'è bisogno non c'è l'epsilon non c'è l'epsilon non c'è l'epsilon non c'è l'epsilon dico perché ci vuole mettere l'epsilon? eh vediamolo vediamolo vediamo una cosa non voglio non voglio smortare il suo entusiasmo di mettere l'epsilon però dico
 cioè capiamo prima senza epsilon no? poi vediamo anche l'epsilon ok per adesso leggo l'epsilon ma devi ancora leggere non mi preoccupo dell'epsilon in questo caso ok non lo sto usando l'epsilon non c'è niente c'è che tu inizi a leggere quindi resta in accettazione qualsiasi non sono quello che in alto e non ci do archi non so che dico sono in q4 leggo 0 non c'è scritto che faccio è morto è morto ok se vuoi far qualcosa devi mettere dei fricci da qualche parte ok
 ok qui non ci stanno le fricce ok quindi lui legge quindi infatti lo possiamo anche disegnare così no? infatti ce n'ho anche uno più complicato adesso vi faccio vedere adesso i rami di computazione ok però in questo caso qua voglio convincere vi subito che invece no niente non c'è mai il ramo di computazione che c'è in questo caso cioè questo infatti è rifiutato e perché viene rifiutato? perché appunto il primo ramo
 di computazione diciamo è quello che abbiamo detto adesso no? c'è l'altro ramo di computazione parallelo che legge il primo 1 che rimane in se stesso no? e a quel punto però il terzo ultimo carattere è 0 e la stessa cosa qui ragazzi cioè qui possiamo stare tutto il giorno faccio un esempio ok un esempio completo perché è un po' più complicato di questo
 vi faccio un esempio completo vi faccio tutti gli alberi ok? poi ogni altro esempio potete cambiare ci potete giocare come vi pare fate gli alberi che volete però vi faccio vedere una cosa un esempio completo ok? cioè x uguale per esempio x uguale 1 0 1 1 0 va bene? facciamo questo ok? per casa per casa ad esempio
 1 0 0 1 0 ok? va bene? è un esercizio va bene? però io vi faccio vedere 1 0 quindi c'è c'è il terzo ultimo 1 c'è il terzo ultimo 1 questo sta in L sta in L deve accettare ok? allora vediamo che fa lui sta lui all'inizio vediamo la figura no? la figura all'inizio sta in Q1 ok? sta in Q1 e legge deve leggere ancora 1 0 1 1
 ok? questo è lo stato iniziale va bene? adesso che succede? il primo carattere è un 1 la computazione si sdoppia ok? perché quando c'è un 1 in Q1 si sdoppia un ramo di computazione rimane in Q1 giusto? ho letto il primo 1 mi rimane ancora da leggere 0 1 1 0 giusto? ho consumato un carattere l'altro ramo di computazione
 va in Q2 e gli rimane da leggere 0 1 1 0 è corretto? ok adesso sviluppiamo prima il ramo Q2 no? questo qua di Q2 adesso una volta che sto in Q2 in realtà la computazione è deterministica ok? cioè qualsiasi cosa leggo vado in Q3 mi rimane da leggere ancora 1 1 0 qualsiasi cosa leggo vado in Q4 mi rimane da leggere ancora 1 0 quindi
 questo ramo di computazione è morto perché sono finito in Q4 e devo leggere ancora 1 0 sono morto ok questo è morto però c'è fortunatamente c'è un altro ramo che è ancora in vita che è questo Q1 0 1 1 0 adesso quando sto in Q1 quando sto in Q1 e leggo 0 rimango in Q1 sempre no? e mi rimane da leggere
 1 1 0 c'è sempre questo no? se sono in Q1 e leggo 0 rimango in Q1 sempre deterministico non faccio nient'altro che rimanere in Q1 allora una volta che sto in Q1 adesso e leggo 1 1 0 quando sto in Q1 e leggo 1 la computazione si sdoppia un'altra volta c'è un ramo di computazione che rimane in Q1 e diventa ancora 1 0 ci sarà un ramo di computazione invece
 che rimane in Q2 e deve leggere ancora 1 0 giusto? vi trovate? stavo in Q1 leggo 1 si sdoppia 1 rimane in Q1 e rimane ancora da leggere 1 0 l'altro va in Q2 e rimane da leggere 1 0 ok allora questo piastro lo posso sviluppare da Q2 vado in Q3 e mi rimane da leggere 0 da Q3 vado in Q4 e non lo devo leggere nient'altro accetto ok
 è inutile no? è inutile giusto? è inutile perché però lo posso continuare a sviluppare se volete intanto ripeto da tutti e due perché questo qua si sdoppia no? siccome sta in Q1 e legge 1 cioè 1 è il ramo che va in Q2 e deve leggere 0 e poi va in Q3 e deve leggere epsilon e quindi ripiuta ce n'è un altro che rimane in Q1 che rimane in Q1 e deve leggere 0
 quando legge 0 rimane in Q1 e deve leggere 0 ok beh bastavano solo fatti poi qua sono fatti continuati perché così vogliamo continuare se c'erano stati due che accettavano davvero qua basta che accettavano però questo ancora non l'abbiamo questo ancora non l'abbiamo definito no? questo qua è una cosa certa
 aspettiamo 5 minuti ok ora facciamo bene si 1 1 0 1 1 0 no perché guardi se lei sta in Q1 la computazione va a andare solo in Q1 vedi la figura se sto in Q1 e lei con 0
 non funziona non funziona ok domande? altre domande? questo è un bellissimo disegno altre domande? e quindi questa è già per me confermata cioè c'è uno in terzo e l'ultimo ok vi lascio un altro esercizio vi lascio un esercizio per casa
 e poi ci torniamo per una pausa ok mi troppo agli appunti riguardo la dimostrazione ricorretezza della dimostrazione mi faccio un altro per finire qual è la classe di linguaggi riconosciuti dagli NFA? mi sono sciolta il tuo livello mi sembra un po' troppo c'è anche altro
 ok cioè ovvero voglio dire possiamo
 possiamo estendere? scusami chiamo a Cristian Cristian Cristian a te che è qua mettere là mettere qua concetto di configurazione quello che abbiamo già definito quello che abbiamo già definito per per il nè possiamo estendere il concetto di configurazione per un NFA? estendere e sarà una coppia?
 una coppia è QX stato è quello che devo ancora leggere in Q sisma epsilon ok cioè l'unica differenza sarà appunto che un NFA quindi la configurazione è sempre diciamo
 è sempre una coppia stiamo estendendo il concetto di configurazione ok cioè quindi per un NFA sarebbe una coppia QX dove appunto che sarà in Q sisma epsilon ok e ovviamente avremo avremo che diciamo P AX come l'abbiamo visto l'altra volta è in configurazione è diciamo in in relazione in relazione QX
 giusto? se e solo se se e se e se e la delta di P virgola A scusate se ok la delta di P virgola A è al contrario Q cioè Q appartiene al contrario
 questa è vero se Q appartiene a delta di P A ok dove ovviamente X appartiene a sigma star in questo caso A appartiene a sigma cioè se io c'ho quando è che diciamo che una coppia quindi una coppia ovviamente scusate qua sopra deve essere sigma star no? cioè una configurazione è una coppia Q e X dove X è in sigma e epsilon star
 una stringa cioè poi sta sto in un certo stato e devo ancora leggere l'insieme di caratteri non solo con il simbolo ok quindi quando è adesso una configurazione quando è una configurazione in relazione usando N N scusate in relazione con N con un'altra configurazione quando la prima configurazione è del tipo P e devo ancora leggere AX dove A è il primo carattere e X è tutto il resto no? e l'altra sarà QX che è quella che vado dove ho dopo aver letto
 l'unica differenza avevamo scritto nel caso di DFA Q uguale adesso sarà Q appartiene perché dato uno stato vado in un insieme di stati e una configurazione corrisponde a quella precedente se è una di quelle possibili dove posso andare ok? quindi l'unica differenza è che ci sarà A appartiene
 quindi è un insieme quindi nel caso di DFA io potevo scrivere Q uguale
 perché ci sono tanti possibili stati però basta che queste due configurazioni sono in relazione se lo stato di arrivo è uno dei possibili stati secondo la teoria a partire dallo stato di partenza ovvero se Q appartiene a DFA ha senso? DFA è DFA perché DFA è un insieme
 perché DFA appartiene a P di Q quindi è un insieme ha senso? io scriverò prima Q appartiene affanculo
 io scriverò prima Q appartiene a DFA ha senso? DFA è DFA perché DFA è un insieme
 il Q star tutti i possibili quindi quando è che N accetta adesso come dire no? quando è che N accetta W appartenente all'ultimo stato ok? si può stare qua se solo se se e solo se
 esiste Q appartenente a F tale che V0W è nella ricordate la relazione estesa con con
 dove N star è la è la relazione ma che simbolo è quello? quale? questo cioè quello la farfallina la farfallina P partizione simbolo di partizione no? P grande vi ricordate? esattamente definita come l'abbiamo definita l'altro si? quando è che N accetta W appartenente a P di Q si?
 quando è mi sto facendo la domanda quando è che N accetta W appartenente a sigma star ok? quando è che N accetta? se esiste uno stato se e solo se esiste uno stato finale ok? tale che Q0W è in relazione con QE cioè vuol dire che a partire dallo Q0W esiste una sequenza di transizioni che comporta il QE cioè ho finito di leggere tutto E e Q è il finale
 ok? la il simbolo perpendicolare con la star l'abbiamo già definito vedi lezione 1 ok? l'abbiamo definita lezione 1 l'abbiamo già definito significa che è un modo di definire una relazione una relazione tra due configurazioni cioè due si chiama relazione è un simbolo che indica una relazione cioè sto mettendo in relazione una configurazione con un'altra quando è che una relazione
 una configurazione è in relazione con un'altra si può seguire da quella secondo la logica del DFA per esempio una configurazione precede o si è il precedente si ma non è che la precede si può precedere capito? se quella la configurazione QX può derivare da P a X secondo la delta ok? quando leggo questo è per un singolo passo su ho fatto una relazione
 tra due configurazioni quando queste sono collegate da un singolo passo di computazione da un singolo passo di computazione ok? la la star vuol dire che le ho messe in relazione pure se sono lontane no? cioè vuol dire esiste una sequenza di passi dalle che mi fa partire da Q0W e mi porta allo stato QE ok? vi trovate? l'abbiamo fatto esattamente uguale col DFA ok? questo
 questo è la è la è la dimensione di linguaggio riconosciuto nel piano cioè ok? cioè in pratica se vi ricordate era una delle prime cose che avevamo fatto per me indietro lo ritrovo sicuramente e era questo
 ecco qua tranquillo Giova esattamente la stessa cosa ti si vuole bene stessa definizione posso definire il linguaggio accettato nel fermo nel fermo ok? come ho definito quello del DFA quindi a questo punto diciamo il DFA a questo punto ho finito tutto questo per dire che adesso adesso voglio adesso voglio
 confrontare due classi L di DFA uguale cioè la classe di linguaggi regolari ovvero la classe l'insieme di linguaggi tale che esiste in DFA che riconosce un linguaggio cioè reg è quello che abbiamo già definito la seconda classe è LNFA ovvero l'insieme di linguaggi L tale che esiste NFA
 N è tale che L di N è proprio uguale ok? questa è L di NFA è una classe ok? cioè come reg è la classe di linguaggi riconosciuti da DFA L di NFA è la classe di linguaggi riconosciuti da NFA ok? si non sto dicendo niente di complicato sto dicendo abbiamo definito reg vi ricordate? reg era l'insieme di linguaggi riconosciuti
 da un DFA ok? adesso mi sto facendo la stessa cosa con gli NFA e magari se due classi sono diversi no invece la risposta sarà solo uguale infatti io do un nome perché si chiama sempre reg ok? cioè L di NFA è l'insieme di linguaggi tali che esistono in NFA che riconosce quel linguaggio ok? adesso la domanda è sta classe è più grande più piccola com'è? ok? è la stessa fino adesso è la stessa ok?
 va bene? cioè non determinismo uguale determinismo nel caso degli FA ma non stiamo mettendo in campo le risorse questa è importante ok? cioè quindi il teorema il teorema ovvero L reg è uguale a L NFA ok?
 sono la stessa cosa va bene? cioè questo che significa? che significa che sono la stessa cosa? cioè questa prova in pratica mi dà una ricetta per dire che se un linguaggio cioè che cosa devo fare per dimostrare questa cosa? devo fare due cose formalmente devo fare due cose cioè devo dimostrare che sono uguali cioè se una cosa è riconosciuta da un DFA allora è riconosciuta da un NFA e viceversa se una cosa è riconosciuta da un NFA è pure riconosciuta da un DFA ok? questo è quello che devo fare
 la parte difficile o più non so più difficile è quella di dire una cosa che è riconosciuta da un NFA può essere riconosciuta anche da un DFA perché è chiaro che intuitivamente l'NFA sembra un modello di computazione più potente però vedremo così non è questo che cosa ci dice questo teorema? ci dice che ogni volta che devo dimostrare che un linguaggio è regolare nulla mi vieta di usare il non determinismo se mi viene più facile perché sono uguali ok? ha senso? ok il teorema è
 quindi dimostrazione ok? si è la classe è l'insieme è l'insieme è l'insieme di linguaggi l'ho definito? dimostrazione eh tutti i linguaggi si tutti i linguaggi tali che come reg è un insieme di linguaggi è una classe ok? l DFA l'ho chiamata reg dimostrazione quindi devo mostrare l NFA
 contenuto in L DFA e L DFA contenuto in L DFA allora sono uguali va bene? e ovvio se L appartiene a L DFA esiste N
 esiste D DFA D tale che L di D è proprio uguale a L ma allora N uguale D è NFA tale che L di N è uguale a L è vero? basta no? cioè nel senso che un DFA è pure un NFA ok? ovvio
 ok? cioè il DFA è un caso speciale di NFA ovvio ok? cioè quindi è chiaro che se un linguaggio è riconosciuto da un DFA cioè è regolare allora quel linguaggio sta pure nella classe dei linguaggi riconosciuti dagli NFA perché posso sempre considerare la NFA N uguale D giusto? eh sicuramente va bene li trovate? ha senso? mi siete persi?
 qualcuno si è perso? esatto non ha capito niente N uguale D lo sto prendendo io lo sto scegliendo io cioè perché devo far vedere appunto che se un linguaggio è nella classe dei linguaggi regolari cioè riconosciuti da un DFA sicuramente sta pure nell'insieme dei linguaggi riconosciuti dagli NFA perché? perché esiste un NFA che lo riconosce qual è questo NFA? proprio D perché D è un DFA
 vabbè ma un DFA è pure un NFA perché è un caso diciamo un caso speciale diciamo no? dove non considerano e non considerano gli epsilonarchi non considerano niente ok? cioè la computazione deterministica è un caso speciale di quella non deterministica ok? va bene?
 questo è banale ok? l'altra direzione è quella interessante cioè ok? l'altra direzione l'altra direzione cioè se L L appartiene a L NFA allora esiste esiste NFA N
 uguale chiamiamo QN non è che non mi si scrive no? delta N no? sì adesso dico zero N FN ci vediamo prima qua cioè non ho detto niente di complicato sto facendo l'altra direzione che è quell'unica interessante ok? l'unica interessante perché dico cioè voglio far vedere adesso che se L appartiene a NFA L NFA allora appartiene pure a L DFA ok? che significa questo? se L appartiene a NFA
 è L NFA cioè se è un linguaggio vuol dire che esiste un NFA e l'ho chiamato adesso QN sigma delta N zero N FN ok? chiamiamolo così tale che infatti proprio tale che L di N è proprio uguale a N ok? quindi questo è l'assunzione e questo è giusto che sigma non ci abbia N? sì perché per semplicità sarà lo stesso sigma ok? sì non ce l'ho messo ok? e devo far vedere
 devo costruire DFA T uguale QD sigma delta D Q zero D FD ok? tale che L di D pure è uguale a L ok? questo voglio fare se posso fare questo ho finito cioè ho fatto vedere che ogni linguaggio che è riconosciuto da un NFA è pure riconosciuto da un DFA va bene?
 ok? sì questa è l'altra parte ha senso? va bene però di fatto no? cioè questa cosa non è tanto complicata l'abbiamo già fatta quando abbiamo fatto la prova dell'unione che cosa abbiamo fatto? abbiamo fatto che abbiamo visto che un DFA può simulare la esecuzione parallela di due DFA giusto? dove appunto può monitorare può avere uno stato per ogni possibile cosa
 e monitorare che cosa fa il primo DFA e cosa fa il secondo DFA però se ci pensate un NFA non è non è tanto non è nient'altro che tante computazioni deterministiche in parallelo giusto? cioè perché la computazione non deterministica però una volta che mi so che si dirama si dirama si dirama ogni ramo by itself no? è deterministico giusto? cioè sono tanti rami deterministici cioè quindi che dovrò fare? dovrò semplicemente definire uno stato per tutti i possibili
 stati in cui la computazione si può diramare eh? cioè devo monitorare in parallelo tutti quanti ok? invece quindi di avere uno stato per ogni coppia di stati dovrò avere uno stato per ogni possibile sottoinsieme di stati però l'idea sarà la stessa ok? questo numero di stati adesso potrebbe crescere tantissimo ok? ma sarà finito però va bene? e il DFA l'unica condizione del DFA è che
 deve essere finito perché non ci sono non stiamo contando dei risultati ok? ha senso? va bene e quindi eh stessa idea stessa idea della prova molto triste per per ok? stessa idea lo scrivo tra parentesi ok?
 quindi facciamolo in due step ok? caso caso per semplice facciamo una semplificazione no epsilonati ok? supponiamo per semplicità che non ci stanno gli epsilonati ok? eh allora è facile avremo ok QD è uguale proprio all'insieme
 delle parti di QN ok? cioè questo ci dice quali sono tutti i possibili stati di QD? eh sono tutti i possibili sottoinsiemi di QN perché? perché D deve monitorare tutti i possibili cammini ok? va bene? e Q0 di D era semplicemente l'insieme no? Q0
 di N ok? ok questo perché ancora una volta no? cioè c'è uno stato per ogni sottoinsieme no? ok? quindi Q0 di D sarà l'insieme che contiene solo Q0 di N ok? va bene? cioè questo è come ho definito QD no? perché QD è un insieme di insieme quindi Q0
 di D deve essere insieme adesso però sarà l'insieme che contiene solo il singleton diciamo Q0 N ovviamente no? va bene? F di D cosa sarà F di D? F di D sarà adesso dovrò fare eh dovrò dire che questo è praticamente l'insieme di R appartenenti a QD cioè quali sono gli stati accettanti di D? sono quegli R appartenenti a QD tali che
 praticamente beh lo scriverei così R intersecato F di N è è diverso da 0 ok? ovvero diciamo R contiene uno stato finale di Q ok? cioè sto dicendo no? quindi QD
 quali sono gli stati di QD? ho risposto qua gli stati di QD sono tutti i possibili sottoinsiemi di QN ok? questo è quello che mi permette di dire è quello che mi permette di dire appunto è diciamo la generalizzazione del caso dell'unione dove QDD era Q1 per QD erano due due stati lì erano due stati Q1 per Q2 quindi sto considerando tutti i possibili sottoinsiemi ok? quindi questo significa che QD è un insieme di insiemi per come l'ho denotato
 ok? uno stato per ogni sottoinsieme ok? potrebbero essere tantissimi però finiti ok? va bene e lo stato iniziale è semplicemente lo stato che corrisponde all'insieme stato iniziale di N lo stato finale qual è? è l'insieme degli stati tali che là dentro ce ne sta almeno uno finale per N no? ok?
 cioè ovvero R intersegato F di N deve essere il senso perché ancora una volta R è sta dentro l'insieme delle parti di QN no? e lì dentro ci deve essere almeno uno che accetta ok? questo significa un cammino si è fermato in uno stato finale e adesso quando adesso l'ultima cosa che devo fare è definire la delta la delta che deve fare? deve partire dallo stato iniziale e deve in parallelo simulare tutti i rami di computazione
 possibili che sta facendo l'NFA ok? lo può fare perché appunto uno stato per D è un insieme di stati per N ok? e appunto come abbiamo detto la computazione non deterministica non è altro che tante computazioni deterministiche in parallelo e la delta dovrà prenderle tutte insieme ok? come abbiamo già fatto pure per l'unione solo che qui lo stiamo facendo all'estremo adesso ok? va bene? la delta
 sia R appartenente a R appartenente a QD cioè uno stato uno stato per D no? R appartenente a QD e A appartenente a sigma allora la delta di R A ok? come la scrivo la delta di R A?
 la delta di R A deve dirmi no? cioè mi deve dire no? se io sono nello stato R ok? cioè che significa stato R? stato R significa che è un insieme di stati dove può essere N sto tenendo tranquillo adesso leggo A ok? adesso attenzione quando N sta in un singolo stato e legge A può andare in tanti stati
 ok? perché ogni passo di computazione a sua volta si può diramare no? e io li devo tenere traccia di tutti quindi che devo fare? dovrò prendere l'unione di tutte le possibili stati in cui N può andare dovrò prendere l'unione no? perché li devo considerare tutti cioè sarà l'unione su R appartenente a R no? ricordiamoci R è l'insieme delle parti no? e quindi R adesso è un singolo stato no? e quindi posso scrivere qua delta N
 di R A ok? delta N di R A ricordatevi è un insieme può essere un insieme quindi sto prendendo l'unione di insieme no? un altro modo per scrivere questo è anche quello di dire è Q appartenente a Q N tali che Q appartiene delta N di R A
 questo lo scrivo tra parentesi perché è solo un modo più verboso per dire la stessa cosa nella slide cosa fa? F di R R è uno stato no? cioè come al solito no? cioè nel senso che prima di tutto devo definire gli stati prima di definire F devo definire Q come al solito adesso però vedi Q l'ho definito come P di Q di N P di Q di N è l'insieme
 delle parti di Q di N vuol dire che sono tutti i possibili sottoinsiemi di Q di N ok? quindi adesso quando scrivo adesso voglio dire tra tutti questi possibili sottoinsiemi ok? ogni sottoinsieme uno stato ok? ci siamo? quindi abbiamo detto uno stato per D è un insieme di stati per N questo lo stiamo dicendo ok? tra questi insiemi di stati quali è che sono finali?
 basta che ce ne sa almeno uno che è finale per N questo è quello che ci ho scritto R intersecato F di N uguale 0 uguale vuoto no? non uguale vuoto diverso lavoro perché R è un insieme di stati F di N è un insieme di stati quindi so fare l'intersezione tra due insiemi ce ne deve sta almeno uno che non è che sta dentro F di N che sta dentro il titolo cioè dentro R ce ne deve sta almeno uno a città finale per N cioè l'intersezione
 è carino che ci sia si no no perché R sta appartiene a Q di N quindi R sta dentro l'insieme delle parti di N perché Q di N l'ho definito come insieme delle parti di N in questo caso sarebbe il singolo stato
 giusto? perché appunto è certo esatto cioè perché dire che R sta dentro l'insieme delle parti vuol dire semplicemente che R è l'insieme dei stati cioè niente di più no? l'insieme delle parti è soltanto considerare tutti i possibili sottinsiemi ma quando prendo uno stato per D questo altro non è che un insieme di stati per N perché sto contando tutti i possibili stati insieme no? ok? quindi uno stato per D sono tanti stati per N
 un insieme per ognuno di questi R piccolo vado a vedere l'NFA che cosa fa l'NFA quando sta in R piccolo e legge A? A può andare in un insieme di stati perché è non deterministico e io prenderò l'unione di tutti quanti perché così li continuo a monitorare tutti in parallelo va bene?
 cioè prendi qualsiasi R e A sto definendo delta D di R A ha senso? ok va bene
 ok cioè adesso questo in questo caso non ho mai considerato gli epsilon archi ok? cioè l'unica cosa che devo fare adesso è considerare anche gli epsilon archi ok? però diciamo già lo possiamo vedere no? ancora una volta cioè adesso la prova formale sarebbe induzione delta star cioè la roba di prima però è chiaro che stiamo facendo la stessa cosa che abbiamo fatto prima cioè è chiaro che ripeto cioè quello vuol dire che parte dallo stato iniziale guardiamo la computazione di D
 parte dallo stato iniziale che contiene solo lo stato iniziale D dopodiché per ogni carattere che legge per ogni carattere che legge lui che cosa fa? per ogni carattere che legge? beh quando sta nello stato iniziale va a vedere che cosa fa N su input A stato iniziale quello può andare in un insieme di stati e lui infatti fa l'unione ok? li prende tutti in realtà diciamo
 nel caso iniziale non c'è bisogno nemmeno di fare l'unione no? cioè nel caso base nel caso base quando quello legge solo A è stato nello stato iniziale l'NFA andrà in un insieme di stati cioè delta N di stato iniziale A è un insieme di stati però l'unico stato che c'è dentro R in quel caso è lo stato iniziale vi trovate? perché vedete come ho definito lo stato iniziale? lo stato iniziale contiene solo Q0N ok? quindi se io applico la delta nello stato iniziale R grande
 è un solo insieme qual è? l'insieme su 0N ok? delta N di Q0N A è un insieme quindi adesso sono andato a finire in un insieme ok? adesso al prossimo passetto di computazione vado a vedere tutte le cose possibili che succedono quando l'NFA sta in ciascuno di quelli e prendo la loro unione perché li controllo fino a che con il calcolo a un certo punto basta che uno di quelli
 quando ho finito di leggere è accettante no? allora li devo accettare questa è la definizione di FD ok? cioè di fatto questo DFA sta eseguendo in parallelo il di fatto D sta emulando deterministicamente tutti i rami
 di computazione non deterministica ok? cioè sta facendo questo no? è un modo formale per dire questo va bene? aggiungo di epsilonarsi e poi faccio un esempio ok? cioè questo secondo me più di dire adesso faccio la prova
 di un'influenza eccetera eccetera che tanto non la trovate neanche sul libro e diventa secondo me troppo complicato dovrebbe essere chiaro ma per renderlo ancora più chiaro vi faccio proprio un esempio ok? cioè vi disegno un NFA e vi applico la prova di questo teorema e lo faccio diventare un DFA mistico ok? così vedete proprio i passi che sto facendo nella prova come li potete applicare anche nella pratica per trasformare un NFA in un DFA facciamo questo no?
 no no no no no no no no no no no no no no
 no no no no no no no no
 no no no no no no no
 no no no no no no no no no no no no no no no no no no no no no no no no no no no no no no
 no no no no no no
 ok? cioè sto considerando l'estensione di QD no? cioè QD dico sto in QD no? ok? cioè prima nel caso precedente quando stavo in QD QD era un insieme risolto insieme adesso a questi ci devo aggiungere pure tutti quelli che sono collegati con epsilon arco perché quando l'NFA sta in uno stato in un certo stato se c'è l'epsilon arco sta pure in quell'altro stato ce li sto aggiungendo praticamente no? sto considerando invece che QD l'estensione di QD
 ovvero tutti gli insiemi in cui può essere che possono essere raggiunti tutti gli stati scusate che possono essere raggiunti da stati in R attraverso un numero maggiore o uguale di 0 di epsilon arco ok? cioè ovvero che ho fatto di differenza rispetto a prima? prima c'era QD e QD era un insieme di stati anche adesso QD è un insieme di stati però adesso sto considerando il fatto che ci possono essere gli epsilon archi ovvero
 quando N sta in uno stato se c'è un epsilon arco sta pure in un altro stato ok? se ci stanno due epsilon archi sta pure in altri due stati e così via allora sto aggiungendo questi stati a QD come lo faccio? usando E di QD cioè E di QD è l'insieme di stati che possono essere raggiunti da un qualsiasi stato dentro R perché R è l'insieme di stati per N attraverso almeno un epsilon arco o forse 0 anche 0 va bene?
 e sono aggiungibili ok? e quindi a questo punto semplicemente a questo punto devo semplicemente considerare questa nella mia unione cioè nella mia unione la delta D cioè ovvero a questo punto posso dire che delta D di R A esattamente come prima delta D di R A
 quello che abbiamo definito prima nel caso senza epsilon archi adesso lo definiamo nel caso epsilon archi cioè prendo R appartenente a QD A appartenente a sigma a questo punto lo definisco così come semplicemente la stessa cosa di prima unione su R appartenente a R e adesso prima ci avevo messo delta N di R, A ok? va bene?
 delta N di R, A però adesso ci devo considerare pure che se vado a finire in delta N di R, A e poi c'è un epsilon arco allora quello lo voglio mettere pure nel delta D perché devo considerare pure gli epsilon archi allora qua ci metterò E praticamente ok? tutto qua
 ma ci vuole di zero eh vabbè sì però cioè se ho attraversato l'eccionario o non l'ho attraversato mi cambia poco cioè E di QD di R può essere semplicemente tutti gli stali e se io l'ho attraversato è un'arco ma tanto mi prendo qua precisa
 mi fa bene tutto vediamo attraversa zero può essere tutta questa linea bellissimo
 no però sto dicendo cioè che voglio che no questo è per dire semplicemente che no questo è semplicemente per dire che gli elementi che stanno già dentro QD di R rimangono no? cioè perché altrimenti lei considererebbe soltanto quelli che stanno cioè sono tutti quelli che già stanno in QD di R quindi zero epsilon archi più tutti quelli che invece può raggiungere usando epsilon archi quindi è giusto
 perché se non ci fosse il maggiore uguale ok? lei considererebbe soltanto quelli che a partire da QDD la porterebbero da qualche altra parte ma quelli in QDD lei se li vuole tenere no? è per quello che c'è lo zero eh no QDD è l'insieme di stadi ok? io voglio considerare questi più tutti quelli che posso raggiungere usando epsilon archi è per quello che c'è il maggiore uguale capito? è per questo che basta prendere l'estensione e fare esattamente come prima correttezza
 come so perché è una cosa che riguarda soltanto D scusa quello che ha detto qua perché? non dipende scusi
 perché mi sembra complicato ma R lo fissiamo R è fissato ok? cioè lo sto definendo per ogni possibile R questo è importante perché poi dopo la delta io la devo definire per ogni possibile R cioè quindi la mia definizione di E di QDD deve essere definita per ogni possibile ok? scusate ma io ho sbagliato a schierare lei voleva dire questo certo certo
 è sbagliato sopra è chiaro no? che ho sbagliato a schierare no QDD sono tutti i possibili QDD sono tutti i possibili adesso sto dicendo ne prendo uno in particolare scusate grazie grazie ok? cioè quindi li prendiamo ok? cioè è fisso un particolare insieme di stati perché QDD sono tutti quelli possibili ne sto fissando uno
 lo chiamo R R è un insieme di stati ok? a questi voglio tenere questi ve li voglio tenere tutti dentro e per quello c'è il maggiore uguale zero epsilon archi vuol dire che mi tengo tutti quelli che stanno là più tutti quelli che posso raggiungere a partire da stati in R usando epsilon archi ok? quindi ce li sto aggiungendo va bene? ha senso adesso? ok?
 allora vi lascio un esercizio e lo facciamo insieme poi la prossima volta per iniziare a ragionare su questa cosa ok? esempio e lo finiamo la prossima volta esempio dato il seguente NFA ed eccolo qua
 ah è quello di prima sai che è quello di prima? penso che sia quello lì che è quello che ho disegnato prima ma il come sopra sarebbe quello lì uguale identico all'unione giusto? penso si stia riferendo
 alla rettezza dovrebbe essere quello di prima e B A A B Epsilon A ok e definire il DFA di tale che L di D è uguale a L di E ok? cioè questo è il DFA è un NFA riconosce un certo linguaggio
 trovare il DFA che riconosce lo stesso linguaggio come faccio? uso questa procedura quella del teorema ok? cioè alla fine devi fare un disegno e questo disegno deve essere il DFA ok? sarà diciamo abbastanza involto non è una serie di stadi è una serie di frecce però di fatto non dovete fare altro che seguire la ricetta della dimostrazione del teorema
 definisco lo stato iniziale tutti i possibili sottinsiemi bla bla bla in questo caso tutti i possibili sottinsiemi sono l'insieme buono l'insieme che contiene solo 1 quello che contiene solo 2 quello che contiene solo 3 quello che contiene 1 2 quello che contiene 2 3 1 3 e 1 per 5 sono un numero piccolo fortunatamente e quindi questo ci permette poi di definire la delta per tutte le possibili transizioni provate a farlo a casa la prossima volta quando iniziamo la lezione lo risolviamo insieme
 va bene
