# Lezione 01
Benvenuti al corso di Automi. Siete tutti studenti di informatica? Benissimo. Piacere di conoscervi, io sono Daniele Venturi.

Sono un docente del Dipartimento di Informatica; cercando il mio nome online troverete la mia pagina personale con tutti i contatti e le informazioni necessarie, inclusa la pagina dedicata a questo corso, dove sono riportate tutte le informazioni pertinenti.

Il corso si terrà alla lavagna. Successivamente, caricherò sul sito il materiale scritto durante la lezione, mantenendo un diario aggiornato di quanto svolto. Potrete trovare tutto sul sito del corso.

Il libro di testo consigliato è "Introduzione alla Teoria della Computazione" di Michael Sipser. È un libro scritto molto bene, famoso nell'ambito dell'informatica teorica e considerato un testo storico. Seguirò questo libro in modo abbastanza fedele per circa due terzi del corso. L'ultima parte, dedicata alla complessità, è trattata in modo un po' datato nel libro di Sipser; sebbene gli argomenti siano presenti, sono presentati in maniera compressa e di difficile lettura. Per quella sezione, vi consiglierò un altro libro o potrete fare riferimento agli appunti delle lezioni. Comunque, quasi tutti gli argomenti trattati saranno disponibili sul sito.

Per quanto riguarda il ricevimento, non ho un orario fisso. Se avete dubbi, potete scrivermi una mail e possiamo discuterne a lezione o fissare un appuntamento se necessario.

### Modalità d'esame

L'esame per questo corso è scritto e suddiviso in tre parti, una per ciascuno dei macro-argomenti del corso:
1.  Teoria degli Automi
2.  Calcolabilità
3.  Complessità

Ogni parte dell'esame sarà composta da due sezioni: una domanda di teoria e un esercizio.
La domanda di teoria richiederà di esporre i concetti studiati durante il corso, esattamente come sono stati spiegati. La parte pratica, invece, consisterà nel risolvere un piccolo problema relativo agli argomenti trattati. Vedremo numerosi esempi di tali problemi durante le lezioni.

In questo corso, come in altri, capire la teoria è una cosa, mentre imparare a risolvere gli esercizi è un'altra. Gli esercizi richiedono un modo di ragionare a cui potreste non essere abituati. Il consiglio che vi do, basato sulla mia esperienza pluriennale di insegnamento di questa materia, è di iniziare a fare esercizi fin da subito. Gli argomenti sono modulari: una volta compreso il funzionamento degli automi a stati finiti, quel concetto non cambierà nei mesi a venire, quindi potete esercitarvi immediatamente. Faremo esempi a lezione e vi suggerirò esercizi da svolgere a casa, ma spetterà a voi portare avanti il vostro percorso di apprendimento.

Sono previsti anche tre momenti di esercitazione in classe, uno alla fine di ogni macro-argomento, in cui ci concentreremo esclusivamente sulla risoluzione di esercizi.

Ci sono domande sulla logistica? Mi sentite bene in fondo all'aula? Bene.

### Panoramica del corso

Iniziamo descrivendo gli argomenti che tratteremo. Questo è un corso di fondamentale importanza, non perché lo tenga io, ma perché per un informatico è essenziale conoscere i concetti di teoria della calcolabilità e della complessità. È un corso affascinante, specialmente se apprezzate la teoria, ma con ovvie e profonde implicazioni pratiche. Stiamo studiando ciò che un computer può fare e, soprattutto, ciò che non può fare.

Le persone che hanno mosso i primi passi in questo campo si sono chieste per la prima volta quali fossero i limiti della computazione. È una domanda affascinante: prima è stato inventato il computer, e solo dopo ci si è interrogati su cosa fosse possibile farci e cosa no. In questo corso, esploreremo le risposte che abbiamo trovato a questa domanda, ma vedremo anche quanto ancora ignoriamo.

La domanda fondamentale che guiderà il nostro percorso è: **quali sono le limitazioni intrinseche della computazione?**

Questa domanda ha origine negli anni '30, con il lavoro di pionieri come Turing e Gödel. Per poter studiare i limiti della computazione, è indispensabile avere un modello matematico di cosa significhi "computazione". Senza una definizione formale, è impossibile dimostrare che qualcosa si possa o non si possa calcolare. Il formalismo matematico e logico è quindi uno strumento necessario.

Il corso sarà suddiviso in tre parti.

#### 1. Teoria degli Automi

In questa prima parte, introdurremo il modello di computazione più semplice esistente: l'**automa a stati finiti**. La sfida nella creazione di questi modelli risiede in un compromesso: un modello matematico di un laptop moderno sarebbe estremamente complesso e difficile da analizzare. La genialità dei pionieri di questo campo è stata quella di definire un linguaggio semplice ma sufficientemente potente da descrivere ciò che un computer può fare, astraendo da tutti i dettagli non essenziali. Hanno creato una definizione minimale che permette comunque di ottenere risultati interessanti. Se la definizione fosse troppo complessa, non sarebbe analizzabile; se fosse troppo semplice, non rappresenterebbe fedelmente le capacità di un computer reale.

L'automa a stati finiti non è abbastanza potente da rappresentare tutto ciò che un computer può fare, ma può modellare alcuni processi importanti che vengono implementati nel mondo reale. Lo possiamo vedere come il primo passo per comprendere i modelli di computazione.

Le applicazioni reali di questo modello includono:
*   Algoritmi per il riconoscimento e l'estrazione di pattern dai dati (es. riconoscere determinate sequenze in un testo).
*   I parser utilizzati nei compilatori per i linguaggi di programmazione.

Il fatto che un modello semplice possa risolvere problemi pratici è un vantaggio, perché la sua semplicità si traduce in una maggiore efficienza di implementazione. Non sempre è necessario un supercomputer; per certi compiti, un modello di calcolo più semplice è sufficiente e più efficiente.

Esploreremo il mondo degli automi e inizieremo già a intravedere i confini della computazione. Vedremo che, sebbene questo modello permetta di fare molte cose, ce ne sono altre che gli sono precluse. Dimostreremo che esistono problemi che questo modello non potrà mai risolvere, indipendentemente dalle risorse a disposizione (tempo o spazio).

#### 2. Teoria della Calcolabilità

Motivati dai limiti del primo modello, passeremo a studiare la calcolabilità, ovvero cosa si può risolvere e cosa è intrinsecamente irrisolvibile. Per fare ciò, considereremo un modello di calcolo molto più potente: la **Macchina di Turing**.

Qualsiasi algoritmo scrivibile in un linguaggio come Python può essere implementato anche da una Macchina di Turing. Certo, l'implementazione sarà più macchinosa, perché la Macchina di Turing è un modello volutamente semplice, spogliato di ogni astrazione, per facilitarne l'analisi matematica. Questo modello, pur essendo semplice da definire, è abbastanza generale da permetterci di dimostrare risultati sorprendenti, come il fatto che **esistono problemi che nessun computer potrà mai risolvere**.

Un esempio celebre è l'**Halting Problem** (il problema dell'arresto): stabilire se un dato programma (per noi, una Macchina di Turing) terminerà la sua esecuzione o entrerà in un ciclo infinito. Questo è un problema non risolvibile da nessun computer. E non è un caso isolato: una volta trovato un problema indecidibile, se ne possono trovare infiniti altri.

È importante sottolineare che questa impossibilità è indipendente dalle risorse: anche con tempo e spazio infiniti, questi problemi rimangono irrisolvibili.

Questi concetti hanno implicazioni profonde che vanno oltre l'informatica. Esiste un parallelo affascinante tra problemi non calcolabili e affermazioni matematiche non dimostrabili. Questo ci porta al celebre **Teorema di Incompletezza di Gödel**. Gödel, un logico, dimostrò che in ogni sistema matematico sufficientemente potente (come l'aritmetica di Peano), esistono affermazioni che non possono essere né dimostrate né confutate all'interno del sistema stesso.

Dimostrare questo teorema richiede tipicamente un intero corso di logica matematica. Tuttavia, una delle bellezze della teoria della computazione è che ci fornisce strumenti per spiegare concetti di altre discipline. Vedremo come il Teorema di Gödel possa essere dimostrato utilizzando la Macchina di Turing. Una volta compresi i concetti di calcolabilità, la dimostrazione diventa accessibile senza la necessità di approfondire tutta la logica formale.

#### 3. Teoria della Complessità

Nella terza e ultima parte del corso, introdurremo il concetto di **risorse computazionali**, principalmente tempo e spazio. Ci chiederemo: tra i problemi che *possono* essere risolti, quali possono essere risolti in modo efficiente?

Da sempre, l'uomo si è accorto che esistono problemi "difficili", non perché impossibili da risolvere, ma perché richiedono una quantità di tempo proibitiva.

Un esempio classico è il **problema della fattorizzazione** (factoring). Dato un numero $$n$$ che è il prodotto di due numeri primi $$p$$ e $$q$$ ($$n = p \times q$$), il problema consiste nel trovare $$p$$ e $$q$$ a partire da $$n$$.
Consideriamo numeri molto grandi, ad esempio con 1024 bit.

*   **Moltiplicazione (problema facile):** Calcolare $$n$$ dati $$p$$ e $$q$$ è un'operazione "facile". Esistono algoritmi efficienti (come quello che abbiamo imparato alle elementari) che risolvono il problema in un tempo polinomiale rispetto alla dimensione dell'input (cioè, il numero di bit, 1024). L'insieme di tutti i problemi risolvibili in tempo polinomiale è chiamato classe **P**.
*   **Fattorizzazione (problema apparentemente difficile):** Risolvere il problema inverso, cioè trovare $$p$$ e $$q$$ dato $$n$$, sembra essere molto più difficile. L'approccio più semplice (la forza bruta) consiste nel provare a dividere $$n$$ per tutti i numeri primi fino a $$\sqrt{n}$$, un processo che richiede un tempo esponenziale. Nonostante secoli di tentativi da parte dei più grandi matematici, il miglior algoritmo conosciuto per la fattorizzazione ha una complessità sub-esponenziale, che in pratica è ancora troppo lenta per numeri grandi. Sospettiamo, quindi, che questo problema non sia in **P**.

Tuttavia, il problema della fattorizzazione ha una proprietà interessante: se qualcuno ci fornisce una potenziale soluzione (una coppia di numeri $$p'$$ e $$q'$$), possiamo **verificare** in modo efficiente se è corretta. Basta controllare se $$p'$$ e $$q'$$ sono primi (operazione che si può fare efficientemente) e se il loro prodotto è uguale a $$n$$.

L'insieme di tutti i problemi per cui una soluzione può essere verificata in tempo polinomiale è chiamato classe **NP** (Non-deterministic Polynomial time).

Questo ci porta a una delle domande più importanti e affascinanti della scienza moderna: **P = NP?**

Questa è una delle sette "Millennium Prize Problems" del Clay Mathematics Institute, con in palio un milione di dollari per chi la risolve. La comunità scientifica crede prevalentemente che la risposta sia "no", ovvero che esistano problemi in NP che non sono in P, ma nessuno è ancora riuscito a dimostrarlo. In questo corso, studieremo le basi della teoria della complessità e i risultati principali legati a questa domanda fondamentale.

Un'ultima nota riguarda i modelli di calcolo alternativi. La discussione fin qui si basa sulla computazione classica (la Macchina di Turing). Tuttavia, esiste un modello basato sulla fisica quantistica: il **computer quantistico**. Negli anni '90, Peter Shor ha sviluppato un algoritmo quantistico che può risolvere il problema della fattorizzazione in tempo polinomiale. Questo ha enormi implicazioni, poiché la sicurezza di gran parte della crittografia moderna si basa sulla presunta difficoltà della fattorizzazione. Sebbene un computer quantistico su larga scala non sia ancora stato costruito, la minaccia potenziale ha già spinto la comunità crittografica a sviluppare alternative "post-quantum".

---

Ora che abbiamo una panoramica, iniziamo con il primo argomento.

### Automi e Linguaggi Regolari

Il primo modello di computazione che considereremo è l'**automa a stati finiti deterministico** (in inglese, Deterministic Finite Automaton o **DFA**).

È un modello semplice per due ragioni principali:
1.  Ha una quantità di memoria limitata (contenuta nei suoi stati).
2.  Processa l'input in modo sequenziale, un simbolo alla volta, senza mai tornare indietro.

Questa semplicità lo rende estremamente efficiente e adatto a compiti come il parsing o il riconoscimento di pattern, come menzionato prima.

#### Esempio Intuitivo: Porta Automatica

Immaginiamo di dover programmare il sensore di una porta automatica. Il sistema deve decidere se aprire o chiudere la porta in base a degli eventi. Le possibili situazioni (stati) della porta sono "APERTA" e "CHIUSA". Gli eventi (input) possono essere: "nessuno presente", "qualcuno davanti", "qualcuno dietro", "qualcuno davanti e dietro".

Possiamo descrivere il comportamento del sistema con una tabella di transizione che, per ogni stato corrente e ogni input, specifica lo stato successivo.
*   Se lo stato è "CHIUSA" e l'input è "qualcuno davanti", il nuovo stato sarà "APERTA".
*   Se lo stato è "APERTA" e l'input è "nessuno presente", il nuovo stato sarà "CHIUSA".
*   Se lo stato è "CHIUSA" e l'input è "nessuno presente", lo stato rimane "CHIUSA".

Questo sistema può essere visualizzato come un **diagramma di stati**. Gli stati ("APERTA", "CHIUSA") sono rappresentati da cerchi, e le transizioni sono frecce etichettate con l'input che le causa.

Questo è il primo esempio di un automa: un sistema con un numero finito di stati che cambia stato in base a una sequenza di input.

#### Esempio Formale di Automa

In informatica teorica, gli automi vengono usati per **riconoscere linguaggi**. Un linguaggio è semplicemente un insieme di stringhe (sequenze di simboli) che possiedono una certa proprietà. Ad esempio:
*   Il linguaggio di tutte le stringhe binarie che iniziano con '0' e finiscono con '1'.
*   Il linguaggio di tutte le stringhe binarie con un numero pari di '1'.

Un automa "riconosce" un linguaggio se, dopo aver letto un'intera stringa, termina in uno speciale **stato di accettazione**.

Vediamo un esempio di DFA che opera su stringhe binarie ('0' e '1'):

L'automa ha tre stati: $$q_1, q_2, q_3$$.
*   $$q_1$$ è lo **stato iniziale** (indicato da una freccia entrante).
*   $$q_2$$ è uno **stato di accettazione** (indicato da un doppio cerchio).
*   Le frecce tra gli stati sono le **transizioni**, etichettate con il simbolo di input ('0' o '1') che le attiva.
    *   Da $$q_1$$, con '0' si rimane in $$q_1$$; con '1' si va in $$q_2$$.
    *   Da $$q_2$$, con '1' si rimane in $$q_2$$; con '0' si va in $$q_3$$.
    *   Da $$q_3$$, sia con '0' che con '1' si va in $$q_2$$.

Come funziona la computazione? Prendiamo la stringa di input `101`.
1.  Si parte dallo stato iniziale $$q_1$$.
2.  Si legge il primo simbolo, '1'. La transizione da $$q_1$$ con '1' porta a $$q_2$$.
3.  Si legge il secondo simbolo, '0'. La transizione da $$q_2$$ con '0' porta a $$q_3$$.
4.  Si legge il terzo simbolo, '1'. La transizione da $$q_3$$ con '1' porta a $$q_2$$.
5.  La stringa è finita. L'automa si trova nello stato $$q_2$$. Poiché $$q_2$$ è uno stato di accettazione, la stringa `101` viene **accettata** dall'automa.

Se l'input fosse stato `0`, saremmo partiti da $$q_1$$, letto '0' e rimasti in $$q_1$$. Poiché $$q_1$$ non è uno stato di accettazione, la stringa `0` sarebbe stata **rifiutata**.

Un automa non calcola un output, ma prende una decisione: accetta o rifiuta la stringa di input. Per questo motivo viene anche chiamato **decisore**.

#### Definizione Formale di DFA

Formalmente, un automa a stati finiti deterministico (DFA) è una tupla di 5 elementi:
$$ M = (Q, \Sigma, \delta, q_0, F) $$
dove:
1.  $$Q$$ è un insieme finito di **stati**.
2.  $$\Sigma$$ è un insieme finito chiamato **alfabeto** (i simboli di input).
3.  $$\delta: Q \times \Sigma \to Q$$ è la **funzione di transizione**, che prende uno stato e un simbolo di input e restituisce lo stato successivo.
4.  $$q_0 \in Q$$ è lo **stato iniziale**.
5.  $$F \subseteq Q$$ è l'insieme degli **stati di accettazione** (o stati finali).

Nell'esempio precedente:
*   $$Q = \{q_1, q_2, q_3\}$$
*   $$\Sigma = \{0, 1\}$$
*   $$q_0 = q_1$$
*   $$F = \{q_2\}$$
*   $$\delta$$ è la funzione rappresentata dalla tabella delle transizioni:
* 

### Linguaggio di un Automa

L'insieme di tutte le stringhe che un automa $$M$$ accetta è chiamato il **linguaggio riconosciuto da M**, e si denota con $$L(M)$$. Un automa accetta molte stringhe, ma riconosce un solo linguaggio.

Per definire formalmente $$L(M)$$, dobbiamo estendere la funzione di transizione $$\delta$$, che opera su singoli simboli, a una funzione che opera su intere stringhe.

#### Funzione di Transizione Estesa

La funzione di transizione estesa, denotata con $$\delta^*$$, prende uno stato e una stringa e restituisce lo stato in cui l'automa si trova dopo aver letto l'intera stringa.
$$ \delta^*: Q \times \Sigma^* \to Q $$
(dove $$\Sigma^*$$ è l'insieme di tutte le stringhe sull'alfabeto $$\Sigma$$, inclusa la stringa vuota $$\epsilon$$).

La definiamo ricorsivamente:
1.  **Caso base:** Per la stringa vuota $$\epsilon$$, $$\delta^*(q, \epsilon) = q$$. (Leggendo nulla, si rimane nello stesso stato).
2.  **Passo induttivo:** Per una stringa $$w$$ che può essere scritta come $$xa$$ (dove $$x$$ è una stringa e $$a$$ è un simbolo),
    $$ \delta^*(q, xa) = \delta(\delta^*(q, x), a) $$
    (Per calcolare dove si arriva leggendo $$xa$$, prima si calcola dove si arriva leggendo $$x$$, e poi si applica la transizione $$\delta$$ per l'ultimo simbolo $$a$$).

#### Definizione formale del linguaggio

Ora possiamo definire il linguaggio di un DFA in modo preciso.
Un automa $$M = (Q, \Sigma, \delta, q_0, F)$$ accetta una stringa $$w \in \Sigma^*$$ se e solo se $$\delta^*(q_0, w) \in F$$.

Il linguaggio riconosciuto da $$M$$ è quindi:
$$ L(M) = \{ w \in \Sigma^* \mid \delta^*(q_0, w) \in F \} $$

In altre parole, $$L(M)$$ è l'insieme di tutte le stringhe che, partendo dallo stato iniziale $$q_0$$, portano l'automa in uno degli stati di accettazione in $$F$$.

