# Lezione 02
 l'automa che è stato definito come primo modello semplice della computazione abbiamo considerato qualche piccolo esempio e abbiamo soprattutto definito che cosa significa che un'automa riconosce un linguaggio adesso, quindi, siccome abbiamo definito l'automa, abbiamo capito che significa che l'automa parla una certa lingua, cioè riconosce
 un certo linguaggio possiamo considerare l'insieme di tutti i linguaggi che sono riconosciuti da automi di questo tipo, cioè una classe quindi c'è un'automa che ha associato un linguaggio, cioè tutte le stringhe che riconosce ci sono tanti automi ognuno di questi ha il suo linguaggio associato un linguaggio, tante stringhe una classe, tanti linguaggi
 che possono essere riconosciuti da automi questi si chiamano linguaggi regolari e sono una classe importante di linguaggi e appunto sono importanti per tutte quelle applicazioni di cui vi ho parlato l'altra volta cioè riconoscimento di pattern, compilatori eccetera sono tutti esempi di linguaggi regolari la prima classe importante di linguaggi che studiamo in questo corso la definiamo sono i linguaggi
 linguaggi regolari cioè reg è una classe di linguaggi contenuti
 in sigma star tale che esiste un dfa m tale che l di m è proprio uguale a l ok? cioè questo ho detto l'insieme di tutti i linguaggi contenuti in sigma star tale che esiste un dfa m che ha associato proprio il linguaggio
 quindi tutti gli insiemi di linguaggi che sono riconosciuti da da dfa va bene, come vedremo questa è una classe importante ok? è una classe importante e infatti vedremo che vedremo che non tutti i linguaggi sono regolari ok? cioè vedremo che ci sono cioè che i dfa hanno dei libri
 che non sanno esplorare i limiti della computazione cioè abbiamo introdotto un modello formale di computazione vedremo che può fare un sacco di cose però vedremo che non può fare altre cose ok? cioè ci sono linguaggi che non stanno là dentro va bene? ok ci sono linguaggi che non sono regolari ok in generale adesso invece vogliamo fare un po' alcuni esempi no? cioè un po' di esempi più esempi di progetto di dfa per capire un po' come si fa a progettare dei dfa in alcuni casi semplici ok?
 un esempio di esercizio ok? cioè un tipico esercizio è disegno di progetto di dfa che riconosce questo linguaggio ok? quindi vogliamo dare un po' dei principi no? cioè vedremo dei principi cioè prima vedremo degli esempi semplici ok? e poi vedremo anche che i linguaggi regolari hanno alcune proprietà importanti ok? rispetto a che ti consentono diciamo di progettare dfa in maniera più organica no? cioè andando a sfruttare
 un linguaggio complicato e pensandolo come la suddivisione di più linguaggi no? che possono essere concatenati oppure uniti o intersegati ok? cioè quindi questo è utile no? vedremo dei progetti come diciamo dei principi di design ok? come se dovessimo fare il design di dfa ok? cioè vogliamo capire adesso quindi qui vogliamo capire capire come progettare
 progettare dfa per un dato linguaggio per un dato linguaggio ok? e diciamo questo è un po' come quando cioè vi si chiede in altri corsi di fare un algoritmo cioè fai un algoritmo fai un codice che fa questa cosa che ordina un array cioè è un po' la stessa cosa come la progettazione
 di algoritmi ok? solo che con le regole degli dfa cioè diciamo gli dfa hanno un numero finito di stati hanno una delta che ti dice quando passi da uno stato all'altro quando accetti quando in quali stati sono accettanti eccetera va bene però è la stessa è la stessa cosa no? e infatti diciamo se io ti do un linguaggio non è che c'è solo un dfa che riconosce il linguaggio ce ne potrebbero essere 5 7 200
 quindi vanno tutti bene cioè se funzionano diciamo vanno tutti bene ovviamente cioè sia diciamo nella vita sia a livello di esame cioè se uno dice di fare un dfa non è che cioè se funziona funziona e c'è diciamo un discorso che non faremo non studieremo tanto in questo corso sul fatto di ottimizzare minimizzare per esempio il numero di stati no? cioè meno stati ci stanno intuitivamente più efficiente è il dfa no? cioè magari puoi fare un dfa molto complicato che riconosce un linguaggio semplice che ha 200
 stati ma questi 200 stati li puoi ridurre diciamo a 5 quindi diciamo questo problema di efficienza però non ci spingeremo così tanto a studiare il dfa dal punto di vista di minimizzare solo degli stati e così via va bene lo useremo più come modello di computazione per per capire i limiti della computazione come punto di partenza per il corso va bene però diciamo cerchiamo di capire un po' facciamo degli esempi ok?
 esempi esempi ok? cioè tipo ad esempio io dò un linguaggio dico l che è si c'è scritto questa è la stessa questa è la volta scorsa
 comunque le carico sul sito alla fine della lezione cioè entro stasera va bene e ok quindi per esempio l l'insieme delle stringhe x appartenenti a 0 1 n 0 1 star scusate 0 1 star tali che x è uguale a 1
 y dove y pure si trova in 0 1 star ok? 1 y si 1 y esatto lo puoi scrivere puoi vedere se puoi scrivere più chiaramente 1 con catenato y ok? cioè sono tutte le stringhe che cominciano per 1 ok? di fatto
 no? sono tutte le stringhe che cominciano per 1 cioè vuol dire che se cominciano per 1 la devo accettare no matter what ci sta a dover dipendentemente da quello che ci sta a dover se invece non cominciano per 1 devo sempre giudare ok? quindi vabbè uno ci può cominciare a pensare e per esempio gli può venire in mente che una cosa di questo di questo tipo funziona no? adesso ripeto cioè non è che c'è un modo solo per farlo
 e cioè un modo per farlo è questo che significa lo start? start significa che nella figura cominciamo dall'alto ok? cioè è un modo per dire q0 è lo stato iniziale ok? perché abbiamo visto nella definizione di dfa c'è lo stato iniziale quindi devi dire qual è lo stato iniziale lo denotiamo così come start ok? start sarebbe il punto da cui ok?
 c'è un accidente che so start ragazzi mi domandano quali di testa 0 e 1 start sono tutte le stringhe binarie di lunghezza arbitraria e io non ci credo che al terzo anno voi non sapete che cos'è 0 e 1 start non lo sapete mai visto 0 e 1 start prima volta va bene non fa niente perché tanto adesso ripeto come ho detto l'altra volta siccome adesso cominciamo a studiare capiremo che significa unire linguaggi concatenare linguaggi
 fare la potenza di linguaggi siccome lo start è un esempio di potenza ok? vedremo la definizione formale di start ok? se proprio visto che insistete ok? ve la spiego però diciamo non è così importante adesso definirlo in maniera formale ok? cioè 0 e 1 start è semplicemente tutte le stringhe binarie perché 0 e 1 ok? però è start no? cioè la potenza cioè 0 e 1 è come 0 e 1 alla 1 perché sarebbe o 0 o 1 ok?
 cioè vuol dire che è una stringa binaria di lunghezza 2 ci siamo? cioè quindi no? 0 0 0 1 1 0 1 1 0 1 3 sono tutte quelle di lunghezza 3 0 1 4 sono tutte quelle di lunghezza 4 0 1 5 sono tutte quelle di lunghezza 5 va bene? 0 e 1 start è l'unione di tutti questi fino a n che va infinito ok? cioè quindi sono tutte quelle può essere di lunghezza 1 può essere di lunghezza 2 può essere di lunghezza 3 può essere di lunghezza 4 può essere di lunghezza 5 può essere di lunghezza n per ogni n naturale ok? cioè vuol dire che è una stringa binaria di una lunghezza 2
 lunghezza arbitra ok? è un modo per dire che è una stringa binaria di qualsiasi lunghezza ok? cioè questo è importante no? cioè ricordatevi sempre che infatti cioè una delle cioè sebbene i DFA no? sono modelli di computazione semplici no? sanno fare una cosa che non è così semplice cioè loro sanno riconoscere una stringa che sta in un linguaggio infinito ok? cioè non è che il DFA lo sa dice ok ci stanno armando su n caratteri no? non è così funziona per ogni n no? cioè capito? è potente questa cosa
 cioè non è che lo sanno a priori quanto è lunga la stringa di input infatti il linguaggio è infinito 0 1 star è un linguaggio infinito perché i numeri naturali sono infiniti però il DFA qualsiasi stringa gli dà input se c'è quella forma te la accetta se è lunga 5 10 100 1 milione 2 miliardi è chiara la cosa ok? quindi 0 1 star è un stringa infinito è chiaro adesso? prego a 0 1 star
 y a qualche 0 1 star questa parentesi questa qua questa no? questa è la parentesi che chiude quella a sinistra cioè non c'entrava tutto su una riga lo scritto in due righe no? questa parentesi graffa chiude la parentesi graffa la parentesi graffa e lo scappa eh?
 quella quella prima della star invece è un'altra parentesi graffa quella è la prima della star no? quella è un sì sì certo sì sembra sì certo è una parentesi graffa ragazzi ma cioè è banale allora ve lo scrivo meglio eh? cazzo è vero questa è una parentesi graffa e questa è uno star sì va bene così? sì ok cioè quindi semplicemente sto dicendo che L è il linguaggio di tutte le stringhe binarie
 che iniziano per 1 ok? non sto dicendo niente di complicato è solo che l'ho scritto in maniera precisa ok? va bene adesso posso fare così no? ci sarà Q1 e ci sarà Q e Q2 va bene? e Q1 sarà accettante ok? allora faccio cioè questa cosa dico ok la stringa deve cominciare per 1 se deve cominciare per 1
 devo accettare no? cioè quindi è facile no? cioè se comincia per 1 cioè quando sto a Q0 leggo 1 ok? la prima cosa che leggo è 1 vuol dire che devo accettare già per questo è Q1 accettante adesso qualsiasi cosa leggo non mi muovo più ha senso? se invece inizia per 0 vado in Q2 siccome inizia per 0 non devo accettare mai più adesso rimango sempre qua no? sì
 dal primo stato di start se prendo 0 ritorno in Q0 dal primo stato di start? start e Q0 sono la stessa cosa eh no sì se leggo 0 rimango in quello stato stesso senza usare Q2 non va bene no? perché se poi legge 0 1 se legge 0 1 no? se lei togliesse Q2 no? ok? e lei legge 0 1 cioè quindi lei dice
 questa cosa non la può fare perché non ci può mettere 0 1 in Q0 perché ci sta già 1 no? cioè questo è un odoma deterministico no? cioè da uno stato quando legge 1 può andare in un solo altro stato ok? se lei ha messo la precetta che da Q0 va a Q1 ok? forse diceva forse diceva quello 0 che senza Q2 è quello 0 che ritorna in Q0 eh ho capito non va bene perché non va bene?
 perché invece di mettere Q2 Q2 lo tolgo ok? adesso invece di mettere Q2 metto una freccia che da Q0 torna in se stessa ed è marcata con 0 ok? questa era la proposta non va bene perché se faccio così prendiamo per esempio la stringa 0 1 ok? comincia da Q0 legge 0
 rimane in Q0 legge 1 va in Q1 e accetta ha accettato 0 1 0 1 sta nel linguaggio? no sta nel linguaggio quindi va bene va bene ok? che senso? cioè che quando ha finito di legge rimane in uno stato accettante colorato è lo stato colorato
 è lo stato accettante esatto quasi esatto esatto esatto è lo stato accettante non è molto precoce quindi Q2 lo usiamo per scartare queste stringhe in funzione del termine esatto ok? cioè questo perché adesso io l'ho fatto cioè praticamente no? ci siamo? cioè questo è un caso semplice ok? c'è solo due stati ok? solo due stati quindi la delta la posso scrivere tutta no? cioè è molto semplice
 perché tu immagini un DFA complicato che c'ha centinaia di stati no? e vai a far tutta la tabella cioè la puoi fare perché sono finiti ovviamente no? però potrebbero essere tanti no? cioè a volte diciamo quando si scrivono i DFA per linguaggi più complicati la delta non si definisce dappertutto cioè per esempio cioè Q2 di solito si chiama lo stato pozzo ok? lo stato pozzo perché una volta che ci vado non ne esco più ok? siete d'accordo? e in realtà io sarebbe anche corretto
 diciamo questo dal punto di vista anche degli esercizi no? cioè è corretto se io Q2 non ce lo metto ok? e quando Q0 quando sono in Q0 e leggo 0 non disegno che cosa succede non ci sta scritto ok? cioè è una convenzione che se io leggo un diagramma sto in uno stato e leggo una cosa e il diagramma non mi dice dove devo andare allora ha rifiutato non va da nessuna parte quelli che rimane là ha rifiutato ok? va bene?
 la delta non è definita equivale a dire che il DFA va a finire in uno stato pozzo perché questa cosa la puoi sempre implementare con lo stato pozzo capito? cioè è equivalente a dire il DFA sta in uno stato legge una cosa e va in uno stato pozzo a dire il DFA sta in uno stato legge una cosa e non si sa che fa tanto potrei sempre aggiungere uno stato pozzo no? però tu immagini un DFA con 150 stati dove cominciamo a mettere stati pozzo dappertutto il disegno diventa ok? cioè capito? con il punto ok?
 però adesso questi hanno due stati ci ho messo tutti ci ho messo pure uno stato pozzo no? ok? allora vedi vi accorgete abbastanza presto no? che cioè in effetti dice vabbè ma perché è così e non era così e perché questo va bene e questo non va bene sì allora funziona con 0 0 0 0 1 non funziona con quell'altro come faccio ad essere sicuro che ho fatto bene? giusto no? no perché è giusto no? cioè io ho fatto una cosa arriva lui e dice ma perché non potevi fare così no?
 e va bene cioè si può fare in modi diversi no? però la cosa importante per questo tipo di esercizi è che uno poi infatti mi deve convincere che va bene no? ok? cioè io dopo che tu hai fatto hai disegnato sta roba no? che è una pagina magari all'esame no? due righe mi spieghi perché secondo te va bene no? giusto? fare in astro se tu me lo spari soltanto così io dico no? come faccio? ok? è chiaro?
 cioè ci vuole ci vorrebbe dal punto di vista matematico no? perché abbiamo una definizione no? ci vorrebbe una prova di una prova di correttezza ok? cioè ci vorrebbe fare una prova di correttezza no? allora adesso visto che è il primo esempio facciamo no? ok? prova di correttezza che significa? cioè significa che la prova di correttezza significa che
 significa due cose che che diciamo che diciamo DFA accetta X se e solo se X appartiene a L ok? cioè sono due cose no? cioè se X sta in L il DFA accetta X se X non sta in L il DFA non accetta ok? cioè una volta che hai dimostrato questo
 non ci sono più dubbi ok? che è quello riconosce esattamente quel linguaggio e solo quel linguaggio no? ok? allora adesso per esempio no? in questo caso qua e in questo caso qua possiamo osservare due cose no? cioè la prima cosa che possiamo osservare osserviamolo che delta stan di Q1 virgola U
 questo è sempre uguale a Q1 per ogni U appartenente a 0,1 star ok? cioè pure Q1 è uno stato pozzo no? cioè una volta che ci finisco e non mi muovo più si vede chiaramente dalla figura no? si si la stessa cosa è che anche delta star di Q2 U è uguale a Q2 per ogni U
 appartenente a 0,1 star cioè questa è evidente no? siete d'accordo? su questo? siete tutti d'accordo? si ok cioè ovviamente adesso se uno volesse essere proprio pedante pure questa cosa la potrebbe dimostrare per induzione no? perché cioè stiamo a dimostrare una cosa che è per ogni X X U 0,1 U scusate U 0,1 star è infinito ok?
 il modo per dimostrare le cose per le cose infinite è l'induzione cioè dal punto di vista proprio no? matematico va bene? però poi ve lo risparmio questo no? perché mi sembra veramente evidente no? ok? però a questo punto cioè per esempio usiamo l'induzione per dimostrare che invece che invece è vera questa cosa cioè il DFA accetta X se e solo se X appartiene a L ok? ok?
 andiamo per l'induzione no? per l'induzione dimostriamo dimostriamo che X appartiene a L se e solo se DFA accetta X ok? allora questo diciamo
 quindi diciamo nel caso base no? nell'induzione abbiamo che cardinalità di X è uguale a 0 praticamente cioè X se X è uguale a Epsilon avremo che abbiamo che DELTA star di Q0 chiamato Q0? si Q0 Epsilon e questo è uguale a DELTA di Q Epsilon Q0 Epsilon
 di Q0 Epsilon che è uguale a Q0 e Q0 non è accettante no? giusto? cioè quindi nel caso base è vero cioè perché quando la lunghezza della stringa è 0 cioè la stringa è vuota allora lui non accetta giusto? ok? va bene? questo è consistente con il fatto che X non inizia con 1 no? in questo caso ok? poi il passo induttivo no? se volete sarebbe così
 no? cioè sia adesso N maggiore o uguale di 0 e supponiamo che sia vero no? supponiamo che appunto DELTA star diciamo di Q0 virgola W quindi cardinalità di W la prendiamo fino ad N no?
 ok? cioè supponiamo che sia che sia vero cioè vuol dire che DELTA star di Q di Q0 W che sarà uguale diciamo sarà uguale a Q1 no? però N non dovrebbe essere maggiore o stretto di 0 in questo caso inizia si va bene? va bene ma dovrebbe essere per tutti gli N però abbiamo messo
 la cartina di DELTA di Q1 il loro uguale di N quindi sì sì no? dovrebbe essere N maggiore o uguale di 0 perché deve includere pure no? nel caso base no? cardinalità di W beh io potrei prenderla anche uguale a N no? ma in questo caso non stiamo nel caso base beh no perché adesso sto dicendo che è vero per tutti gli N però no? ok? sto dicendo che è vero per tutti gli N ok? non so diciamo questo qui lo posso anche togliere no? perché tanto per N uguale a 0 già ho dimostrato
 ok? cioè posso dire anche N maggiore di 0 e allora qui posso mettere il minore uguale se volete la stessa cosa quindi fa Q1 se W inizia con 1 no? fa Q2 se W inizia con 0 e sappiamo che fa Q0 se W è uguale a Y no? cioè questa è la è la proprietà corretta no? cioè è quello che vediamo qui dal disegno praticamente
 ok? cioè se è vuota cioè questo è per dire che accetta se e solo se W inizia con 1 che cosa c'è? Epsilon stringa vuota Epsilon stringa vuota già l'abbiamo usata nella scorsa lezione ok? cioè questo è per dire per ogni W fino a lunghezza N allora questo accetta se e solo se comincia con 1 perché infatti delta stardico 0W uguale a Q1
 se inizia con 1 se invece non inizia con 1 è uguale o a Q0 o a Q2 sappiamo che è Q2 soltanto nel caso in cui inizia con 0 basta guardare il disegno nel caso invece è vuoto rimane in Q0 no? vi trovate? cioè questo è un modo per dire che accetta se e solo se inizia con 1 ok? quando la stringa c'ha lunghezza N ora devi far vedere che questa cosa implica che è vero pure se la stringa c'ha lunghezza N più 1 ok? ok?
 c'è una domanda? cioè quindi adesso prendo X tale che cardinalità di X uguale N più 1 e lo penso come lo penso X uguale ad AU con A appartenente a 0,1
 ok? e e U a questo punto c'ha lunghezza 0,1 N ok? cioè tiro fuori il primo carattere di di X ok? e quindi posso adesso andare a calcolare la delta star di Q0 X questa è la delta star di Q0 AU giusto? abbiamo scritto così e
 e questo per definizione di delta star no? è la delta della delta star di Q0 ops Q0 e A no? virgola Q no? questa è la definizione ricorsiva di delta star no? ok? vi trovate? e questa è la delta diciamo di delta Q0 virgola A
 per cosa? professore una cosa ma lì U appartiene a 0,1 N ah perché N? perché X c'ha cardinalità N più 1 e quindi ho preso fuori il primo carattere di X e U è tutto il resto giusto? siccome era N più 1 ah è il primo pezzetto U è tutto il resto però non è al contrario è fuori delta star e dentro delta normale?
 ma io non riesco a capire vuole la U e poi la N è equivalente si può è la stessa cosa si può definire in tutte e due modi è la stessa cosa è la stessa cosa puoi definire la ricorsione forse l'altra volta l'abbiamo definita al contrario però è la stessa cosa si ma è la stessa cosa no? perché adesso lei c'ha la delta star di Q0 A dove A Q0 A c'ha lunghezza N no? e adesso quindi toglie sempre un carattere tanto e un carattere di X
 hai un elemento si ah non c'è un elemento ok ah quindi infatti ho sbagliato a scrivere ah ok ah no c'era il generale si si scusi scusi delta star di delta no? e infatti non serve a niente e vediamo un attimo che ho scritto
 e
 allora vediamo un attimo scusate e quindi delta star di Q0 A come l'avevamo definito? l'avevamo definito come delta di QA si hai ragione quindi questo è corretto così no? si e
 ok va bene ok certo giusto giusto giusto no è corretto è corretto adesso quindi è corretto così come l'avevamo definito l'altra volta cioè per ricorsione la delta star di Q0 A è la delta star di delta di Q0 A che sarebbe il primo carattere e tutto il resto adesso il punto è
 che posso dire esattamente che cos'è delta di Q0 A in tutti i casi possibili no? ok cioè siccome quella A non è vuoto perché abbiamo detto che è l'N più unico no? avremo che o delta di Q0 A e e e cioè quindi ci sono solo due casi no? delta di Q0 A è uguale a Q come l'avevamo chiamato Q2 se A è uguale a 0 e delta di Q0 A è uguale a Q1 se
 A è uguale a 1 giusto? quindi quel caso non si può verificare qual è? quello che abbiamo scritto sopra cioè quell'uguaglianza l'abbiamo scritto per cui Q0 è la data di delta di Q0 A eh cioè non c'è un input che mi porta a ritenere Q0 dove? no la seconda volta ah ok no no questa è delta star no? la prima è delta star si delta star applicata sullo stato Q0 che abbiamo scritto come delta di Q0 A si però non ci possiamo riandare cioè non esiste un input
 che mi porta su Q0 a meno che A non è vuoto ok però in questo caso A non può essere vuoto perché abbiamo detto che la stringa cioè lunghezza è N più 1 e A è l'ultimo carattere ok? quindi certo però c'è ancora tutta la delta star che si può applicare a 1 adesso il punto è che se A è uguale a 0 sarà in Q2 se A è uguale a 1 sarà in Q1 e abbiamo visto per osservazione iniziale no? che se sto in Q1 ci rimango sempre se sto in Q2 ci rimango sempre no? ok quindi questo che significa? che delta star di Q0 X quindi questo significa
 che delta star di Q0 X è uguale a Q1 se e solo se X inizia con 1 se A è uguale a 1 ok? che significa? che abbiamo dimostrato adesso il passo induttivo perché avevamo detto era vero per tutte le stringhe di lunghezza N adesso è vero pure per le stringhe di lunghezza NP vi trovate? cioè questa è un semplice applicazione di quello che si chiama induzione no? ok?
 cioè formalmente ho fatto vedere che assumendo che per tutte le stringhe di lunghezza N il DFA accetta va in Q1 se e solo se la stringa comincia con 1 quando considero il carattere successivo posso utilizzare la delta star per mettere a fattore quello che fa praticamente quella del primo passetto se comincia con 0 va in Q2 ma sappiamo che una volta che ci va non esce più se comincia con 1 va con 1 una volta che ci va non esce più quindi la delta star della stringa di lunghezza NP1
 accetta se e solo se sta in la stringa comincia con 1 se A è uguale a 1 ok? che è esattamente quello che vogliamo dimostrare va bene? ci siamo? ok è un esempio va bene? era un esempio ve ne lascio altri così vi esercitate un pochetto va bene? cioè altri esercizi ok? vi lascio alcuni esercizi per esempio L uguale insieme alle stringhe X appartenenti
 a 0 1 star tale che W H di X è maggiore o uguale di 3 dove W H di X è uguale al numero di 1 in X appartenente a 0 1 star ok? quindi riconoscete tutte le stringhe
 X che hanno peso di Heming almeno 3 ok? ovvero Heming weight questo è W H il numero di 1 in X è almeno 3 ok? oppure L uguale X appartenente a 0 1 star tale che X è uguale a 0 alla N 1 con N naturale
 ok? va bene? sono tutti esercizi sono degli esempietti no? provate a farli e provate a dimostrare con l'induzione che quello che avete fatto è corretto ok? per cominciare a esercitarvi va bene? sono chiari i linguaggi? lo ha definito W H è il numero di 1 in X appartenente a 0 1 star
 0 N 1 più dietro devo leggere l'ultimo non si capisce l'ultimo è L è l'insieme degli X in 0 1 star sì? dove X è della forma 0 alla N 1 cioè N 0 seguito da 1
 per ogni possibile N naturale ok? va bene? è chiaro? è strano? finì con un solo 1 da un solo 1 per ogni N naturale N non lo sai quant'è? è chiaro? ha senso? i numeri naturali
 adesso non ci credo che non avete mai visto il simbolo dei numeri naturali va bene tutto però va bene che scrivo male però finì a un certo punto va bene? ci siamo? ci siamo? ok cominciamo a parlare invece adesso e così finalmente ci togliamo il dubbio di definire la star parliamo di operazioni
 dei linguaggi operazioni sui linguaggi ok? va bene? cioè vogliamo definire vogliamo dire capire che significa fare semplici operazioni dei linguaggi tipo unione eccetera no? cominciamo diciamo da dalle basi no? così capiamo pure la definizione della star pensiamo sigma uguale 0 1 per concretezza
 e spesso scriverò così anche diciamo non so se l'avete visto già da qualche altra parte per N in N definiamo N così parentesi quadre l'avete mai visto questo? 1 2 fino a N ok
 va bene? allora adesso il punto è questo siccome quindi linguaggi sono insieme di stringhe no? siccome i linguaggi sono insieme di stringhe posso considerare su di essi delle operazioni
 giusto? come faccio con gli insiemi no? cioè tipo unione che significa? L1 unito a L2 è l'insieme degli x appartenente a sigma star tale che x appartiene a L1 oppure x appartenente a L2 giusto? ma anche l'intersezione
 cioè L1 intersegato a L2 sarà l'insieme degli x appartenente a sigma star no? e tale che x appartiene a L1 e x appartiene a L2 ok? cioè questi possono essere pure l'or e l'end diciamo logici ovviamente sono scritti così però è chiaro?
 e c'è pure il complemento insieme degli x appartenente a sigma star tale che x non appartiene a L sono chiari? ok quindi sto definendo sto dicendo no? una cosa semplice no? dico siccome
 appunto i linguaggi sono insiemi ok? sugli insiemi posso fare le operazioni vabbè pure sui linguaggi posso fare le operazioni ok? cioè quindi se c'è due linguaggi li posso unire ok? cioè che è esattamente la stessa cosa degli insiemi cioè saranno l'insieme di tutte le stringhe su sigma adesso abbiamo detto sigma uguale a 0,1 per semplicità star di stringhe di lunghezza arbitraria tali che x appartiene a L1 oppure x appartiene a L2 intersezione
 x deve stare sia in L1 che in L2 complemento x non deve stare in L va bene? ok? ecco e queste sono le operazioni le tre operazioni in base poi operazioni l'altra operazione che posso fare è quella che si chiama la concatenazione ok? che posso concatenare
 due linguaggi come posso concatenare le stringhe giusto? e in particolare qui adesso voglio definire la concatenazione no? e poi la potenza perché la potenza altro che non è che la concatenazione con se stesso tante volte ok? la star è la potenza per ogni possibile lunghezza questo è che è esattamente quello che succede con le stringhe binarie cioè se avete studiato le stringhe binarie da qualche parte avrete visto
 che le stringhe binarie si possono concatenare no? e quindi vediamo la concatenazione concatenazione e cioè se ho se abbiamo ad esempio x uguale non lo so a1 a n ok? e y uguale
 b1 bm ok? dove n e m sono positivi no? e va bene? allora x y sarà semplicemente a1 a n b1 bm ok? che sta in sigma star ovviamente
 ok? inoltre posso sempre concatenare la parola vuota no? cioè y x uguale x y uguale x cioè non fa se concateno y succede niente e questo mi consente anche di definire la ricorsione in maniera ricorsiva no? cioè quindi posso dire sempre questo no? che la definizione di ricorsione è questa che x y è uguale a x e x concatenato con y a equivale a x y
 concatenato da dove x y appartengono a 0 1 star no? sigma star sigma star e a è un carattere singolo no? cioè questo è un modo ricorsivo di definire la concatenazione come la definisco? caso base no? x y è uguale a x ok? caso induttivo se devo concatenare x con una roba questa roba
 la penso come l'ultimo carattere a e tutto il resto questo equivale a concatenare x y con a ok? questa è la mia definizione adesso questa è ricorsiva perché vedi nella riga sotto sto diminuendo la lunghezza di quello che concateno diminuisco diminuisco diminuisco arrivo a y sto al caso base e ho finito ok? questo è un modo ricorsivo per definire la concatenazione
 bisogna dimostrare qualcosa sì ma lei è venuta la prima lezione non ci sono esami all'esame ci saranno esercizi che sono sia su teoria che su esercizi cioè sono esercizi pratici cioè fare un dfa per fare il dfa devi dimostrare che il dfa è corretto oppure ci sarà dimostrare che i linguaggi regolari sono bla bla bla e l'abbiamo fatto in classe tutto il corso è fatto in un senso che è un corso di teoria della computazione sì sì
 ok un sacco sì cioè questo è semplicemente un modo ricorsivo per definire la la concatenazione ok? cioè posso definirla in maniera ricorsiva cioè definisco il caso base il caso generale dove tolgo un carattere e riduco la lunghezza della stringa se lo ripeto ricorsivamente no? ok e adesso quindi questo è per le stringhe no? cioè concatenazione
 di stringhe adesso posso fare la stessa cosa con i linguaggi ok? concatenazione di linguaggi cioè che è semplicemente sì posso concatenare i linguaggi ovvero L1 di solito si scrive così no? concatenato L2 col pallino in mezzo questo è uguale all'insieme delle stringhe
 ok? x y tali che in qualche modo x è in L1 e y è in L2 ok? cioè che vuol dire che una stringa sta nella concatenazione di due linguaggi? vuol dire che la posso spezzare ok? in due parti x y dove x sta in L1 e y sta in L2 ok?
 e questa come vedremo sarà una domanda un po' cruciale che ci faremo penso la prossima lezione non faremo i tempi oggi però ci cominceremo a chiedere no? rispetto a tutte queste operazioni no? ma i linguaggi regolari sono chiusi rispetto a queste operazioni? cioè ovvero se L1 è regolare ovvero esiste un DFA che lo riconosce se L2 è regolare ovvero esiste un DFA che lo riconosce allora l'unione tra L1 e L2 è regolare
 ovvero esiste un DFA che lo riconosce la risposta sarà sì ok? cioè questa è una cosa anche che ti aiuta nel progetto dei DFA no? perché tu hai un linguaggio super complicato però dici ok ma questo linguaggio guarda è l'allunione di questi due linguaggi allora io so che non devo disegnare il DFA per il linguaggio super complicato perché basta che faccio il DFA per L1 poi faccio il DFA per L2 è molto più semplice e poi so che c'è un modo automatico per unirli perché c'è un teorema che mi dice esiste un DFA
 e riconosce l'unione capito? la potenza della cosa la stessa cosa per l'intersezione la stessa cosa per il complemento la stessa cosa per la concatenazione sarà vera per la concatenazione vedremo che questa cosa sembrerà difficile da fare cioè lo vedremo adesso lo faremo per l'unione e vedremo che non sarà così difficile ok? però per la concatenazione ci troveremo ci scontreremo davanti a una difficoltà cioè che è quella di dire
 faccio a capire se una stringa sta là dietro cioè nel senso che cioè è come se la dovessi scomporre in tutti i modi possibili e sperare che ci sia un modo tale che x sta in L1 e x sta in L2 ok? proprio questa difficoltà sarà quella che ci porterà a definire il non determinismo ok? vabbè sto andando avanti dicendo cose che non hanno senso ovviamente quindi la concatenazione non ha la potenza commutativa cioè L1 concatenato L2 è diverso
 certo perché infatti di fatto L1 e L2 potrebbero addirittura essere definiti su alfabeti diversi potrebbe essere cioè potrebbe essere un alfabeto per L1 un alfabeto per L2 a quel punto ovviamente non è commutativo perché i simboli di uno stanno nell'altro va bene ok quindi adesso arriviamo alla star visto che ho fatto la concatenazione approfitto per dire star cioè quindi oppure se volete prima faccio un esempio così forse proprio chiaro al 100% vediamo questo ho un esempio semplice
 qui giusto per capire se stiamo parlando la stessa lingua sigma AB L1 l'ho scritto A AB BA L2 AB B ok? una cosa a caso adesso L1
 concatenato L2 cioè adesso lo devo concatenare tutte quante no? cioè per esempio quindi A lo devo concatenare con AB otterrò A AB ok? A lo devo concatenare con B e ottenendo AB cioè come faccio la proprietà distributiva ovviamente perché sto sto distribuendo AB lo devo concatenare con AB otterrò AB AB AB con B otterrò ABB BA
 con AB otterrò B A AB giusto? e B A con B otterrò B A B va bene? mi è piaciuto? ci sta? cioè ho concatenato i due linguaggi sono tutti i modi possibili di concatenare le stringhe di un linguaggio con le stringhe dell'altro ok?
 è stato super semplice no? in cui nel linguaggio 1 ci stavano 3 stringhe nel linguaggio 2 ci stavano 2 no? però questa cosa tu la vuoi devi pensare in generale cioè L1 potrebbe essere il linguaggio infinito ok? L2 infinito e tu lo stai concatenando ok? questo è potente cioè ci stanno un sacco di stringhe se i linguaggi sono infiniti ovviamente ci ne stanno tante quando le concateno sono tutti i modi possibili di concatenare va bene?
 va bene ok? quindi la potenza quindi questa era la concatenazione la potenza è un caso speciale un caso speciale della concatenazione
 cioè sulle stringhe per le stringhe x alla n è semplicemente x concatenato a x n volte per le stringhe x appartenente a sigma star ok? cioè se x è una stringa su sigma la sua concatenazione n volte
 con se stessa si chiama x alla n la potenza ok? che lo puoi pure definire ricorsivamente pure questo cioè x alla 0 è epsilon cioè se lo ripeto 0 volte c'ho la stringa vuota se lo ripeto n più 1 volte è come fare x alla n x no? questa è la definizione ricorsiva di potenza di stringhe ok? lo stesso per i linguaggi
 lo stesso per i linguaggi cioè per i linguaggi lo posso definire ricorsivamente cioè per i linguaggi sarà uguale l alla 0 sarà il linguaggio che contiene solo la stringa vuota ok? e l alla n più 1 sarà semplicemente ln concatenato a x ok? cioè ricorsivamente
 ok? sto concatenando e sto concatenando e di fatto l n volte per se stesso ok? cioè quindi per esempio sempre bene fare un esempio cioè alla fine quello che stiamo dicendo è una cosa veramente semplice cioè questo se è a a b b a allora l al quadrato
 sarà cioè tutti i modi no? tutte le stringhe che saranno adesso di ripetere la concatenazione con se stesso no? cioè quando a lo concateno con se stesso c'ho a a no? e però posso concatenare anche a con a b no? e allora ottengo a a b e posso concatenare anche a con b a e ottengo a b a giusto? poi posso concatenare a b con se stesso
 e ottengo a b a b posso concatenare a b con b a a b con a ottengo a b a a già ho scritto a b a quindi lo riscrivo ok? a b con b a ottengo a b b a giusto? e così via no? ci sarà poi b a a b a a b b a b a ok? controllate
 che ho fatto bene va bene cioè molto semplice questo vi porta a dire finalmente la star ok? se volete la star la star sarebbe l star sarebbe l'unione su n maggiore o uguale di 0 di ln ok? cioè sarebbe diciamo
 epsilon unito per l1 unito ops unito l alla 1 unito l alla 2 giusto? la star ok? la star per i linguaggi la star è semplicemente questa infatti diciamo ancora una volta se volete un esempio esempio
 con l se l è uguale ad a b scrivo qua sopra se l è uguale ad a b l star ditemi l star che ci sta dentro? epsilon a b eh? come come? a a poi? come come? a a
 B? B, B? B, B. Poi? Ah, ok. Ok? Ok? Va bene? Ok. Scusi, ma fino a quando dobbiamo... cioè l'unione è fino a dove? È per un L architrave. Quindi fino a LRN?
 Eh no, perché N è un indice, no? Quindi se lo scrivo vuol dire che N va in fila. L'unione non si ferma mai. È un'unione in fila. È in fila. Non mi fermo mai. Perché N è un indice, hai capito? Per quello ci sono i puntini. Non ti puoi fermare mai. Vuol dire che per un qualche N, no? Vuol dire che se X sta là dentro, per un qualche N sta dentro LRN.
 Per un qualche N. Ma può essere di una qualsiasi indice. Prego. Certo. Certo. Qua, L quadro? Ci sono domande? Sì.
 Sì, la potenza è semplicemente la concatenazione un certo numero di volte fissato, no? Cioè, potenza al quadrato significa che la concatena due pezzi, due stringhe, una nel linguaggio e una con se stesso, no? Quindi, come nell'esempio. Vedo l'esempio. L quadro. Significa...
 È concatenazione di A con AB. Con altri elementi. Con altri elementi di se stesso. È per quello che è potenza. Sta concatenando con se stesso, infatti. La potenza significa tutti i possibili... La potenza è per un numero fissato. La star significa l'unione di tutte le possibili potenze. Fino al fine. Ci siamo? Domande?
 Sì, forse l'ho già detto. Mi sono un attimo distratto. Quindi, la L star sarebbe... Cioè, definito un linguaggio, lo fa con se stesso infinite volte? L'unione. È considerata l'unione. Sì.
 Dove è L? Scusi. AB? Ah, scusi. Sì. Sì. L è... Ok, L è... No, sono due separati uniti, però. Perché l'alfabeto sigma sono tutti i caratteristici.
 Cioè, A e B è l'alfabeto. Ok? L sono le stringhe che stanno dentro quel linguaggio. In questo caso è AB... Cioè, non è A, B. È proprio AB attaccato. Cioè... Cioè, quindi, per esempio, se avessi un DFA che riconosce questo linguaggio, quello, quando io do AB, va in uno stato accettante. Se io do BB, invece no. Ok? Ok. Quello che vogliamo studiare adesso.
 Vogliamo studiare... Studiare le proprietà di chiusura, si chiamano, come dicevo prima, chiusura dei linguaggi regolari. Va bene? Cioè, ovvero... Ovvero...
 Ovvero... Se L1, L2 appartengono al REG, posso dire che, ad esempio, L1 unione L2 appartiene al REG? E L1 intersegato L2? Ok? Oppure L negato?
 L1 negato? L1 star? Ok? Questo voglio... Voglio capire. Cioè, voglio capire se la classe dei linguaggi regolari è chiusa rispetto a queste operazioni. Chiusa significa che l'unione di due linguaggi regolari è regolare, l'intersezione di due linguaggi regolari è regolare, il complemento di un linguaggio regolare è regolare, eccetera, eccetera, eccetera, eccetera. Ok? Perché questo è utile? Dicevi una cosa così che ci stava a fare un problema inutile? No, come dicevo, è utile perché, appunto,
 mi dà un criterio anche di progettazione di DFA, no? Perché, cioè, se un DFA è... Devo disegnare un DFA per un linguaggio molto complesso, e adesso questo lo ha ridotto a disegnare... Se capisco che questo linguaggio in realtà è l'unione di due linguaggi, mi posso concentrare semplicemente su disegnare il linguaggio per L1 più semplice, per L2 più semplice, e poi ho una formula magica che mi dice, ok, una volta che c'hai quelli, li puoi mettere insieme così. E funziona sempre.
 Va bene? Ok. Va bene. E cominciamo, ma continueremo la prossima volta, penso. Però cominciamo, almeno diciamo, enunciare il teorema, ok? Enunciamo il teorema per un po' di intuizione su come... Prego. Certo.
 Cioè, quindi, il primo teorema facile da dimostrare, questo è facile, è questo che reg è chiusa nell'unione. In realtà, ma anche intersezione è complemento, diciamo, è molto facile da dimostrare. Quello che è più difficile da dimostrare è la concatenazione.
 Quindi, reg è chiusa per unione, va bene? Intuizione. E poi magari lo dimostriamo la prossima volta, va bene? Quindi, intuizione, cioè, voglio dire, voglio dire, L1 e L2 appartengono al reg. Ovvero, esistono M1,
 M2 di FA, no? Tali che L di M1 è uguale a L1 e L di M2 è proprio uguale a L2. Giusto? Per definizione, per definizione di linguaggio irregolare, se L1 e L2 sono regolari, allora esistono degli FA M1 e M2 tali che M1 riconosce proprio il linguaggio L1 e M2 riconosce proprio il linguaggio L2. Devo definire
 M, no? Tale che L di M è uguale a L1 unione L2. Ok? L1 unione L2 che significa che X sta o sta in L1 o sta in L2. Ok? Ha senso? Problema.
 Non posso prima vedere se, non posso prima vedere se, ad esempio, dovrei scrivere forse, scusate, prima di scrivere questo, vedete, dato un X, vedete, dato un X,
 dato X candidato. Ok? Cioè, devo decidere se X sta nell'unione o no. Non posso prima provare a vedere se M1 di X accetta. Perché? Perché questo?
 Cioè, uno potrebbe dire, ok, ho due DFA, uno per X, uno per M1 e uno per L2, no? Allora, ok, prima vedo se accetta M1. Qual è il problema? Cioè, posso lanciare, secondo voi, X su M1? Perché? Perché se sono un M1 non accetterà mai X.
 No, questo non è vero. Ci possono essere delle parti di L2? No, aspetta, aspetta. Non è così, no. X, se X sta nell'unione, vuol dire che X o sta in L1 o sta in L2. O sta in tutte e due. Ok. Quindi significa che può essere M1 accetta X. E lei che dice? Perché ci sono delle parti di L2 e perciò non riconosce l'automa M1 questa sequenza?
 M1, allora, perché se X fosse in L2, dice lei, M1 non accetterebbe. Non accetterebbe. E poi che succede? Questo è il problema. Perché? Questo è il problema. Cioè, perché poi non posso lanciare X su M1? Su M2, scusate. No, dico, visto che per questa ragione non può lanciare su M1, credo che lo stesso problema, visto che su X possono essere certe le parti di L1, non può lanciarlo su M2.
 Significa? No, però, cioè, diciamo, io, cioè, X o sta in L1 o sta in L2. Quindi io posso sempre lanciare M1 su X e M2 su X. Quello che posso fare. Cioè, o accetta o rifiuta. Però qual è il problema? Cioè, io, la prima idea che forse mi viene in mente, dico, vabbè, ok, sai che faccio? Prendo X, lo lancio su M1. Se accetta, ho finito. Se rifiuta, mo devo lanciare su M2. No. Perché non si può fare la cosa? Potrebbero non avere lo stesso ortopedo. Questo non è importante.
 Supponiamo che ce l'abbiano, non cambia niente. Dovrei provare tutte le possibili, no? No, però non devo provare tutte le possibili, scusi. Io devo, io c'è X e è fissato. Devo decidere se sta in L1 o se sta in L2. Se non sta in nessuno dei due, devo rifiutare. Se sta in uno dei due, posso accettare subito. Ok? Allora ho detto, io sto dicendo, è facile. Ok? Faccio X, prendo X, lo lancio su M1. Se accetta, accetto. Se invece rifiuta, lancio X su M2. Lancio M2 su X.
 Se accetta, accetto. Se rifiuta, lancio X su M2. Perché non va bene?
 Vabbè, ma se funziona... No, se funziona, certo, se funziona. Però qual è il punto? Io devo fare un solo automa. Un solo automa, che significa? Nel senso, devo avere un automa e un'altra. Un automa, eh. E perché l'automa non la può fare la cosa che ho detto io? In che senso? Cioè, perché quello che ho detto io non si può implementare con un automa? Ha detto bene, cioè sta dicendo una cosa giusta, secondo me. Però, voglio vedere se la sta dicendo corretta. Cioè, lei dice, ci deve essere un solo automa. Sì.
 Qual è il problema di fare un automa che fa la cosa che ho detto io? Perché non se lo fa? Perché nella promozione ha detto che gli automi fanno... No, vabbè, ma io dico, prima faccio quello e poi faccio quello. Che non sarà più un definito. Eh? Non è detto che sarà un definito. Che significa un definito? Che potrebbe avere per lo stesso... Potrebbe avere due stati diversi per lo stesso valore di... Se uniamo M1 e M2. Ma questo dipende, diciamo, come...
 Cioè, io gli stati li posso sempre separare, no? Cioè, non... Non mi sembra questo... Cioè, è un problema proprio fondamentale. Cioè, è... Se faccio la prova su M1 non c'è più la stringa. Hai capito? Cioè, l'automa... Quello legge l'input da sinistra a destra. Ha letto tutto. Cioè, lei ricomincia dall'inizio. Sta a fare il codice Python. Non se può fare questa cosa. Non se può. L'automa non può fare questa cosa. Prima legge, poi dopo vede, poi cambia, no? A macchina di Turing, sì.
 Non si può passare la stessa stringa in input contemporaneamente a due atomi diversi. Esatto. E devo accettare se uno dei due accetta. Quindi lo devo fare in parallelo. Ok? Cioè, quindi l'idea della prova è proprio questa. Idea. M deve eseguire M1, M2 in parallelo. Ok? Non scrivo parallelo, sennò vi stranite. In parallelo. E accettare.
 Se, solo se, uno dei due accetta. Ok? Cioè, tutto quello che è rimasto da fare adesso è formalizzare come fa un automa a fare questa cosa. Cioè, quindi, intuitivamente, quest'automa deve tenere traccia di... Per ogni carattere che legge, deve andare in uno stato che tiene traccia di quale stato sta M1 e quale stato sta M2.
 I stati di M1 e M2. Vi è chiaro? A quel punto, computa, computa, computa. E se uno dei due finisce in uno stato accettante, deve accettare. Ok? Lo deve fare in parallelo. Ok? Però se può fare. Va bene. Come si fa? Lo vediamo la prossima volta. Ok? Quando dimostriamo questo teorema. Per oggi ci vediamo. Va bene?
 Grazie.
