# Lezione 05
Nella scorsa lezione è stato introdotto il teorema che mette in relazione espressioni regolari e automi: essi descrivono esattamente la stessa classe di linguaggi.
###### Teorema - Linguaggi ed Espressioni Regolari
Un linguaggio è regolare se e solo se esiste una espressione regolare che lo descrive. In particolare $$REG\equiv L(re).$$
In altre parole, la classe dei linguaggi regolari e quella dei linguaggi definiti da espressioni regolari sono equivalenti.
**Dimostrazione:**
- **$L(re)\subseteq REG:$** Ogni linguaggio definibile tramite un'espressione regolare è un linguaggio regolare

Data un'espressione regolare $r$, bisogna trovare il modo di costruire un NFA/DFA $N_{r}$ che riconosca il linguaggio da essa descritto, ovvero $L(N_{r})=L(r)$.

Per farlo, ci aiuta la definizione ricorsiva che abbiamo delle espressioni regolari:
**Caso base**:
- $r=a,a\in\Sigma$:
![[lez05_01.drawio.svg|700x348]]
$$\begin{aligned}N_{r}=(\{q_{1},q_{2}\},\Sigma,\delta,q_{1},\{q_{2} \})\\ \delta(q_{1},a) =q_{2} \\ \delta(q,b)=\emptyset,\quad\text{se } q\neq q_{1}\lor b\neq a \end{aligned}$$
- $r=\mathcal{E}$:
![[lez05_02.drawio.svg|700x190]]
$$\begin{aligned}N_{r}=(\{q_{1}\},\Sigma,\delta,q_{1},\{q_{1} \})\\\delta(q_{1},b)=\emptyset,\quad\forall b\in\Sigma \end{aligned}$$
- $r=\emptyset$
![[lez05_03.drawio.svg|700x159]]
$$\begin{aligned}N_{r}=(\{q_{1}\},\Sigma,\delta,q_{1},\emptyset)\\ \delta(q_{1},b)=\emptyset,\quad \forall  b\in\Sigma \end{aligned}$$
**Caso Induttivo:**
- $r=R_{1}\cup R_{2}$
Se
$$\begin{gathered}\exists M_{1},M_{2}\text{ tali che }L(M_{1})=L(R_{1})\text{ e }L(M_{2})=L(R_{2})\end{gathered}$$
allora:
$$\begin{gathered}\exists M\text{ tale che }L(M)=L(R_{1})\cup L(R_{2}) \end{gathered}$$
Per ipotesi induttiva, assumiamo che i due linguaggi $L(R_{1})$ e $L(R_{2})$ definiti dalle espressioni regolari $R_{1}$ e $R_{2}$ siano linguaggi regolari (ovvero esistono due DFA che li riconoscono). Bisogna dimostrare che anche la loro unione è un linguaggio regolare (questo è vero per chiusura di $REG$).
- $r=R_{1}\circ R_{2}$
La dimostrazione è analoga al caso dell'unione
- $r=(R_{1})^{*}$
La dimostrazione è analoga ai primi due casi.

Questo è un modo per definire un NFA a partire dall'espressione regolare. 

Esercizio: $(ab\cup a)^{*}$. Qual è il suo NFA corrispondente?
![[lez05_04.drawio.svg|700x1344]]

- $REG\subseteq L(re)$ Se un linguaggio è regolare allora esiste una espressione regolare che lo descrive.

Partiamo da un linguaggio regolare $L.$ Per definizione di $REG$, esiste un DFA $M$ che lo accetta. Il passo successivo è quello di convertire questo DFA in un'espressione regolare.

Per facilitare la conversione in espressione regolare introduciamo il **NFA Generalizzato (GNFA)**.

Il procedimento della dimostrazione consiste in:
1. Convertire il DFA in un GNFA
2. Convertire un GNFA in **forma canonica** (o **forma normale**), un suo caso semplice.
3. Convertire un GNFA in forma canonica in un'espressione regolare.

Un GNFA è un NFA dove:
- le etichette degli archi sono espressioni regolari anziché simboli.
- gli input possono essere letti come blocchi di caratteri invece che necessariamente leggere un carattere alla volta.

Un GNFA **accetta** una parola $w$ se è contenuta nel linguaggio denotato dall'espressione regolare che etichetta un cammino dallo stato iniziale a uno finale.
![[lez05_05.drawio.svg|700x269]]
In questo esempio, il linguaggio accettato è l'insieme delle parole formate da zero o più $a$ e che terminano per $ba$, oppure da quelle che iniziano con $bba$.

I GNFA possono essere trasformati in una loro forma speciale, la **forma canonica**, che rispetta le seguenti condizioni:
1. Lo stato iniziale ha archi di transizione che vanno in tutti gli altri stati, ma **non** ha archi entranti.
2. C'è **un solo** stato di accettazione, **diverso** dallo stato iniziale, che ha archi entranti provenienti da tutti gli stati, ma non ha archi uscenti.
3. Eccetto gli stati iniziale e finale c'è un arco per ogni coppia di stati.

La forma canonica è considerata *senza perdita di generalità*, perché è sempre possibile passare da un NFA a un GNFA, attraverso il seguente procedimento:
- Aggiungere un nuovo stato iniziale che è collegato al vecchio tramite un $\mathcal{E}-$arco uscente
- Aggiungere un nuovo stato finale che è collegato al vecchio tramite un $\mathcal{E}$ arco entrante.
- Se ci sono più frecce tra una coppia di stati, si rimpiazzano con una sola freccia, la cui etichetta conterrà l'unione delle etichette delle frecce rimosse.
- Si aggiungono degli archi con etichetta $\emptyset$ tra gli stati che non hanno frecce (non cambierà il linguaggio riconosciuto perché una transizione $\emptyset$ non verrà mai usata)

Bisogna infine capire come creare un GNFA canonico in un'espressione regolare.

**Idea:**
Sia $k$ la cardinalità del GNFA $G$. Per la definizione di GNFA, $k\ge 2.$ Se $k$ è maggiore di $2$, costruiremo un GNFA equivalente con $k-1$ stati, e così via fino ad arrivare ai $2$ soli stati.

Se $k=2$ il GNFA ha una singola freccia che va dallo stato iniziale allo stato di accettazione.

Quando $k>2$ viene selezionato uno stato diverso da quello iniziale e finale (che chiameremo $q_{rip}$) che viene rimosso (o "strappato", ripped). Dopodiché riparo il GNFA con nuovi archi, che avranno nuove etichette composte da espressioni regolari più complesse (di solito l'unione d. In tal modo il GNFA sarà in grado di accettare lo stesso linguaggio, ma con uno stato in meno.

**Procedimento:**
Formalmente definiamo il GNFA $G$ come segue $$G=Q,\Sigma,\delta,q_{start},q_{acc}$$
dove la $\delta$ è definita come
$$\delta:Q\setminus \{q_{acc} \}\times Q\setminus \{q_{start} \}\longrightarrow\underset{\substack{\text{Insieme delle} \\ \text{espressioni regolari} \\ \text{su }\Sigma}}{\underbrace{\mathcal{R}=re(\Sigma)}}$$
Quindi se $\delta(q_{i},q_{j})=R$, la freccia che va da $q_{i}$ a $q_{j}$. Il dominio corrisponde a quello descritto sopra, perché una freccia connette uno stato ad ogni altro stato (tranne per le eccezioni di $q_{start}$ e $q_{acc}$

Siamo pronti per convertire $G$ in espressione regolare.
Definisco $Convert(G),$ una procedura che prende un GNFA e ne ritorna la sua espressione regolare. Questa procedura è ricorsiva:
 - Sia $k$ La cardinalità di stati in $G$
 - Se $k=2,G$ avrà solo 2 stati: $q_{start},q_{acc}$ e un solo arco con etichetta $R\in\mathcal{R}$ con output $R.$
 - Se $k>r,$ scelgo $q_{rip}\in Q,\text{ con }q_{rip}\neq q_{start},q_{acc}$ e definisco $$G'=(Q',\mathcal{E},\delta',q_{start},q_{acc})$$
dove $Q'=Q\setminus\{q_{rip} \}$. 

Per quanto riguarda la $\delta$, definiamo $\delta'$ con dominio:
$$\delta':Q'\setminus\{q_{acc} \}\times Q'\setminus \{q_{start} \}\longrightarrow \mathcal{R}$$
Notiamo che:
![[lez05_06.drawio.svg|700x391]]
$$\delta'(q_{i},q_{i})=(R_{1})(R_{2})^{*}(R_{3})\cup R_{4}\quad \begin{cases}\forall q_{i}\in Q'\setminus \{q_{acc} \} \\ \forall q_{j}\in Q'\setminus\{q_{start} \} \end{cases}$$
dove:
$$\begin{gathered}R_{1}=\delta(q_{i},q_{rip}) \\ R_{2} = \delta(q_{rip},q_{rip})\\ R_{3}=\delta(q_{rip},q_{j})\\ R_{4}=\delta(q_{i},q_{j}) \end{gathered}$$
Dopodiché rilancio $Convert(G)$ se necessario.

Per concludere, devo dimostrare che $Convert(G)$ è equivalente a $G$, ovvero che $L(G)=L(G')$.
**Caso base:**
Per $k=2$ è sicuramente vero (perché in entrambi ci sono solo due stati, $q_{start}$ e $q_{acc}$).
**Caso induttivo:**
Assumiamo che la proprietà sia vera per $k-1$ stati e uso questa assunzione per verificare che lo sia per $k$ stati.

Supponiamo che $G$ accetti un input $w$. Ciò implica l'esistenza di un ramo di computazione compiuto da $G$ del tipo: $$q_{start},q_{1},q_{2},q_{3}...,q_{acc}$$
Se la sequenza non contiene $q_{rip},$ allora $L(G)=L(G')$ perché le nuove espressioni regolari contengono le vecchie come unione. Se c'è  avrò una situazione del tipo $q_{1}q_{rip}q_{2}$ e quindi una nuova sequenza di stati per $G'.$ Ma gli stati adiacenti a $q_{rip}$ ($q_{1}$ e $q_{2}$) in $G'$ hanno un arco che tiene conto di tutti i modi per andare da $q_{1}$ a $q_{2}$ direttamente o passando per $q_{rip}.$

Quindi ancora $L(G)=L(G').\quad\blacksquare$

<span style="background:#affad1">Esercizio</span>: trovare l'espressione regolare associata a questo NFA:
![[lez05_07.drawio.svg|700x330]]
<font color="#000000"><span style="background:#b1ffff">Svolgiamolo!</span></font>
Per iniziare, trasformiamo l'NFA in un GNFA in forma canonica:
![[lez05_08.drawio.svg|700x505]]
Dopodiché lanciamo Convert(G). Inizialmente rimuoviamo lo stato $b$:
![[lez05_09.drawio.svg|700x516]]
e infine lo stato $c$:
![[lez05_10.drawio.svg|700x166]]
L'etichetta dell'arco che collega gli stati $a$ e $d$ è corrisponde proprio all'espressione regolare associata al NFA.
### Pumping Lemma
Tutti i linguaggi sono regolari? La risposta è no.

Ad esempio:
$$L=\{0^{n}1^{n}:n\ge0\}$$
non è un linguaggio regolare, perché l'automa non è capace di contare lo stesso numero di zeri e di uni.

Nella prossima lezione vedremo che il pumping lemma è un modo per dimostrare che un linguaggio non è regolare.