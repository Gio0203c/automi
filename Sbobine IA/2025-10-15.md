# Lezione 06
potresti farlo con questo?  è una serie di cose che qualcuno ha ora ok, stiamo facendo qualche esercizio continuiamo a fare qualche esercizio chiudiamo questa parte sui linguaggi regolari continuiamo a fare qualche esercizio
progettare automa progettare automa per il linguaggio L delle stringhe W in 0,1 star tale che W termina con 0,0 ok?
quando dice progettare un automa diciamo, in questo caso è qualsiasi tipo di automa quindi può essere anche non deterministico ad esempio un semplice automa che fa questa cosa è questo
giusto? cioè l'idea è che che stai in una stata iniziale e ci rimani fino a che leggi qualsiasi cosa ma in ogni momento questo è non deterministico perché quando stai in 0 c'è un ramo di computazione che rimane in Q0 quando stai in Q0 e leggi 0 c'è un ramo che rimane in Q0
e c'è un ramo che prova a vedere se quelli sono gli ultimi due 0 ok? cioè quindi tutta la parte che viene a destra di Q0 prova a vedere se la stringa termina con due 0 ok? infatti legge due 0 e va in Q2 e accetta se ha finito di leggere cioè ogni volta è chiaro l'intenzione? ha senso? quindi come lo dimostri? poi devi dimostrare che è corretto cioè vabbè diciamo dovresti descrivere
gli stati come è fatta la delta ma tutte queste cose qua però diciamo non me lo risparmio ok? vabbè però diciamo la figura in questo caso basta va bene non è un caso così semplice è chiaro che la delta è tutto quello che riguarda la figura quello che non c'è nella figura è implicito come abbiamo sempre fatto e correttezza ok? cioè devo far vedere che
tiene a L se e solo se è M chiamiamolo M ok? questo sempre dovete fare ok? quando fate un esercizio dove costruite un'automa dovete sempre dimostrare che il vostro automa è corretto ok? corretto significa che le stringhe che stanno nel linguaggio sono accettate e solo le stringhe che stanno nel linguaggio sono accettate ok? quindi è sempre un se e solo se ok?
va beh diciamo per esempio vediamo una direzione è questa cioè se se W appartiene a L allora M accetta W per esempio questo lo puoi vedere per l'induzione cioè ovvero il caso basico
questo caso sarebbe diciamo esatto il caso basico sarebbe W W 0 0 è il caso basico ok? e chiaramente e chiaramente chiaramente M accetta 0 0 cioè quindi questo è vero
sicuramente per il caso basico cioè perché 0 0 lo accetta si vede dalla figura ok? e passo induttivo no? passo induttivo beh avremo W che sarà W primo 0 0 no? dove W primo è W primo appartenente a 0 1 ok?
ma anche in questo caso anche in questo caso è chiaro? è chiaro? che M accetta W un'altra volta diciamo per ispezione diciamo se guardiamo la figura cioè qualsiasi cosa ci sta prima M ci darà un ramo di computazione che sta in W 0 ok? e gli ultimi due 0 porteranno voi ad accettare no? ok?
quindi questo è un caso semplice dall'altra parte diciamo ovvero se M accetta W allora W appartenente a N ok? ma che significa che M accetta W? se M accetta W vuol dire che c'è un ramo di computazione che l'ha portato in Q2 ok? ma questo significa che gli ultimi due caratteri di W sono 0 ok?
cioè qua per l'ispezione se M accetta W esiste un ramo di computazione che termina in Q2 termina in Q2 ovvero
W termina con W ok? e W appartiene ok? non bene? domande? ok?
perché non accetta perché non accetta e come va a accettare 0 e 0? 0 e 0 e qui 0 e qui 0 e qui 0
e qui 0 e qui 0 e qui 0 e qui 0 e qui 2 il ramo di computazione che ha letto 0 e rimane in Q0 qual è la strica 0 1 0? quando leggi il primo 0 ok? cioè un ramo come ha detto giustamente un ramo sta in Q0 e un ramo sta in Q1 ok?
il primo ramo che ha letto Q1 morirà le 0 come legge 1 1 non c'è scritto niente e quindi quel ramo muore il secondo ramo rimarrà ancora in Q0 e poi però andrà in Q1 non ha terminato di leggere Gesà? si? nel caso di questo qua ovviamente è semplice quindi l'ispezione facciamo prima ma se è un po' più complicato forse per la dimostrazione tra via delta tra via delta stanno
non saranno molto complicati invece è il contrario se M accetta W c'è la dimostrazione solo se perché se si fa con delta solitamente anche per ispezione si riesce a quindi cioè non vedremo non ci saranno tomi giganteschi dove sarà
va bene? ok e vogliamo un altro esercizio e consideriamo R
ok? consideriamo questa ispezione regolare ok? ispezione regolare 1 star ok? poi 0 0 1 più ok? non star ma più
e poi tutto star più che significa come star ma c'è almeno un occorrente ok? certamente perché star oppure 0 occorrente ok? la differenza tra più e star è solo un ok? progettare automa
per L di R L di R e con 3 stati ok? quindi questo qui diciamo richiede anche che il numero di stati si aprirà ok? va bene? e ok apriamo come posso fare? cioè
diciamo innanzitutto ok cioè la stringa ok la prima cosa che osservo è che la stringa vuota sta dentro il linguaggio ok? perché c'è star concatenato con una cosa sta e quindi la stringa vuota sicuramente sta nel linguaggio ok? quindi lo stato iniziale deve essere accettante giusto? beh perché c'è 1 star no? concatenato di 0 0 1 più star ok?
ma in 1 star c'è la stringa vuota giusto? in 0 0 1 più star pure c'è la stringa vuota e quindi la stringa vuota sta in L di L ok? quindi Q0 deve essere ok? poi ok poi ovviamente diciamo anche cioè
se la seconda parte fosse vuota no? cioè 0 0 1 più star fosse vuota cioè questa deve riconoscere un qualsiasi numero di 1 ok? cioè fino a che leggo 1 rimando qua ok? così accetto diciamo 1 1 1 1 1 1 1 tutti 1 il resto accetto tutti 1 ok? però adesso poi devo anche accettare tutte le stringhe che sono fatte da diciamo 0 più 1 e quindi a partire da funzione
mi troverò sempre in Q0 fino a che leggo 0 più 1 mi troverò sempre in Q0 devo accettare stringhe che sono della forma 0 0 1 più star ok? si? quindi ci avrò ovviamente adesso la sottoparte dell'automa che deve riconoscere 0 0 1 simile a come abbiamo fatto sopra per i due zeri ma adesso 0 0 1 solo che c'è questa parte che deve essere almeno 1 ok? quindi avrò diciamo Q1 e Q2 che mi riconosce la sottoparte
cioè questo è il ramo di computazione che ogni volta parte mi prova a riconoscere la stringa 0 0 ok? e 1 no? ci sarebbe 1 no? cioè adesso volendo potrei mettere infatti un altro un altro stato però siccome mi dice che lo devo fare solo con tre stati ho già finito gli stati quindi adesso devo usare gli stati che già ci sono ma per fortuna c'è questo stato che Q0 che ha quella freccia sull'1 quindi c'è l'idea che posso fare questo ok?
perché in questo modo la parte destra dell'automa mi riconosce proprio 0 0 1 e almeno 1 che c'è quella freccia cioè non può essere non può terminare solo con 0 0 ok? cioè se termina con 0 0 infatti è più da sempre tutte le stringhe che terminano con 0 0 vengono più da sempre quindi quella parte lì diciamo l'unione di quella freccia Q2 che va a Q0
è sicura che c'è almeno un 1 ok? e poi un altro numero alquilato di 1 cosa succede se ha 3 0? se ha 3 0 è rifiutato Q2 è uguale a 0 0 0 lui sta in Q0 poi va in Q1 quando ha letto il primo 0 sta in Q1 questo lo porta in Q1 questo lo porta in Q2
in Q2 se legge 0 è rifiutato non c'è l'acqua come stai? come stai? va bene? è chiaro? sì? va bene, è abbastanza intuitivo ok, lavorate insieme lo dovete fare un'altra volta per ispezione
e allora se non ci fosse sale più questa è la domanda se non ci fosse sale più e se non ci fosse sale più
si, non avrebbe potuto di usare quello sale perché è chiaro la domanda a tutti quanti cioè se non ci fosse sale più
se non c'era il più uno più ok allora questa domanda andava bene cioè sicuramente perché appunto se non c'era il più lei non può accettare 0, 0 per esempio 0, 0 1, 1 non c'è stata dentro quindi quella domanda questa domanda non andava bene non penso che fosse possibile il sale più possibile
farlo con il testato potrebbero servire quattro stelle io potrebbero perché non ci ho pensato però però sicuramente questa domanda qui non andava bene cioè questo è sicuro e vabbè in generale non studieremo molto questo problema di minimizzare il numero di stali negli auto però questo è un problema che è abbastanza da studiarsi
non va bene perché vede ad esempio se non c'era l'uno più ok se non c'era l'uno più infatti diciamo infatti la stringa 0, 0 1, 1 non apparteneva al linguaggio l, d, r, d si trova cioè se
non ci fosse stato il più sopra l'uno ok la stringa 0, 0 1, 1 ok non sta dentro il linguaggio si trova su questo perché non c'è il più cioè lei fa 0, 0 1 sta ok vuol dire che ci sono tutte le rivendizioni della stringa 0, 0, 1 ok non 0, 0 qui non ci può mai essere 0, 0, 1, 1 sì e questa però questa automa
0, 0, 1, 1 giusto ok dove arrivi c'è un piccolo 0, 0, 1 ok 0, 0, 1, 1 non ci stava dentro ok va bene
vediamo un'altra cosa poi questo diciamo ok allora data w w uguale w1 wn su sisma sia w rovesciato a n a n-1
ok la parola è rovesciata ok sia l regolare mostrare che l r è
lr sarebbe l'insieme delle parole rovesciate è chiaro no? ok w è l'insieme delle stringhe rovesciate ok cioè tutte le parole rovesciate per ogni possibile stringa in l ci mettiamo tutte le sue
parole rovesciate w sarebbe a1 a n maggiore perchè sotto poi si è sopra scritto w1 wn sotto a n certo ok cioè l'insieme delle parole rovesciate come pensate di fare questa cosa?
quale è l'idea ok? poi magari la provate a formalizzare più precisamente a casa però quale è l'idea? quale può essere un'idea? ok devo invertire tutti gli archi e poi gli stati e il stato iniziale e il stato finale
e questo è meglio questo però è senza perdere generalità se c'è un se c'è un automa con più stati finali lo può sempre trasformare in uno che ha un solo stato finale come abbiamo già visto no? ah questo voleva fare voleva fare questo questo è lo stato iniziale ok si
ok e lo stato finale del nuovo automa ok comunque l'idea è questa no? scambiare stato iniziale e finale
e invertire gli archi ok ha senso?
eh? per casa provare la formalità la formalità ok? come è fatto l'automa qual è la transizione di transizione ok? però è chiaro che l'idea è questa va bene? domande?
praticamente di lunghezza infinita si L è un linguaggio che potrebbe avere stringe di lunghezza infinita e è possibile fare una sensazione modica cioè questo è sempre vero che gli automi riconoscono linguaggi di lunghezza infinita però se sono invertiti a quale cioè quale simbolo si si si ha un senso si si ha un senso di doppio
di L certo l'alfabeto è lo stesso L e LR sono definiti sullo stesso alfabeto perché LR ha tutte le parole rovesciate quindi l'alfabeto è lo stesso ovviamente se lei inverte l'arco quello che sta scritto sopra l'arco rimane lo stesso così non riesce a immaginare cosa? come realità che non riesce a immaginare come realità all'esempio
se l'automata fosse stato questo non lo so qual è il problema? qual è il problema?
deve scrivere per ogni automa certo dice che lei non se lo riusciva a immaginare allora io ho disegnato così così se lo immagina però quando lo descrive mi deve dire chi è Q0? chi è Q? chi è l'alfabeto? chi è la delta? eccetera eccetera vabbè ma questo è facile perché la delta cioè dovrò scambiare gli stati però nella delta scambierò gli stati cioè è facile fare la descrizione formale di questa roba sì?
vabbè ok vediamo un altro un altro vediamo questo che è di nuovo costruire costruire DFA per
L uguale W W in 0 1 star tale che W non appartiene a diciamo 0 1 più
ok? cioè deve essere l'istrime di tutte le stringhe W binarie di qualsiasi lunghezza che non sono della forma ok? non sono della forma 0 1 più star cioè tutto il resto chiaro l'esercizio? sì? chiaro cioè ok qual è l'idea qua? usare la chiusura per il complimento sì?
giusto? cioè se devo fare cioè sembra complicato quando lo leggi ma come faccio a fare questa cosa? uso la chiusura cioè faccio un automa che riconosce proprio 0 1 più star questo è facile e poi sappiamo che i linguaggi regolari sono chiusi per complimento quindi dato un automa che riconosce L posso sempre fare un automa che riconosce L negato sarebbe la negazione di quello che faccio però è molto più facile sì?
uso la chiusura la chiusura però adesso quando usi la chiusura devi stare attento a come fai l'automa ok? perché uso la chiusura per il complemento ok? ovvero prima faccio automa faccio DFA
per 0 1 più star ok? questo sarà fatto così no? deve accettare le stringhe del tipo deve accettare la stringa vuota sempre no? perché la stringa vuota sta nel linguaggio e poi deve riconoscere le ripetizioni di 0 quindi se è 0 quindi deve iniziare con 0 se non è vuota deve iniziare con 0 ok?
poi quindi va in Q1 poi ci deve essere un 1 0 1 ci deve essere un 1 e giusto? 1 1 quindi per esempio 0 1 ovviamente 0 1 sta là dentro quindi questo già ci suggerisce
che questo per come lo stiamo disegnando deve essere accettante no? perché 0 1 deve stare là dentro giusto? però anche 0 1 1 anche 0 1 1 1 1 qualsiasi numero di 1.0 deve stare là dentro giusto? quindi qua ci devo mettere questo sì? e fino adesso riconosco tutte le stringhe del tipo 0 1 0 1 1 no? ok?
a questo punto è esatto questo funziona perché più è un 1 arbitraio di 1 quindi cioè in questo modo ogni volta che ho letto una cosa del tipo 0 1 più quello 0 mi fa rileggere un'altra volta quella parte 0 1 più
ok? quindi questo ci ho messo tutte le stringhe accettate ok? adesso è chiaro per esempio va bene? sì sì non manca un arco nello stato iniziale nello stato iniziale? nello stato iniziale più 0 non manca l'arco 1 non manca l'arco 1 questa è un'altra domanda lei perché vuole mettere l'arco 1?
no c'è l'1 diciamo non è l'arco 1 che non ce l'abbiamo messo va bene perché le stringhe che cominciano con 1 sono tutte originali giusto? si si trova? sì per quello non ce l'ho messo ok si trova su questo? sì ok però in realtà sarà importante che ci sia quest'arco
cioè perché è importante che ci sia non per questo per questo linguaggio ma perché adesso devo usare la chiusura per il complemento ok come si fa la chiusura per il complemento?
perché l'1 è non è vero che è l'1 cioè vabbè perché deve essere l'1 cioè in generale in generale se lei ha un'automa ok un DFA ok e deve riconoscere il complemento e che non so eh eh giusto? ok vi trovate su questo? cioè come si fa?
la chiusura per il complemento è tale che gli stati che non sono accettanti dovranno diventare accettanti no? sì? ci siamo? no basta puoi scambiare no? eh no aspetta cioè questo è il punto adesso no? ci siamo?
ok cioè adesso no? questo automa qua no? questo automa qua cioè come definisco il complemento di questo automa? cioè non lo posso fare perché l'automa non l'ho disegnato ok cioè questo è il punto cioè la perché ad esempio cioè il mio automa per il complemento no? come faccio ad ottenerlo a partire da questo? cioè deve essere un automa che per esempio ogni volta che una stringa inizia con 1 la dovrebbe accettare sì?
è giusto ogni volta che una stringa inizia con 1 deve essere deve essere accettato giusto? qualsiasi cosa ci sta dopo ok? cioè quindi è chiaro che per fare il complemento di un automa la delta deve essere definita dappertutto se io faccio questo disegno qua e poi dico prendi il complemento di questo eh il complemento di questo è sbagliato ok? cioè vi trovate cioè se io lo lasciavo così il disegno
e dicevo ok ora faccio il complemento il complemento vuol dire che Q1 diventa accettante Q0 non è più accettante Q2 non è più accettante questo è sbagliato perché adesso questo non è vero che accetta tutte le stringhe che cominciano con 1 quindi vi trovate? ok il complemento cioè se facevo se facessi se facessi il complemento di questo di FA di FA non potrebbe
otterrei non otterrei la negazione di 0 1 più sta qui vi trovate? ok? cioè questo è chiaro cioè se io applico l'automa del complemento l'automa di chiusura del complemento a questo automa ok? non accetto tutte le stringhe
che cominciano con 1 ad esempio quelle le dovrei accettare tutte sì? ok quindi che devo fare? devo completare questa figura in modo che questo non accada perché se invece la delta è definita su tutti su tutti allora a quel punto non mi perdo niente ok? questa era diciamo la sottigliezza di questa cosa quindi per esempio qua dovrò aggiungere in realtà basta aggiungere un solo stato quello che abbiamo chiamato spesso lo stato pozzo cioè tutte le stringhe
vengono rifiutate e vanno in quello stato e ci rimangono poi per sempre quando sono di quel tipo ok? cioè quindi per esempio questo quali sono le stringhe che sono rifiutate? quelle che cominciano con 1 ok? quando inizio con 1 vado qui e non ne esco più no? sì? ok? cioè adesso ok? cioè quindi l'automa deve essere completo per ogni stato ci deve essere la freccia con 0
questo significa che l'automa è completo qui cioè quindi nello stato q0 mancava la freccia q1 mo ci ho messo nello stato q3 c'è sia la freccia q0 che la freccia q1 tanto è un DFA quindi non ci possono stare più frecchi quindi adesso è giunto questo stato perché era un autovolto adesso esplicitamente lo scriviamo lo scrivo perché poi dopo devo disegnare il complemento quando disegno il complemento la q3 sarà accettante questo prima non c'era la q3 cioè è un problema ok?
ok? e adesso la stessa cosa per q1 per esempio q1 ha la cosciente con 1 ma non ce l'ha la cosciente con 0? eh ce la devo mettere questo non ce la devo mettere q2 ce l'ha tutte e due qui ti manca solo una ma posso fare da q1 a q3 decisamente lo posso fare ok senza che faccia un altro stato che tanto è lo può fare ok? questo perché?
perché ogni volta che ci sono due 0 no? cioè in questo linguaggio nel complemento sono fatti dei linguaggi cioè fuori da questo linguaggio ci stanno tutte le stringhe che cominciano con almeno due 0 perché c'è 0 1 più cioè il primo 0 può essere seguito deve essere seguito da almeno un 1 tutte le stringhe del tipo 0 0 stanno fuori dal linguaggio si? ok infatti qualsiasi cosa sta dopo due 0
rimangono si? va bene? domande? ok meglio vedete Q3
qual è la domanda? il più ci deve stare almeno uno 0 ma non ci può stare uno 0 è solo solo di uno cioè è come lo star no? cioè per lo star
è uguale no? non è che dopo un 1 ci può stare un 0 uno star vuol dire no? tutte le stringhe che sono fatte da da una o vuote cioè quindi ci potrebbero essere 0 ripetizioni o più ripetizioni di uno cioè uno sempre ok ok ma la stringa vuota non è come tra i due la stringa vuota tra 0 1 star e no la stringa vuota sta in 0 1 più star ma c'è anche
in 0 1 star nel linguaggio accettato sopra in questo linguaggio no no sopra quello richiesto da L 0 1 star accetta la stringa vuota come anche 0 1 più star no non ho capito cioè nel senso che scusi non ho non ho capito la cosa che ha detto cioè il linguaggio L ha tutte le stringhe che non stanno là dentro sì sì
la stringa vuota ci sta là dentro sì quindi sta in L però anche in 0 1 star ma che c'entra però cioè la parte sinistra no le dice che sono tutte le stringhe della forma 0 1 star ma quali quelle che non stanno ok cioè cioè per dire no anche 0 1 è una stringa che sta in 0 1 star ovviamente però non sta in 0 1 più star la stessa cosa per epsilon cioè epsilon è una stringa possibile però non sta in 0 1 più star e quindi non sta in L
ah no non c'è in 0 1 più star epsilon sta in 0 1 più star siamo d'accordo quindi non sta in L perché L è il complemento di 0 1 più star però mi chiedevo 0 1 star a sinistra sì no non capisco la domanda nel senso che il fatto che a sinistra ci sia W in 0 1 star cioè non mi dice niente perché 0 1 star sono tutte le stringhe
ok tutte adesso dici ma quale so quelle che stanno in L quelle che stanno dopo i due punti mi dice quelle che so che stanno in L non quello che sta prima dei due punti cioè tutte le stringhe sono quelle al favore ok però ma quali stiamo prendendo dice quello che sta scritto a destra non quello che sta scritto a destra ok quale ah
ok no è semplicemente perché lo sto facendo in questo modo cioè magari poteva fare in altro modo cioè io però cioè quello che lei poteva fare anche diciamo forse è quello di dire ok caratterizzo qual è il complemento di quel linguaggio poi faccio un automa per il complemento perché questo non è che era sbagliato però io sto usando voglio usare la chiusura per il complemento perché mi sembra più facile almeno quando l'ho risolto stai deciso mi sembrava più facile ok come faccio a usare la chiusura del complemento vuol dire che prima devo fare l'automa per 0 1 più star e poi però devo applicare il teorema
di chiusura del complemento però attenzione cioè quando lei questo esercizio era fatto apposta per farvi riflettere su questa cosa ok quando lei applica la chiusura per il complemento deve fare una certa trasformazione cioè deve prendere il DFA e lo deve trasformare e che deve fare gli stati accettanti diventano non accettanti e viceversa ok le sto facendo notare che se l'automa che ha disegnato anche se quell'automa diciamo riconosce quel linguaggio ma non è disegnato in maniera completa ok
non cambia niente perché quando non è disegnato in maniera completa è un problema che riguarda solo le stringhe che non sono accettate però capito quando lei fa il complemento le stringhe che non sono accettate devono diventare accettate cioè se lei uno stato non ce l'ha messo si perde i pezzi e io l'ho fatto vedere quando non c'era Q3 ok quando non c'era Q3 cioè se vuole io lo faccio rivedere io lo faccio rivedere guarda
l'avevamo disegnato così ok ok questo andava bene per 0, 1 più star andava bene ok perché per esempio 0, 1 più star non contiene le stringhe che cominciano con 1 se però lei adesso apre il teorema di dosura questo lo fa cioè lei gli stati Q0 e Q2 diventano non accettati e Q1 diventa accettabile però ma adesso lei se persi bene
perché non può dire che il complemento di questa automa riconosce L che era quello che doveva fare L lei doveva riconoscere L no? perché questo è vero? perché per esempio se lei fa il complemento di questa automa ok questa automa continua a rifiutare la stringa 1 quindi è un problema lo vedi? non funziona perché non funziona? perché lei l'automa non l'ha disegnato tutto cioè io l'ho disegnato tutto ok perché l'automa per esempio
la stringa che comincia con 1 è rifiutata da questa automa ok? e questo va bene va bene questo va bene però il suo scopo è fare l'automa per il complemento quindi lei deve fare un'automa che accetta la stringa 1 ma se lei adesso applica la trasformazione del complemento a questa automa la stringa 1 lei non l'accetta quindi sta sbagliando allora come fa a risolvere questo problema?
ci deve mettere tutte le stati cioè per ogni stato per applicare il teorema di chiusura quando la delta è espressa tramite disegno ok? lei deve avere tutte le frecce a partire da tutti gli stati ok? altrimenti ci poteva essere uno stato che era uno stato pozzo che lei non ha fatto quello stato dovrebbe diventare accettante ma nel suo disegno non c'è e lei se perde le stringhe ok? questa è la cosa che stavo facendo notare quindi ho aggiunto Q3 qua no?
in modo che le stringhe che cominciano con 1 vengono rifiutate adesso però verranno accettate dopo quindi vedi tutte le stringhe che cominciano con 1 seguito da una qualsiasi altra roba verranno accettate tutte le stringhe che pure sono del tipo 0 e dopo 1 e poi qualsiasi altra cosa pure devono essere accettate perché sono quelle stringhe che non stanno là dentro quindi qui aggiungo questo 0 adesso vedi l'automa è completo adesso posso applicare il complemento si tocca diventare accettante
quando lo inverto sarà accettante quando lo inverto ancora non l'ho invertito basta che cambio quello che era colorato diventa bianco quello che era bianco diventa colorato è finito direi di sì se ci fosse la stagiazione anche qui è la stessa struttura ok
quindi diciamo importante cosa abbiamo imparato per applicare la chiusura è bene che il DFA sia definito su tutti gli stati
ok va bene? questo è il risultato certo, sì sì vediamo ah sì sì non ho scritto
poi apri la chiusura cioè poi inverto poi inverto parti accettanti e non l'ho
ok? cioè quindi la delta deve essere poi apri la chiusura per il complimento la delta deve essere definita da percorso cioè adesso siccome l'avevamo fatta con il disegno vediamo un po' vediamo un po' gli esercizi del panchino no? L
L W W rovesciato non è arrivato ok?
ok? cioè tutte le stringhe del tipo W attaccato alla sua rovesciata non è arrivato non esiste un DFA che lo rimasca e ok il pump in L no? se lo fosse
esiste P tale che valgono le condizioni ok? considero adesso considero W la stringa 0 alla P 1
1 0 alla P ok? questa appartiene a L e il cardinalità di W è maggiore o uguale di P ok? quindi è una stringa per cui dovrebbero valere le condizioni del pump in L perché è una stringa che è nel linguaggio 0 alla P 1 e 1 0 alla P che è la sua rovesciata e c'è la lunghezza che è più grande di P no?
quindi devono valere le condizioni ok e adesso faccio vedere che non è possibile scomporla nel modo che dice il pump in L cioè contraddico il pump in L il pump in L ma mi dice questa stringa dovrei poterla scomporre in quel modo lì legale no? scusi ma il secondo esponente P è associato
allo 0 finale oppure a 1 sì in generale parentesi ah ok sennò ce lo devo mettere a parentesi sì no perché deve essere la palinza eh però quindi questo corrisponderebbe a 2 più L no? 1 0 P è la rovesciata di 0 più questo è rovesciata eh è rovesciata ah è questo che sta scoprendo eh sì è quello che sta
scritto qua questa no però qua poi lo ho definito uguale ok ok ok bene ok allora prendo una scomposizione albinaria sia prendo scomposizione w x e y
z no? e tale che y cardinalità di y maggiore di 0 cardinalità di x y minore o uguale di P no? queste sono le condizioni della composizione questo che significa questo mi impiega che praticamente y è fatta di soli 0 scomposizione giusto? perché cardinalità di x y minore o uguale di P
y non è vuota e quindi y è fatta di soli 0 perché la stringa w comincia con P 0 ok? cioè ovvero in altre parole sto dicendo che cioè w lo sto scomponendo come 0 alla k 0 alla l 0 alla m 1 1 0 alla p no? dove praticamente
k più l più m è uguale a P x sarà 0 alla k questo sarebbe x x non sarà 0 alla l e z sarà tutto il resto k maggiore o uguale di 0 l maggiore di l
l deve essere maggiore di 0 giusto? sì? quindi uguale a 2 abbiamo x y al quadrato del 0 ok?
0 è 0 alla m tutto il resto no? sì? e quindi questa sarà sarà uguale a 0 alla k 0 alla 2 l 0 alla m
e poi 1 0 alla p giusto? e abbiamo che k con con k più k più 2 l più m ok? k più 2 l più m
è praticamente è uguale a k più 2 l più 2 m più 2 l che è uguale a p più l che è maggiore di perché l è maggiore di 0? sì? no perché y può essere vuota y non può essere vuota l deve essere strettamente maggiore di 0
no no no la i è la i cioè fino a qua il pumping lemma sto prendendo ok sto prendendo una qualsiasi scomposizione della stringa v ok? di tipo x y 0 ok? sì? però l'osservazione è che y deve essere fatta fino a y deve essere sicuramente
più l no no no ok x l'ho chiamato 0 alla g ok? y l'ho chiamato 0 alla l k l sono valori albinari ok? va bene questo perché abbiamo detto che x y è meno uguale di p quindi fino a x y deve essere tutti 0 vedremo fino qua ok quindi k l'ho chiamato
il numero di z che stanno in y e l il numero di z che stanno in y sì? ok ma k k potrebbe anche essere 0 perché non c'è l quindi k maggiore o uguale a 0 ok ma l sicuramente è strettamente maggiore di 0 perché y può essere vuoto ok? ci troviamo ok z è tutto quello che viene dopo ok? che potrebbero essere un po' dei z quelli che mancano diciamo alla differenza diciamo p meno la somma della lunghezza di
più tutto il resto ok quindi prima cosa ci troviamo adesso faccio pumping faccio pumping con y uguale a 2 quindi considero x in un circolo questo sarà 0 a k 0 a 2l perché era 0 a l allora x in un quadro deve essere 0 a 2l 0 a l è 1 1 a ok? ok adesso conto gli zeri ok? adesso conto gli zeri sì? gli zeri che stanno a sinistra se questi non so più
non è palito perché a sinistra c'è più 0 e a sinistra c'è più 0 sì? allora ma questo è vero perché k più 2l più m che è il numero di 0 è k più 2l più m più l ma k più 2l più m è proprio p quindi più l ma è estremamente più 0 ok? quindi questo è una contraddizione
ma è maggiore se fosse uguale è un problema ma il fatto che sia maggiore è perché l è strettamente positivo l non può essere 0? sì? è giusto? dubbi? incertezze?
tutto chiaro? proviamo in un altro l uguale 1 elevato alla n al quadrato non è arrivato ok?
sì? allora suppongo lo sia quindi questo linguaggio qua quali sono le stringhe che stanno in questo linguaggio? tutte quelle che sono una ripetizione di 1 però il numero di 1 deve essere un quadrato ok? cioè quindi quindi il numero di 1 deve essere pari no? perché ad esempio n è uguale a 1
oppure anche 3 al quadrato fa 9 no? deve essere esattamente un quadrato no? cioè quindi per esempio c'è la stringa che contiene solo 1 c'è pure la stringa vuota perché 0 ripetizioni di 1 è la stringa vuota poi c'è anche ci saranno 2 e 2 e 1 no? 2 e 1 no? ci saranno 4 e 1 no? 2 alla seconda 4 e 1 poi 9 e 1 16 25 ok? quindi per esempio 24 e 1
non ce sa però 25 si ok? va bene suppongo lo sia ok? e scelgo scelgo direttamente adesso w uguale 1 elevato alla p al quadrato ok? appartenente a l e ok? quindi questo è il mio è il mio
è la mia stringa quindi suppongo lo sia vuol dire che esiste p tale che ma con le condizioni del pumping lemma adesso farò vedere una contraddizione prendo la mia stringa w che è 1 elevato alla p al quadrato ok? e adesso devo fare il pumping no? ok considero considero una scomposizione scomposizione generica di w
uguale il tipo w uguale x y z tale che y maggiore di 0 e cardinalità di x y meno uguale di x ok? devo considerare questo tipo di scomposizione ok? in particolare avremo che w
sarà del tipo 1 alla k 1 alla l e poi 1 elevato a p quadro meno k meno l ok? dove? praticamente sto dicendo che x è uguale a 1 alla k y è uguale ancora una volta a 1 alla l e z è tutto il resto
ok? z è tutto il resto z è 1 alla p quadro meno k meno l e k è maggiore o uguale di 0 ok? posso sopra così k maggiore o uguale di 0 l maggiore di z giusto? ok fatto diciamo la stessa cosa di prima
e vediamo ovviamente anche deve essere vero che k più l deve essere minore o uguale di p no?
giusto? x y sarebbe cardinalità di x y k più l è meno uguale giusto? ok e faccio un pumping adesso no? con ancora una volta i uguali a 2 ok? quindi considero x y al quadrato 0
e questa era del tipo 1 alla k 1 alla 2 l e poi 1 alla p quadro meno k meno l giusto? ok? si? e qual è la cardinalità? adesso devo far vedere che questo numero non è
che non è un quadrato cioè la lunghezza del numero di 1 non deve essere un quadrato ok? perché se fosse un quadrato cioè per far stare fuori da lì quasi vuol dire che la sua lunghezza la lunghezza di questa stringa non deve essere un quadrato x y al quadro 0 qual è la sua lunghezza? è k più 2 l più p quadro meno k meno l giusto? che è uguale a p quadro
più l che è maggiore a p quadro ok? perché l è strettamente così quindi questa stringa qua questa stringa qua ok? c'ha ovviamente vabbè non era sorprendente diciamo che c'ha strettamente più di p quadro
di p quadro 1 no? perché appunto ho fatto il pumping di y con y uguale 2 y nel quadro quindi ci saranno più almeno p quadro ce ne saranno ok? fino a mo' ho detto solo questo ok? adesso per far vedere che non sta nel linguaggio basta far vedere che questo numero è strettamente più piccolo di p più 1 al quadrato se questo fosse vero beh perché siamo arrivati alla stringa ci sono più 1 di p al quadrato si? ci sono più di p al quadrato 1 ci sono almeno p al quadrato ok?
adesso però per stare nel linguaggio ce ne devono stare p più 1 tutto al quadrato oppure p più 2 tutto al quadrato oppure p più 3 tutto al quadrato oppure p più qualcosa tutto al quadrato però purtroppo se questo numero di 1 fosse strettamente più piccolo ok? di p più 1 al quadrato vuol dire che il numero di 1 è compreso tra p quadro e p più 1 al quadrato e quindi sta a mezzo va bene ok? si? devo solo contare gli 1 no?
ok? ok? quindi adesso mi rimane solo da contare il linguaggio è del tipo 1 alla m al quadrato ok? cioè quindi il numero di 1 che sta nel linguaggio deve essere un quadrato perfetto ok? va bene? quindi se io sto dicendo che siccome ci stanno più di p al quadrato 1 ok? adesso
cioè almeno ce ne stanno più al quadrato perché è sicuro affinché questa stringa però stia nel linguaggio il numero di 1 non può essere un numero qualsiasi a questo punto può essere o p più 1 tutto al quadrato oppure p più 2 tutto al quadrato ok? si? giusto? questa è la definizione del linguaggio se fosse vero che il numero di 1 è strettamente più piccolo di p più 1 tutto al quadrato come sarà? allora non sta nel linguaggio e ho fatto una contraddizione ho raggiunto una contraddizione ok? quindi sto dicendo se faccio pumping professore scusi ma se
prima aveva definito L come 1 alla L quello era Y Y come 1 alla L quando sotto faccio il pumping quindi con Y alla seconda dovrebbe essere 1 alla L alla seconda cioè non mi sta confondendo adesso sta confondendo il quadrato delle stringhe con il quadrato degli interi il quadrato degli interi significa che cioè vedete nella definizione qua c'è scritto che N è un numero positivo non è una stringa ok?
cioè il quadrato applicato ai numeri ok? perché N è un numero naturale ok? quindi il quadrato applicato ai numeri è N per S ma il quadrato applicato alle stringhe significa la potenza di una stringa qui X è la concatenazione ok? con potenza di stringa e concatenazione di non c'è confondimento non è che la si? ok
ok però guarda che succede però P più 1 al quadrato ok? cioè P più 1 al quadrato è la prossima stringa la lunghezza della prossima stringa che sta nel linguaggio questa è uguale a P quadro più 2P più 1 ok? è il quadrato del binomio
questa è e P avevamo detto no? si e vi ricordate no? K più L è minore o uguale di P ok? ovvero P maggiore o uguale di K più L ok? quindi questa è maggiore o uguale
di P quadro più 2 volte K più L più 1 ok? questo perché abbiamo detto perché K più L è minore o uguale di P ok? vi ricordate? cardinale di X è minore o uguale di P K più L è minore o uguale di P ovvero P maggiore o uguale di K più L quindi posso fare maggiore o uguale di 2 volte K più L
e questa adesso voglio dire P quadro più 2 volte K più L più 1 questa è maggiore ok quindi è facile cioè questa è seriettamente maggiore di P quadro più L
perché c'è P quadro più 2K più 2L più 1 P quadro più 2K più 2L più 1 sì? cioè quindi ovviamente K è maggiore o uguale di è minore o uguale di 0 quindi K non ci dà passione K è maggiore o uguale di 0 non ci dà passione cioè K lo posso ignorare potrebbe essere 0
però c'è sicuramente P quadro più 2L ok P quadro più 2L è strettamente è maggiore di P quadro più L sì? poi c'è più 1 più 1 lo strettamente maggiore lo dà il più 1 cioè poi tolgo il più 1 e posso mettere strettamente maggiore e poi c'ho P quadro più 2L questo è ovviamente è diciamo maggiore o uguale di P quadro più L ok però c'è uno strettamente maggiore perché c'è il più 1
quindi questo mi dà che P più 1 al quadrato è strettamente maggiore di P quadro più L vabbè ho finito ce ne avevo P quadro più L dei valori quindi il mio numero di 1 è strettamente minore di P più 1 al quadrato ok? questa è una contraddizione perché la lunghezza no? cioè la contraddizione ovvero mettendo quello che sto dicendo è che la lunghezza di x di y al quadrato di z che era uguale a
x quadro più L è strettamente minore di P più 1 al quadrato P più 1 al quadrato ma d'altra parte la cardinalità di x quadro z era diciamo dove l'avevo scritto? maggiore di P al quadrato ok? cioè quindi ho fatto pumping ok? che cosa ho ottenuto? ho ottenuto una sequenza di 1
ho ottenuto quindi strettamente più grandi di P al quadrato ma strettamente più piccoli di P più 1 al quadrato non sta nel linguaggio giusto? contraddizione domande? se non ci sono domande ciao
ok
abbiamo terminato lo studio dei linguaggi regolari va bene? e abbiamo visto che i linguaggi regolari corrispondono a un modello di calcolo semplice che è quello del DFA e abbiamo visto che ci sono linguaggi che non sono regolari ok? quindi motivati da questo limite andiamo a definire un tipo di una classe di linguaggi più grande ok?
una classe di linguaggi più grande e e questi saranno quelle che si chiamano le grammatiche acontestuali in inglese le chiamano context free context free grammars ok? c f c ok? anche dette grammatiche context free e vedremo che e quindi vedremo questo introduciamo
un modello un modello di computazione più potente utile in diverse applicazioni applicazioni
ad esempio il di parzer per i compilatori di linguaggi di programmazione ok? cioè quella parte dei compilatori no? che vi dice se una certa espressione è formata nel modo giusto no? cioè per esempio se avete chiuso le parenti se l'avete aperte nel manolo corretto e cose di questo tipo va bene? cioè questo è una cosa che infatti questi parzer sono facilitati se sono progettati a partire da una grammatica possono essere progettati a partire da una grammatica
vedremo anche che le grammatiche vedremo che le grammatiche coincidono anche con un diverso tipo di autonomo
ok? cioè vedremo in realtà che le grammatiche sono definite in un modo che non nomina mai la parola autonomo cioè non sono definite a partire dagli automi ok? tipo le espressioni regolari come abbiamo visto le espressioni regolari automi sono state definite stessa cosa le grammatiche automi di tipo push down va bene?
PDA ok? si chiameranno PDA questi automi che corrispondono alle grammatiche e saranno degli automi che possono fare più cose rispetto a quelli stati finiti infatti sarebbero gli automi che hanno pure una pila possono utilizzare una pila possono trattarla in un certo modo ok? va bene? e ci sarà una corrispondenza tra queste due cose e ed infine vi anticipo anche questo vedremo anche che ci sono anche però
linguaggi che non sono corrispondenti non sono riconoscibili da nessuno di questi da automi di questo tipo ok? cioè quindi non è vero che che abbiamo abbiamo definito una classe di linguaggi più grande ma non saranno comunque tutti linguaggi perché ci saranno linguaggi che non saranno equivalenti a grammatiche autoessuali ok? tipo pumping lemma ok? cioè ci sarà un pumping lemma anche per questa roba qua ok? questo ci porterà poi a definire
un riconoscimento stesso va bene? questo è un po' il piano va bene però diciamo la buona notizia è che le grammatiche per esempio facilmente riconosceranno linguaggi che non erano regolari cioè ad esempio diciamo ad esempio sarà molto facile dare una grammatica
che genera stringhe le stringhe 0 alla n 1 alla n 1 alla n maggiore o maggiore lo vedremo subito ok? cioè quindi il primo esempio di linguaggio di linguaggio infatti il primo esempio di grammatica
che vedremo sarà proprio questo ok? partiremo da questo e questo già ci starà dicendo quindi che di fatto le grammatiche possono caratterizzare una classe di linguaggi più grandi perché questo è un linguaggio male sappiamo che questo è un linguaggio male ok? facciamo proprio questo ok? come esempio facciamo subito questo come esempio ok? invece di dare
la definizione formale facciamo un esempio va bene e di fatto allora una grammatica una grammatica è una sequenza ecco una sequenza di sostituzioni e produzioni ok? di questo tipo
ad esempio ok? a lo posso sostituire con 0 a 1 ma anche a lo posso sostituire con b e infine b lo posso sempre sostituire con sha ok? va bene? ok qui sono una grammatica è un insieme di regole ok? sono regole si chiamano regole le regole della grammatica
ok? come se fosse diciamo la grammatica del linguaggio ci sono le regole queste regole sono righe una dopo l'altra scritte una di seguito all'altra ok? e come sono fatte queste regole? sono fatte di questo tipo ok? cioè come vedremo nelle grammatiche ci sono due elementi ok? una sono le variabili quelle che di solito indichiamo con la lettera maiuscola ok? le variabili sono quelle che si possono sostituire con altre sequenze di variabili e anche terminali i terminali sono i caratteri dell'alfabeto invece no? cioè in questo caso per esempio
0 e 1 e anche sharp il simbolo sharp sono i terminali ok? quindi diciamo 0 1 sharp sono i terminali sono dei terminali a b sono invece le variabili ok? e le regole e le equazioni diciamo no?
sono le regole queste sono invece le regole le regole della grammatica ok? ok? e inoltre
va bene? che volevo dire? ok c'è sempre una variabile speciale che si chiama variabile iniziale ok? e in questo caso penso sia a non l'ho specificato in realtà però
di solito no non di solito come vedremo ci sarà sempre una variabile iniziale ok? la variabile iniziale è quella che vi dico qui devi cominciare da quella ok? non puoi cominciare da B per esempio devi cominciare per forza da A e devi applicare una delle regole ok? quindi come fai? cioè che cosa fa una grammatica? una grammatica genera stringhe come le genera? partendo dalla variabile iniziale e applicando in maniera arbitraria una o più delle regole che ci stanno nella grammatica
non c'è un ordine ok? cioè poi fa quello che ti pare e a un certo punto ti esce poi una stringa perché la stringa ti esce quando hai terminato quando hai sostituito tutte le variabili con il terminale ok? infatti le grammatiche che vedremo sono oggetti che sono indirettamente ricorsivi ok? quindi vediamo un esempio quindi come la grammatica
genera stringhe seguendo questo processo scrivo scrivo variabile iniziale poi
sostituisco variabili con altre espressioni espressioni seguendo le regole della grammatica seguendo le regole della grammatica e ripeto
fino a che non ci sono più variabili ok? cioè quindi parto dalla variabile iniziale comincio a usare le regole le regole mi permetteranno di sostituire la variabile iniziale con altre espressioni che contengono sia variabili che terminali come ad esempio questa ok? continuo come voglio fino a che a un certo punto le variabili non ci stanno più
quella stringa sta nel linguaggio che corrisponde a quella grammatica ok? la grammatica e il linguaggio associato alla grammatica sono tutte da queste stringhe visto che prima o poi arriveremo a un punto in cui non troveremo più variabili si queste stringhe che non ci sono cicli e stanno tipo che A diventa B B diventa A e così via cioè se no diventerebbe non ci sono cicli infiniti se ci fossero diciamo quella grammatica non si genera nessuna stringa cioè una grammatica potrebbe generare il linguaggio vuoto
ok? giusto? va bene ad esempio ok? nell'esempio facciamo un esempio cioè questa non è la definizione ok? ok? sto facendo un esempio ok? però vi sto dando l'intuizione cioè ad esempio parto da A qua
la prima regola e produco 0 A1 per esempio ok? poi uso di nuovo la prima regola e sostituisco A con 0 A1 si? e poi ancora
ok? poi basta cioè come se questa diciamo cioè se questa la chiamassi R1 questa la chiamassi R2 e questa la chiamassi R3 no? avrei fatto praticamente R1 R1 R1 poi potrei usare R2 fare 0 0 0
quindi 1 1 1 e infine R3 0 0 0 0 1 quindi questa grammatica la grammatica dell'esempio genera 0 0 0 1 1 per esempio perché ha deciso da R2 di sostituire
arbitrati per fare esempio non è una regola cioè infatti diciamo questa è soltanto una delle possibili stringhe che quella grammatica genera ok? il linguaggio associato alla grammatica saranno tutte le possibili stringhe che sono generabili utilizzando le regole della grammatica tutte quindi cioè noi abbiamo delle stringhe che non sono generabili perché se noi continuiamo ad usare R1 R1 R1 certo infatti questa questa grammatica
qua per esempio genera 0 alla n 1 alla n dove gli 0 e gli 1 sono separati da sharp in questo caso ok? c'è pure lo sharp in mezzo si? si vede no? cioè che questa per come tu voglia diciamo utilizzare le regole di questa grammatica puoi solo generare le stringhe del tipo 0 alla n 1 alla n con sharp in mezzo non puoi fare altrimenti si ma lo sharp sarebbe la stringa vuota? no lo sharp è un simbolo cioè sarebbe diciamo
l'alfabeto in questo caso sarebbe un terminale terminale ok? cioè come dicevo nelle grammatiche ci saranno le variabili che sono quelle che puoi sostituire e che quindi compaiono a sinistra delle regole no? ok? le variabili compaiono solo a sinistra a parte le cose maiuscole a destra ci compaiono altre variabili ma anche i terminali i terminali saranno definiti un alfabeto in questo caso l'alfabeto sarà 0 1 sharp in questo esempio sharp è un simbolo
ok? in realtà è pure facile fare una grammatica che ti genera 0 alla n senza lo sharp ok? lo sharp è un esempio va bene? un esempio va bene? per ogni derivazione questa si chiama produzione o derivazione ok? per ogni tale per ogni tale derivazione produzione
tale produzione posso associare quello che si chiama un albero sintattico
un albero sintattico cioè è semplicemente un modo diverso di vedere quello che ho fatto adesso cioè per esempio in questa produzione qua che ho fatto prima la posso vedere così sono partito da a ok? la radice dell'albero poi ho applicato la regola a cioè ho fatto così cioè
ok? cioè sotto le foglie dell'albero saranno soltanto i terminali i terminali ok? quindi da a sono passato a 0 a 1 ok? 0 e 1 scritte in fondo perché saranno le foglie ok? un'altra volta ho fatto la stessa cosa giusto?
e qui 0 a 1 ok? qui è uguale a 0 a 1 e poi b e poi sha ok? diciamo che dovrebbero essere tutte la stessa altezza facciamo così b
sha va bene, domani ce l'ha tutti
si? va bene? cioè come l'ho disegnato quest'albero? quindi l'ho disegnato seguendo le regole che ho fatto sopra è la stessa cosa che ho partito da e ho fatto a 0 a 1 ok? 0 e 1 le scrivo nelle foglie no? perché ho già ormai non le posso più sostituire con niente
ok? perché ormai sono arrivato a terminali i terminali non si sostituiscono con niente le regole sostituiscono soltanto variabili con altre espressioni ma non i terminali non sono mai sostituiti quindi alle foglie ci metto tutti i terminali va bene? questo è quello che si chiama l'albero sintattico vediamo ci siamo? ok domande? domande?
altro esempio altra grammatica g chiamiamola g ok? questa è così cioè r1 che fa questo e lo sostituisce con e più e e lo sostituisce con e per e
lo sostituisce con parentesi e e e lo sostituisce con 0 1 2 ok? la riga quella riga lì quel separatore dritto è come per dire ci sta la regola e0 ma anche la regola e1 anche la regola e2 cioè invece di scriverle tutte separate una per riga cioè e freccia 1 e freccia 2
e freccia 3 e freccia 4 sto dicendo e lo posso sostituire con qualsiasi cosa da 0 1 2 3 4 fino a 9 ok? singolo però singolo ok? in questo caso in questo caso i terminali sono 0 1 9 più per parentesi parentesi
sì? cioè inserito pure gli operatori eh sì perché sono terminali eh e le pareti? sì in realtà sì pure le pareti sono come se fossero terminali cioè l'alfabeto sarebbe questo in questo caso il mio alfabeto dalla grammatica è questo no? perché quando aprisco le regole otterrò delle stringhe che sono fatte
i simboli qua sì? però vedi per esempio mentre le variabili in questo caso l'unica variabile è la sua ok? ok ok questa g per esempio g genera 3 più 4 per 4 ma non genera
ma non genera 3 più 4 più per 4 ok? cioè 3 più 4 per 4 la genera perché ad esempio no faccio così parto da e applico r2 e ottengo e per e applico r3
e ottengo e per e applico r4 e ottengo e più e per e per e applico r 4
e ottengo e per e applico r2 e ottengo e per e applico r3 e poi applico r1 in questo caso però siccome le variabili hanno tutto lo stesso nome decidiamo noi evidentemente di fare delle variabili applicare la regola se se le variabili scegliamo una sì sì esatto cioè poi ci sono dei modi canonici per farlo a volte le derivazioni si possono fare partendo sempre dalla variabile più a sinistra ci sono dei modi canonici per derivare le stringhe partendo sempre
sostituendo sempre quello che sta a sinistra ma non c'è nessuna regola in questo tipo adesso posso sostituire quello che voglio per dire visto che ci sono due e quattro in un successivo passaggio che si può fare applicando r4 sostituire due insieme no un passo della composizione è come la delta però se può considerare la transizione estesa cioè la star allora fa quella cosa che dice lei è come la delta e la delta star è la stessa cosa
e r1 poi posso fare r4 e per esempio posso fare e più e per 4 e poi continuo e posso fare 3 più e per 4 e poi continuo e posso fare 3 più 4 e ho finito
ok non possiamo scrivere tutto insieme direttamente r4 no altrimenti sta facendo la transizione estesa un'altra volta la stessa cosa che ho detto come la delta e la delta star ok una produzione una regola se può fare più produzione insieme lo può fare però a quel punto sta facendo sta estendendo diciamo il concetto ok cioè questo lo posso pure disegnare
cioè io l'ho fatto diventare e pereno poi dai
a sinistra l'ho fatto diventare e più e poi quella e a sinistra l'ho fatto diventare e più e poi questo l'ho fatto diventare 3 questo l'ho fatto diventare 4
questa e qua l'ho fatto diventare 4 sì? questo è l'albero risultato ok niente di niente di trascendentale ok ok quindi per esempio cioè questa per definizione questa grammatica
sempre bene perché puoi aggiungere c'è una sola parentesi e può essere soltanto sostituito da i tre parentesi no? ok però non puoi mai avere una cosa che per esempio finisce con più cioè più è sempre seguito da un'altra cosa perché se vedi le regole come fai a fare è una cosa che più finisce in secondo no? sì? cioè quindi questa grammatica genera tutte le espressioni aritmetiche con una sola parentesi solo con le parentesi sono due sì?
ok va bene possiamo definire adesso quella che si chiama la context free di Rammstein una cfg è una tubla del tipo v sigma rs
dove? v è insieme finito di varianti ok? sigma è l'alfabeto e sigma è insieme finito terminale
abbiamo che v intersegato sigma è vuoto ok? sono disgiunti v e sigma i varianti terminali devono essere disgiunti se no faccio un cammino ok? e r sono le regole sono insieme di regole insieme di regole
s v è la varia di inizio ok? basta questa è una grammatica non ti so tutto qua ok?
fatta così le regole vabbè non ho scritto nella definizione però le regole sono fatte sono sempre fatte così che a sinistra c'è una sola variabile e a destra c'è un'espressione che è fatta da una sequenza un insieme di variabili e terminale ok? cioè ad esempio vediamo una cosa posso anche definire adesso il linguaggio?
insieme delle regole può essere infinito? modo? finito? finito ho scritto r è insieme finito grazie finito benissimo
ok? a questo punto vedete diciamo se u v se u v v doppio appartengono a sigma unito v ok? e a a v doppio appartiene alla regola a v doppio
appartiene a r ok? se prendiamo qualsiasi u v v doppio appartenente a sigma unito v ok? e c'è la regola a freccia v doppio in r allora diremo che che u a v produce
u v u v doppio u e lo scriviamo come u a v produce u v doppio ok? ok? questo è un nomenclatura cioè nel senso che se prendiamo
qualsiasi u v v doppio che stanno nell'unione tra sigma e v ok? cioè possono essere variabili terminali che non fanno niente nell'unione allora diremo che l'espressione u a v produce u v doppio v perché c'è la regola a freccia v doppio e lo scriviamo in questo modo ok? e ok? questa è come dire cioè una singola l'applicazione
una singola regola cioè quello che abbiamo fatto sopra la produzione che abbiamo fatto sopra tutte queste qui sono tutte produzioni quello che abbiamo fatto qua ok? se diciamo anche che u deriva v doppio
con lo star se esiste una sequenza di passaggi intermedi che riportano da u a v u deriva v u deriva v se u uguale v oppure esiste una sequenza di u1 u k k maggiore uguale 0
tale che u produce u1 che produce u che produce u k ok? cioè quindi abbiamo due frecce che chiamiamo implicazioni la freccia singola quella che ti dice ok parti dall'espressione ok? quell'espressione produce quest'altra espressione
usando una delle regole sarebbe la prima cosa che ho scritto ok? cioè parto da un qualsiasi espressione del tipo u a v ok? dove u e v possono essere un insieme di variabili o terminali ok? non sto distinguendo che cosa sono perché ho detto che stanno nell'unione tra sigma e v ok? non sto facendo distinzione però c'è una a che invece è una variabile no? in questo caso allora applicando una regola faccio il singolo passo di derivazione
derivazione singola applico una regola derivazione star esistono una serie di derivazioni singole che mi portano dalla prima all'ultima ok? solo questo sto dicendo ok? cioè quindi oppure diciamo ovviamente è il caso banale che sono un vario ovviamente è una cosa sempre stessa ok? questo sarebbe diciamo come la cosa come la delta e la delta estesa è la stessa cosa questo ci porta a definire ci permette
di definire il linguaggio associato ad una grammatica ad una cfg ok? cioè sia g gfg v come abbiamo chiamato v sigma e rf allora
che cos'è l di g l di g è l'insieme di stringhe fatte di soli terminali tale che s può produrre cioè sono tutti gli insiemi di terminali producibili a partita s con qualche passaggio intermedio che è si? è un modo compatto per scrivere
ok? quindi due concetti fondamentali ok? il primo è la definizione di grammatica il secondo è la definizione di linguaggio associato ad una grammatica che cos'è il linguaggio associato ad una grammatica? è l'insieme di tutte quelle stringhe che posso produrre partendo dalla variabile inca stringhe fatte di soli terminali ok? quindi v doppio e sigma star s produce star v doppio cioè esiste una sequenza
di sostituzioni che mi porta a passare da s a v doppio si? quindi data una grammatica c'è associato ad essa un linguaggio questo l'insieme di linguaggi associati alle grammatiche adesso è una classe di linguaggi come i linguaggi regolari è una classe di linguaggi che sono descrivibili dagli FA ok? questa classe di linguaggi qua
è più grande perché abbiamo visto già che contiene linguaggi che non sono regolari ci sono? va bene? adesso vogliamo capire vogliamo caratterizzare domande? si si si si
va bene? vediamo degli esempi ok? vediamo degli esempi di grammatica un altro esempio di grammatica tipico di grammatica di questo esempio g è definita così v è uguale a s sigma è uguale
a a b poi c'è r e poi c'è s ok? e la regola è questa r e è questa s lo puoi sostituire con a s b ma anche con s s
e anche con r ok? ok? questo è un esempio c'è e
non è difficile con b ci siamo s a s b s s epsilon epsilon è la stringa vuota cioè vuol dire che s lo posso sostituire con niente e e questa grammatica qui per esempio è come se fosse diciamo quella che corrisponde al parter che controlla che le parentesi sono bene annidate perché è come se
a fosse la parentesi aperta e b fosse la parentesi chiusa ok? e le stringhe che stanno generate così diciamo sempre che la parentesi è aperta cioè non ci puoi avere mai non ci puoi avere mai non puoi mai avere ad esempio b a parentesi chiusa e non puoi avere ok?
no no no dico se a fosse il simbolo della parentesi c'è il simmetrico sì esatto sì sì cioè no ad esempio questa qui cioè per esempio no? cioè facciamo degli esempi a b appartiene a l che posso fare s a s b a e b che è uguale a
no? e d'altra parte anche a a b b no? ok? nel legge sì perché posso fare sempre s a s b poi a a s b
poi a a ok? va bene ok questi linguaggi questi grammari di questo tipo sono sono utili per i parte ok? perché controllano
che appunto la parentesi aperta può essere guida da quella chiusa prima che ce ne sia un'altra aperta ok? che comunque per ogni parentesi aperta prima o poi si chiude ok? cioè giusto? cioè per esempio questa grammaria non genera mai la sola a ok? la sola a sarebbe come se fosse solo la parentesi aperta ok? oppure una stringa che termina con a non succede?
oppure una stringa che inizia con b cioè ma vi trovate? quindi è come se sta controllando che le parentesi sono ben annidate cioè controlla che a e b siano ben annidate ok? come i compilatori
va bene? domande? ok vediamo brevemente iniziamo a vedere iniziamo a vedere
alcuni alcune tecniche diciamo alcune tecniche per costruire per costruire grammatiche ok? vedremo alcune diciamo una semplice allunione di grammatiche come parentesi un altro è dagli FA
alle grammatiche e poi tre sfruttare la rivoluzione ok e queste sono diciamo tre tecniche che si possono usare per fare le grammatiche ok? una tecnica che si può fare per usare le grammatiche è tipo diciamo la chiusura no? cioè tipo la chiusura per l'unione no? ovvero
ottenere le grammatiche quindi posso sempre se posso vedere un linguaggio un'unione di linguaggi no? posso sempre diciamo ottenere una grammatica per quel linguaggio a partire dalle grammatiche per i linguaggi corrispondenti no? poi la seconda cosa che vedremo è che posso passare dai FA alle grammatiche ok? cioè questa è una cosa che ci sta convincendo del fatto che appunto già lo sapevamo cioè ci aspettiamo che infatti
le grammatiche a contestuali corrispondono a linguaggi che sono più grandi della classe di linguaggi regolari infatti per ogni DFA poi defini una grammatica immediatamente ok? e in generale puoi sfruttare la ricorzione no? perché è quello che abbiamo fatto per esempio per generare quindi linguaggi che portengono stringhe di lunghezza infinita che hanno una certa un certo pattern no? come per esempio 0 a n e 1 a n va bene?
vediamo questo a partire dalla prossima volta ci vediamo