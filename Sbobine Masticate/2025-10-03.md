# Lezione 04
Ci eravamo lasciati con la dimostrazione dell'equivalenza tra DFA e NFA e un esempio di conversione. Vorrei iniziare con una piccola ma importante correzione sulla costruzione del DFA equivalente a un NFA in presenza di $$\epsilon$$-archi. Avevo specificato come modificare la funzione di transizione, ma ho omesso un dettaglio cruciale per lo stato iniziale.

Quando si converte un NFA con $$\epsilon$$-archi in un DFA, lo stato iniziale del DFA non è semplicemente il sottoinsieme contenente lo stato iniziale dell'NFA, ma la sua **epsilon-chiusura**.
Quindi, lo stato iniziale $$q_{0,D}$$ del DFA è definito come:
$$ q_{0,D} = E(\{q_{0,N}\}) $$
dove $$E(R)$$ indica l'insieme di tutti gli stati raggiungibili da un insieme di stati $$R$$ seguendo zero o più $$\epsilon$$-archi. Questo garantisce che la simulazione parta considerando tutti gli stati in cui l'NFA potrebbe trovarsi prima ancora di leggere il primo simbolo di input.

#### Esempio: Conversione di un NFA in un DFA

Riprendiamo l'esempio della scorsa lezione: convertire un dato NFA in un DFA equivalente. La procedura segue i passaggi della costruzione dei sottoinsiemi che abbiamo definito.

Sia dato un NFA con stati $$\{1, 2, 3\}$$.
1.  **Definizione degli stati del DFA:** Gli stati del DFA ($$Q_D$$) corrispondono a tutti i possibili sottoinsiemi degli stati dell'NFA ($$Q_N = \{1, 2, 3\}$$). Questi sono: $$\emptyset, \{1\}, \{2\}, \{3\}, \{1,2\}, \{1,3\}, \{2,3\}, \{1,2,3\}$$.

2.  **Definizione dello stato iniziale:** Lo stato iniziale dell'NFA è $$1$$. Dal diagramma, vediamo che c'è una $$\epsilon$$-transizione da $$1$$ a $$3$$. Pertanto, lo stato iniziale del DFA è l'epsilon-chiusura di $$\{1\}$$:
    $$ q_{0,D} = E(\{1\}) = \{1, 3\} $$

3.  **Definizione degli stati finali:** Lo stato finale dell'NFA è $$1$$. Gli stati finali del DFA saranno tutti i sottoinsiemi che contengono lo stato $$1$$.
    $$ F_D = \{ \{1\}, \{1,2\}, \{1,3\}, \{1,2,3\} \} $$

4.  **Definizione della funzione di transizione ($$\delta_D$$):** Calcoliamo le transizioni per ogni stato del DFA e per ogni simbolo dell'alfabeto, seguendo la formula:
    $$ \delta_D(R, a) = E\left( \bigcup_{r \in R} \delta_N(r, a) \right) $$
    Ad esempio:
    *   **Stato $$\{2\}$$:**
        *   Con input **a**: Da $$2$$, l'NFA può andare in $$\{2, 3\}$$. L'epsilon-chiusura di $$\{2, 3\}$$ è $$\{2, 3\}$$. Quindi: $$\delta_D(\{2\}, a) = \{2, 3\}$$.
        *   Con input **b**: Da $$2$$, l'NFA può andare in $$\{3\}$$. L'epsilon-chiusura di $$\{3\}$$ è $$\{3\}$$. Quindi: $$\delta_D(\{2\}, b) = \{3\}$$.
    *   **Stato $$\{3\}$$:**
        *   Con input **a**: Da $$3$$, l'NFA può andare in $$\{1\}$$. L'epsilon-chiusura di $$\{1\}$$ è $$\{1, 3\}$$. Quindi: $$\delta_D(\{3\}, a) = \{1, 3\}$$.
        *   Con input **b**: Da $$3$$, non ci sono transizioni. Quindi: $$\delta_D(\{3\}, b) = \emptyset$$.

Si procede in questo modo per tutti gli stati raggiungibili a partire dallo stato iniziale $$\{1, 3\}$$. Il risultato sarà un DFA completo. Spesso, non tutti gli stati del powerset sono raggiungibili, e il diagramma finale può essere semplificato.

#### Utilizzo degli NFA per Semplificare le Prove di Chiusura

Ora che abbiamo stabilito l'equivalenza tra NFA e DFA, possiamo sfruttare la flessibilità degli NFA per dimostrare più facilmente le restanti proprietà di chiusura.

##### Unione con NFA (Riscaldamento)
Abbiamo già dimostrato la chiusura rispetto all'unione usando la costruzione del prodotto per i DFA. Con gli NFA, la costruzione è molto più intuitiva:
Dati due NFA, $$N_1$$ e $$N_2$$, per i linguaggi $$L_1$$ e $$L_2$$:
1.  Creiamo un nuovo stato iniziale $$q_0$$.
2.  Aggiungiamo due $$\epsilon$$-transizioni da $$q_0$$ agli stati iniziali di $$N_1$$ e $$N_2$$.
3.  L'insieme degli stati finali del nuovo NFA è l'unione degli stati finali di $$N_1$$ e $$N_2$$.

Questo nuovo NFA accetta una stringa se e solo se esiste un percorso di accettazione in $$N_1$$ oppure in $$N_2$$.

##### Chiusura rispetto alla Concatenazione
Dimostrare che se $$L_1$$ e $$L_2$$ sono regolari, anche $$L_1 \cdot L_2$$ lo è, era problematico con i DFA. Con gli NFA, la costruzione è semplice:
Dati due NFA, $$N_1$$ per $$L_1$$ e $$N_2$$ per $$L_2$$:
1.  Lo stato iniziale del nuovo NFA è lo stato iniziale di $$N_1$$.
2.  Aggiungiamo una $$\epsilon$$-transizione da **ogni stato finale** di $$N_1$$ allo **stato iniziale** di $$N_2$$.
3.  Gli stati finali di $$N_1$$ non sono più stati finali nel nuovo automa.
4.  Gli stati finali del nuovo NFA sono gli stati finali di $$N_2$$.

Questo automa esegue prima la computazione di $$N_1$$. Ogni volta che raggiunge uno stato che sarebbe stato di accettazione per una stringa $$x_1 \in L_1$$, usa il non-determinismo (tramite l'$$\epsilon$$-arco) per iniziare una nuova computazione con $$N_2$$ sul resto della stringa, $$x_2$$. Se anche $$N_2$$ accetta $$x_2$$, l'intera stringa $$x_1x_2$$ viene accettata.

##### Chiusura rispetto alla Stella di Kleene
Per dimostrare che se $$L$$ è regolare, anche $$L^*$$ lo è, usiamo un NFA $$N$$ che riconosce $$L$$.
$$L^*$$ contiene tutte le concatenazioni di zero o più stringhe da $$L$$.
1.  **Per accettare la stringa vuota ($$L^0$$):** Creiamo un nuovo stato iniziale $$q_0'$$ che è anche uno stato finale.
2.  **Per avviare la computazione:** Aggiungiamo una $$\epsilon$$-transizione da $$q_0'$$ allo stato iniziale originale di $$N$$, $$q_0$$.
3.  **Per concatenare più stringhe:** Per ogni stato finale di $$N$$, aggiungiamo una $$\epsilon$$-transizione che ritorna allo stato iniziale $$q_0$$. Questo permette all'automa di "ricominciare" dopo aver riconosciuto una stringa valida in $$L$$, per verificare se il resto dell'input è un'altra concatenazione di stringhe di $$L$$.

### Espressioni Regolari

Introduciamo ora un modo alternativo per descrivere i linguaggi regolari: le **espressioni regolari**. Storicamente, sono state sviluppate in modo indipendente dagli automi, ma la teoria della computazione ha unificato questi concetti.

Le espressioni regolari sono simili alle espressioni algebriche, ma invece di descrivere numeri, descrivono linguaggi. Sono uno strumento potente e ampiamente utilizzato, ad esempio, per la ricerca di pattern in testi.

**Definizione Ricorsiva di Espressione Regolare**
Un'espressione regolare $$R$$ sull'alfabeto $$\Sigma$$ è definita ricorsivamente:
*   **Casi base (espressioni atomiche):**
    *   $$\emptyset$$ è un'espressione regolare.
    *   $$\epsilon$$ è un'espressione regolare.
    *   $$a$$ è un'espressione regolare, per ogni $$a \in \Sigma$$.
*   **Casi induttivi:** Se $$R_1$$ e $$R_2$$ sono espressioni regolari, allora lo sono anche:
    *   $$(R_1 \cup R_2)$$ (Unione)
    *   $$(R_1 \cdot R_2)$$ (Concatenazione, spesso scritta semplicemente $$R_1R_2$$)
    *   $$(R_1^*)$$ (Stella di Kleene)

**Linguaggio Associato a un'Espressione Regolare**
Ad ogni espressione regolare $$R$$ è associato un linguaggio $$L(R)$$:
*   **Casi base:**
    *   $$L(\emptyset) = \emptyset$$ (il linguaggio vuoto)
    *   $$L(\epsilon) = \{\epsilon\}$$ (il linguaggio contenente solo la stringa vuota)
    *   $$L(a) = \{a\}$$
*   **Casi induttivi:**
    *   $$L(R_1 \cup R_2) = L(R_1) \cup L(R_2)$$
    *   $$L(R_1 \cdot R_2) = L(R_1) \cdot L(R_2)$$
    *   $$L(R_1^*) = (L(R_1))^*$$

**Esempi:**
*   $$0^*10^*$$: descrive il linguaggio delle stringhe binarie che contengono esattamente un '1'.
*   $$\Sigma^*1\Sigma^*$$ (dove $$\Sigma = \{0, 1\}$$): descrive le stringhe che contengono almeno un '1'.
*   $$\Sigma^*001\Sigma^*$$: descrive le stringhe che contengono la sottostringa `001`.

#### Equivalenza tra Espressioni Regolari e Linguaggi Regolari

Il punto focale è il seguente teorema fondamentale, che unifica i due mondi.

**Teorema di Kleene:** Un linguaggio è regolare se e solo se può essere descritto da un'espressione regolare.

Questo significa che la classe dei linguaggi generati dalle espressioni regolari coincide esattamente con la classe REG.

**Dimostrazione (schema)**

La prova si articola in due direzioni:

1.  **Se un linguaggio è descritto da un'espressione regolare, allora è regolare.**
    Questa direzione è la più semplice. Si dimostra per induzione sulla struttura dell'espressione regolare $$R$$.
    *   **Casi base:** È facile costruire NFA per i linguaggi $$\emptyset$$, $$\{\epsilon\}$$ e $$\{a\}$$.
    *   **Passo induttivo:** Assumiamo che per le espressioni regolari $$R_1$$ e $$R_2$$ esistano degli NFA che riconoscono $$L(R_1)$$ e $$L(R_2)$$. Poiché abbiamo già dimostrato che i linguaggi regolari sono chiusi rispetto a unione, concatenazione e stella, possiamo usare le costruzioni viste in precedenza per creare NFA per $$L(R_1 \cup R_2)$$, $$L(R_1 \cdot R_2)$$ e $$L(R_1^*)$$.

2.  **Se un linguaggio è regolare, allora può essere descritto da un'espressione regolare.**
    Questa direzione è più laboriosa. Partendo da un DFA che riconosce il linguaggio, dobbiamo costruire un'espressione regolare equivalente. L'idea è quella di generalizzare il concetto di automa per permettere alle etichette sulle transizioni di essere espressioni regolari, per poi ridurre progressivamente l'automa fino a ottenere una singola espressione regolare che descrive tutti i percorsi dallo stato iniziale a quello finale.

Vedremo questa costruzione in dettaglio nella prossima lezione.