# Lezione 06
Continuiamo con alcuni esercizi per consolidare i concetti sui linguaggi regolari.
#### 1. Progettare un Automa per Stringhe che Terminano in `00`
**Problema:** Progettare un automa per il linguaggio $$L = \{w \in \{0,1\}^* \mid w \text{ termina con } 00\}$$.

**Soluzione (con NFA):**
Possiamo utilizzare un automa non deterministico, che si presta bene a questo tipo di problema.
L'idea è che l'automa rimanga in uno stato iniziale leggendo qualsiasi simbolo. Quando legge uno '0', il non-determinismo gli permette di "indovinare" se quello è l'inizio della sequenza finale '00'.

*   **$$q_0$$ (Stato iniziale):** L'automa rimane in $$q_0$$ leggendo `0` o `1`. Quando legge `0`, un ramo della computazione rimane in $$q_0$$, mentre un altro si sposta in $$q_1$$.
*   **$$q_1$$:** Da qui, se l'input è `0`, si passa a $$q_2$$.
*   **$$q_2$$ (Stato finale):** Se la stringa termina qui, viene accettata.

**Correttezza:**
Per dimostrare la correttezza, dobbiamo verificare che $$w \in L \iff M \text{ accetta } w$$.
*   **($$\Rightarrow$$) Se $$w \in L$$, allora $$w$$ ha la forma $$w'00$$.** Esiste un percorso di computazione in cui l'automa rimane in $$q_0$$ per tutta la lettura di $$w'$$ (il ramo che rimane sempre in $$q_0$$). Sugli ultimi due caratteri, l'automa segue il percorso $$q_0 \xrightarrow{0} q_1 \xrightarrow{0} q_2$$. Poiché la stringa termina e l'automa è in $$q_2$$, la stringa viene accettata.
*   **($$\Leftarrow$$) Se $$M$$ accetta $$w$$, allora esiste un ramo di computazione che termina in $$q_2$$.** Per ispezione del diagramma, l'unico modo per raggiungere lo stato finale $$q_2$$ è attraverso una sequenza di input che termina esattamente con `00`. Pertanto, $$w$$ deve terminare con `00`, e quindi $$w \in L$$.

#### 2. Progettare un Automa con 3 Stati
**Problema:** Progettare un automa con al più 3 stati per il linguaggio descritto dall'espressione regolare $$R = (1^* (001^+)^*)^*$$

**Soluzione (con NFA):**
Analizziamo l'espressione regolare:
*   Lo star più esterno `(...)*` e lo star interno `1*` implicano che la stringa vuota $$\epsilon$$ appartiene al linguaggio. Quindi, lo stato iniziale deve essere anche finale.
*   `1*`: l'automa deve accettare qualsiasi numero di `1`.
*   `(001^+)^*`: l'automa deve accettare zero o più ripetizioni di blocchi `00` seguiti da uno o più `1` (`1^+`).

Un NFA a 3 stati può essere costruito come segue:
*   **$$q_0$$ (Stato iniziale e finale):** Accetta $$\epsilon$$ e le stringhe che terminano correttamente. Con input `1`, rimane in $$q_0$$. Con input `0`, passa a $$q_1$$.
*   **$$q_1$$:** Da qui, con input `0`, passa a $$q_2$$.
*   **$$q_2$$:** Da qui, con input `1`, si torna a $$q_0$$, completando il ciclo `001`. Poiché la parte dell'espressione è `1^+`, da $$q_2$$ si può anche rimanere in $$q_2$$ leggendo altri `1` (anche se con 3 stati questa opzione non è necessaria, si può usare il loop in `q0`). La transizione da `q2` a `q0` con `1` è sufficiente a catturare `001^+` grazie al loop `1*` in `q0`.

Se l'automa riceve `000`, ad esempio, da `q0` va in `q1`, poi in `q2`, e al terzo `0` la computazione muore, rifiutando correttamente la stringa.

#### 3. Chiusura rispetto al Rovesciamento
**Problema:** Sia $$L$$ un linguaggio regolare. Mostrare che anche $$L^R = \{w^R \mid w \in L\}$$ (il linguaggio delle parole rovesciate) è regolare.

**Idea della soluzione:**
L'idea è di partire da un NFA $$N$$ che riconosce $$L$$ e costruire un nuovo NFA $$N^R$$:
1.  **Invertire tutti gli archi** di $$N$$.
2.  Lo **stato finale** di $$N$$ diventa lo **stato iniziale** di $$N^R$$.
3.  Lo **stato iniziale** di $$N$$ diventa lo **stato finale** di $$N^R$$.

Se $$N$$ ha più stati finali, si può prima trasformarlo (senza perdita di generalità) in un NFA equivalente con un unico stato finale, per poi applicare la procedura. Questo nuovo automa $$N^R$$ accetterà una parola se e solo se l'automa originale l'avrebbe accettata letta al contrario.

#### 4. Costruire un DFA usando il Complemento
**Problema:** Costruire un DFA per $$L = \{w \in \{0,1\}^* \mid w \notin (01^+)^*\}$$.

**Idea della soluzione:**
Il problema chiede di riconoscere il complemento del linguaggio $$(01^+)^*$$. Sfruttiamo la proprietà di chiusura dei linguaggi regolari rispetto al complemento.
1.  **Costruire un DFA per $$(01^+)^*$$:**
    Questo linguaggio contiene la stringa vuota e concatenazioni di blocchi `0` seguito da uno o più `1`.
2.  **Rendere il DFA completo:** La procedura di complemento (scambiare stati finali e non-finali) funziona correttamente solo se il DFA è **completo**, ovvero se la funzione di transizione è definita per ogni stato e ogni simbolo di input. Se mancano delle transizioni (es. cosa fare se una stringa inizia con '1'?), bisogna prima completare il DFA aggiungendo uno **stato pozzo** (o *trap state*) non accettante, dove convergono tutte le transizioni "illegali".
3.  **Applicare il complemento:** Una volta ottenuto il DFA completo, si scambiano gli stati finali con i non-finali (incluso lo stato pozzo, che diventerà accettante) per ottenere l'automa per il complemento.

Questa procedura garantisce che tutte le stringhe non appartenenti al linguaggio originale (come quelle che iniziano con '1', o che contengono '00', etc.) vengano correttamente accettate dal nuovo DFA.

#### 5. Esercizi sul Pumping Lemma

**a) Provare che $$L = \{ww^R \mid w \in \{0,1\}^*\}$$ non è regolare.**
*   Assumiamo per contraddizione che $$L$$ sia regolare. Esiste una lunghezza di pompaggio $$p$$.
*   Scegliamo la stringa $$w = 0^p110^p$$. Questa stringa è in $$L$$ (è un palindromo) e $$|w| = 2p+2 \ge p$$.
*   Per il Pumping Lemma, $$w$$ può essere scomposta in $$xyz$$ con $$|y|>0$$ e $$|xy| \le p$$.
*   Poiché $$|xy| \le p$$, sia $$x$$ che $$y$$ devono essere composti solo da '0' (la parte iniziale della stringa). Sia $$y = 0^l$$ con $$l > 0$$.
*   Consideriamo la stringa pompata con $$i=2$$: $$xy^2z$$. La stringa avrà la forma $$0^{p+l}110^p$$.
*   Questa nuova stringa non è un palindromo, poiché la prima metà non è più l'inversa della seconda. Quindi, $$xy^2z \notin L$$.
*   Abbiamo trovato una contraddizione. Pertanto, $$L$$ non è regolare.

**b) Provare che $$L = \{1^{n^2} \mid n \ge 0\}$$ non è regolare.**
*   Assumiamo che $$L$$ sia regolare e sia $$p$$ la lunghezza di pompaggio.
*   Scegliamo la stringa $$w = 1^{p^2}$$. $$w \in L$$ e $$|w| = p^2 \ge p$$ (per $$p \ge 1$$).
*   Scomponiamo $$w$$ in $$xyz$$ con $$|y|>0$$ e $$|xy| \le p$$. La sottostringa $$y$$ sarà della forma $$1^l$$, con $$1 \le l \le p$$.
*   Consideriamo la stringa pompata $$xy^2z$$. La sua lunghezza è $$|xy^2z| = |xyz| + |y| = p^2 + l$$.
*   Perché questa stringa sia in $$L$$, la sua lunghezza deve essere un quadrato perfetto.
*   Sappiamo che $$1 \le l \le p$$. Analizziamo gli estremi:
    *   $$p^2 < p^2 + l$$ (poiché $$l \ge 1$$)
    *   $$p^2 + l \le p^2 + p$$ (poiché $$l \le p$$)
*   Il quadrato perfetto successivo a $$p^2$$ è $$(p+1)^2 = p^2 + 2p + 1$$.
*   Poiché $$p \ge 1$$, abbiamo $$p^2 + p < p^2 + 2p + 1$$.
*   Quindi, la lunghezza della stringa pompata si trova strettamente tra due quadrati perfetti consecutivi: $$p^2 < |xy^2z| < (p+1)^2$$.
*   Ne consegue che $$|xy^2z|$$ non può essere un quadrato perfetto, e quindi $$xy^2z \notin L$$.
*   Abbiamo trovato una contraddizione. Pertanto, $$L$$ non è regolare.

---

### Grammatiche Context-Free (CFG)

Abbiamo visto che i linguaggi regolari hanno dei limiti. Per superare questi limiti, introduciamo un modello di computazione più potente: le **grammatiche context-free (CFG)**.

Le CFG sono fondamentali in informatica, specialmente per la definizione della sintassi dei linguaggi di programmazione e la costruzione dei parser nei compilatori.

#### Intuizione: Generare Linguaggi
Una grammatica è un insieme di **regole di sostituzione (o produzione)** che permettono di generare le stringhe di un linguaggio.

**Esempio:** Consideriamo il linguaggio non regolare $$L = \{0^n1^n \mid n \ge 0\}$$. Una grammatica per una variante di questo, $$L' = \{0^n\#1^n \mid n \ge 0\}$$, potrebbe essere:
1.  $$A \to 0A1$$
2.  $$A \to B$$
3.  $$B \to \#$$

*   **Variabili (o non-terminali):** Simboli che possono essere sostituiti (es. $$A, B$$).
*   **Terminali:** Simboli dell'alfabeto finale (es. $$0, 1, \#$$).
*   **Regole:** Definiscono come una variabile può essere riscritta.
*   **Variabile iniziale:** Il punto di partenza del processo (es. $$A$$).

Il processo di **derivazione** parte dalla variabile iniziale e applica le regole fino a ottenere una stringa di soli terminali. Esempio:
$$ A \Rightarrow 0A1 \Rightarrow 00A11 \Rightarrow 00B11 \Rightarrow 00\#11 $$
Questa grammatica genera il linguaggio $$L'$$. La sua capacità di "ricordare" e bilanciare il numero di 0 e 1 deriva dalla sua struttura ricorsiva, superando il limite della memoria finita di un DFA.

#### Definizione Formale di una CFG

Una grammatica context-free è una tupla di 4 elementi: $$G = (V, \Sigma, R, S)$$
1.  $$V$$: un insieme finito di **variabili**.
2.  $$\Sigma$$: un insieme finito di **terminali** (l'alfabeto), con $$V \cap \Sigma = \emptyset$$.
3.  $$R$$: un insieme finito di **regole**, della forma $$A \to w$$, con $$A \in V$$ e $$w \in (V \cup \Sigma)^*$$ (una sequenza di variabili e terminali).
4.  $$S \in V$$: la **variabile iniziale**.

#### Derivazione e Linguaggio
*   **Derivazione in un passo ($$\Rightarrow$$):** $$uAv$$ produce $$uwv$$ se $$A \to w$$ è una regola.
*   **Derivazione in più passi ($$\Rightarrow^*$$):** $$u$$ deriva $$v$$ se esiste una sequenza di zero o più derivazioni in un passo che trasforma $$u$$ in $$v$$.
*   **Linguaggio di una grammatica $$L(G)$$: ** È l'insieme di tutte le stringhe di terminali derivabili dalla variabile iniziale:
    $$ L(G) = \{ w \in \Sigma^* \mid S \Rightarrow^* w \} $$

#### Esempi di Grammatiche
*   **Espressioni aritmetiche:**
    $$ E \to E+E \mid E \times E \mid (E) \mid 0 \mid 1 \mid \dots \mid 9 $$
    Questa grammatica può generare stringhe come `3+4*4`.
*   **Parentesi bilanciate:**
    $$ S \to aSb \mid SS \mid \epsilon $$
    Se $$a=( , b=)$$, genera tutte le sequenze di parentesi correttamente annidate.

#### Tecniche per la Progettazione di Grammatiche
1.  **Unione:** Combinare grammatiche per creare il linguaggio unione.
2.  **Da DFA a CFG:** Esiste un metodo per convertire ogni DFA in una CFG equivalente, dimostrando che i linguaggi context-free sono un soprainsieme dei linguaggi regolari.
3.  **Ricorsione:** Sfruttare la natura ricorsiva delle regole per definire pattern ripetitivi e annidati.

Nella prossima lezione, esploreremo più a fondo le proprietà delle CFG e la loro relazione con gli automi a pila.