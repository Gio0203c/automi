# Lezione 06
Lo faresti anche con questo? Abbiamo considerato quindi, fissato un alfabeto SIGMA, il linguaggio, tutti i linguaggi che sono possibili, che è possibile definire usando espressioni regolari su quei linguaggi. Ok? Le espressioni regolari usano l'unione, la concranizzazione e l'operazione star, in maniera ricorsiva. Quindi abbiamo, diciamo, il caso base, no? Dove ci sono, cioè, l'insieme vuoto, la stringa vuota e il singolo carattere, uno per ogni possibile carattere di alfabeto, sono il caso base di un'espressione regolare.  
Sono, diciamo, i casi dei generi, no? E poi, in maniera induttiva, un'espressione regolare è semplicemente o l'unione di espressioni regolari, o la concranizzazione di espressioni regolari, o un'espressione regolare elevata a star, no? Questo è un modo ricorsivo per definire espressioni regolari. E ovviamente, diciamo, i linguaggi si definiscono in maniera analoga. Quindi ci sono i casi in cui il linguaggio è associato a espressioni regolari,  
e quindi ci sono le stringhe che possono essere generate a partire da quell'espressione regolare, no? E quindi, di fatto, se l'espressione regolare è vuota, il linguaggio è vuoto. Se l'espressione regolare è il carattere, la stringa vuota, il linguaggio regolare è quello che contiene solamente la stringa vuota. Se l'espressione regolare è un singolo carattere, il linguaggio regolare è l'insieme che contiene solo due carattere. E nel caso ricorsivo, se c'è un'espressione regolare, l'unione di espressioni regolari,  
l'unione dei linguaggi associati a quelle espressioni regolari. Questo ti permette ricorsivamente, no? Di andare a metterci tutti gli elementi dentro, va bene? E abbiamo visto a pensare tanti esempi, no? Cioè, abbiamo visto degli esempi di linguaggi che sono generali a partire da espressioni regolari, va bene? Ok, adesso una cosa fondamentale che volevamo dimostrare oggi era questa, che di fatto le espressioni regolari altro non sono che i linguaggi regolari, cioè è sempre la stessa cosa.  
Ok? Quindi c'è un'equivalenza, cioè un linguaggio regolare, regolare come abbiamo definito nelle scorse lezioni, ovvero un linguaggio regolare se esiste un DFA che lo riconosce, no? Ma questo è vero se e solo se esiste a sua volta un'espressione regolare che descrive quel linguaggio. Cioè, quindi c'è un'equivalenza, cioè posso prendere un linguaggio e se questo è riconosciuto da un DFA, posso derivare l'espressione regolare associata a quel linguaggio, prima direzione. Seconda direzione, se un linguaggio è descritto a partire da un'espressione regolare,  
il DFA che riconosce quel linguaggio, queste due cose sono equivalenti, ok? Ok, questo è quello che vogliamo dimostrare oggi, va bene? Vogliamo dimostrare questo teorema, no? Sono due direzioni, due direzioni, e la più facile, la prima, e anche la più semplice, diciamo, se vogliamo, è qui un lemma, ci possiamo mettere,  
da parte, è che, diciamo, come lo chiamavo sopra, LRE, LRE è contenuto in REG, ok? Cioè, quindi, se un linguaggio è descrivibile a partire dall'espressione regolare, allora esiste un DFA che lo riconosce, ok? Quindi questo è il, quindi dato, in questo caso,  
diciamo, data, espressione regolare R, ok? Costruisco, costruisco, per dimostrare questo, un DFA, un NFA, è buono, barra DFA, tale che è, è DFA, diciamo, che è un N, NDR, no? Tale che è L di NDR,  
è proprio uguale al linguaggio associato ad L, ok? Cioè, quindi, espressione regolare R, cioè il linguaggio associato a quell'espressione regolare L, LDR, ok? Che cosa devo fare per far vedere che L di RE, il linguaggio di tutte le espressioni regolari su un certo alfabeto, è contenuto dentro REG? Vabbè, prendo una qualsiasi espressione regolare, vedo quel linguaggio e faccio vedere che esiste un NFA che riconosce lo stesso linguaggio, ok? Quindi devo andare da,  
espressioni regolari a NFA, ok? L'altro caso sarà, partirò dall'NFA e devo derivare l'espressione regolare, ok? Quindi ci sono due direzioni. Per farlo, diciamo, ci aiuta, ci aiuta la definizione ricorsiva che abbiamo,  
considerata, ok? Cioè, la definizione ricorsiva ci permette proprio di fare questo in maniera molto semplice, cioè, da una parte avremo il caso base, no? Cioè, R è un'espressione regolare, ok? Ma sappiamo che l'espressione regolare può essere o un caso base o un caso induttivo, no? Giusto? Quindi, in maniera ricorsiva possiamo anche definire l'NFA associato a che riconosce lo stesso linguaggio. Cioè, nel caso base avremo, no? Diversi casi, no?  
Nel caso base avremo il caso in cui, per esempio, R uguale A con A in sigma, no? Questo è uno dei casi della definizione di, è uno dei casi che riguardano la definizione di linguaggio associato a espressioni regolari, no? Erano tre, cioè la stringa vuota, insieme vuoto e singolo carattere, ok? Quindi, se l'espressione regolare è un singolo carattere, ok? Il linguaggio associato a quella espressione  
regolare è il linguaggio che consiste di un singolo carattere. Tutto quello che devo fare è fare un NFA che accetta il singolo carattere, ok? Quindi, come faccio a fare un NFA che accetta il singolo carattere? Sarà fatto così. Giusto? Cioè, sarà fatto così, no? Cioè, c'è ora, se vuoi, lo posso, diciamo, definire in maniera  
più precisa, no? Cioè, posso dire che sarà fatto da, insieme gli stati, che sarà Q1 e Q2, sigma è sigma, c'è ora una delta, c'è ora uno stato iniziale Q1 e c'è ora uno stato finale che è fatto solo da Q1. Questa è, diciamo, Q1, questa è Q2, ok? Quindi, c'ha due stati, alfabeto sigma, la delta è Q1,  
ancora devo definire Q1 è lo stato iniziale e Q2 è l'unico stato accettante. E devo definire la delta, cioè delta di, diciamo, Q1, A è uguale a Q2. E delta di Q, B, questo è sempre uguale a ruoto, se Q è diverso da Q1, B è diverso da A.  
Ok? Cioè, tutte, l'unica freccia che ho messo è quella là, perché significa che tutte le altre frecce sono associate col vuoto. Ok? Perché deve accettare solo il carattere A. Ok? Quindi, la NFA di figura accetta solo il carattere A. Qualsiasi altra cosa che dà in input, non accetta. Va bene? Ci siamo? Finora?  
L'altro caso è R uguale a epsilon, eppure questo è facile, no? Cioè, R uguale a epsilon, c'è un automa che comincia così, start, e poi deve accettare epsilon. Basta, finisce qua. NR sarà, diciamo, Q1, quindi solo Q1, Q1 è l'insieme di stati.  
E poi c'è Q1, è l'insieme di stati accettate, e poi c'è la delta di QB, questa è uguale a ruoto. Quando Q è diverso da Q1, beh, non c'è solo Q1, deve finire solo la delta di Q1. Q1, B. Questo è per ogni B appartenente al sistema.  
Ok? Cioè, qualsiasi sia B, va in vuoto, no? Però, quando legge la stringa vuota, accetta. Perché inizia, sta in Q1, stringa vuota, accetta. Ok? Quindi questo è un NFA che chiaramente riconosce epsilon. Ok? Questo riconosce epsilon. Vabbè, e l'ultimo è quello che deve riconoscere, non deve accettare mai, no?  
Questo non accetta mai. È fatto così. Questo è l'NFA che non accetta mai. Q1, sigma, delta, Q1, vuoto. E... va bene? Vabbè, delta, Q1,  
B, è vuoto. Per ogni B appartenente al sistema. Ok? Solo che adesso lo stato Q1 non è accettato. Così non accetta mai. Neanche la stringa vuota. Ok? Allora, quindi questi erano i casi, diciamo, base, no? Cioè, è chiaro che se l'espressione regolare è uno dei casi in base, ovviamente è facile fare degli NFA che riconoscono il linguaggio associato a quelle  
espressioni regolari. Sono questi tre che abbiamo visto. Ok? Poi c'è il caso induttivo. Ok? Ma il caso induttivo pure è facile perché abbiamo già studiato linguaggi regolari. Cioè, che possiamo dire sul caso induttivo? Possiamo dire che sappiamo che nel caso induttivo un'espressione regolare o è l'unione di espressioni regolari o è la concatenazione o è lo star. Il linguaggio associato al... il linguaggio associato al caso induttivo sarà l'unione dei linguaggi,  
la concatenazione dei linguaggi o lo star del linguaggio. Vabbè, ma già sappiamo che però... già sappiamo che però se abbiamo l'unione di due linguaggi, no? Allora, tutto quello che dobbiamo fare è fare l'unione dei DFA, diciamo. Cioè, la classe dei linguaggi regolari è chiusa rispetto a tutte queste operazioni. Ok? Cioè, quindi... Poi più avremo qualità. Cioè, se R è uguale a R1 unito a R2,  
ok? E... diciamo, per induzione, no? Per induzione avremo che... Ok, cioè, quindi come se lo sto costruendo per induzione questo NFA, no? Ok? Cioè, sto dicendo questo è il caso base, no? Ok? Supponiamo che quindi adesso ho due espressioni regolari che per induzione sono regolari, cioè sono riconosciute da DFA. Per induzione avremo  
che esistono M1, M2, tale che M1... L di M1 è proprio uguale a L di R1 e L di M2 è proprio uguale a L di R2, no? Ok? Cioè, ovvero L di R1 e L di R2 sono linguaggi regolari. Allora sappiamo che esiste M per la chiusura, questa è per la chiusura, esiste M  
tale che L di M è uguale a L di R1 unito L di R2. Questa è per la chiusura. Questa è per la chiusura. Ok? Cioè, per la chiusura di reg... Per la chiusura di reg... E... sappiamo che... Questo è vero, no? Ok? Cioè, quindi lo sto facendo per induzione, no? Cioè, assumiamo che R1 e R2 siano espressioni regolari,  
ok? Che hanno associato un... che sono riconosciute da DFA. Ok? Allora è vero anche per la loro unione. Ok? Quindi siccome sono partito dal caso base, no? E poi il caso induttivo è soltanto un'unione di... un po' partita dal caso base, posso usare l'induzione, no? Per dire che quindi se le due espressioni regolari sono regolari,  
sono riconosciute da DFA, allora anche la loro unione lo è. Stessa cosa per... stesso discorso... per... concatenazione e per star. Ok? Ha senso? Vediamo se... faccio vedere un esempio di questa cosa.  
Ok? Va bene? Questo conclude, diciamo, la dimostrazione del lemma. Ok? Usando praticamente l'induzione. Cioè, questo ci dà un modo induttivo, ricorsivo, per... definire... definire... un NFA a partire da un'espressione regolare. Cioè, partiamo dai casi base, e poi ci daranno le unioni, le concatenazioni, le star, e consideriamo...  
il modo canonico che abbiamo studiato per fare concatenazione, unione e star. Ok? Vediamo un esempio, così lo... lo... esempio chiarificatore, cioè che lo, diciamo, concretizza... esempio, ok? Cioè, interrompiamo un attimo il flusso della dimostrazione e facciamo un esempio. Ad esempio, prendiamo questa espressione regolare. AB unito a star. Ok? Trovare...  
NFA... corrispondente. Vediamo, io saprei qual è l'NFA che corrisponde a questo, ok? Allora, faccio questo, cioè, vedi? Cioè, quello che devo fare è semplicemente applicare la stessa logica che ho applicato nella dimostrazione. Cioè, dovrò fare... c'ho l'NFA che riconosce solo A. Poi c'ho l'NFA che riconosce solo B. Ah, poi posso fare l'NFA che riconosce la concatenazione tra A e B. Poi posso fare l'NFA che riconosce l'unione tra...  
La concatenazione tra B e A. Poi posso fare l'NFA che riconosce AB unito a star. Ok? Uso la ricorsione. Esattamente quello che abbiamo fatto nella prova del teorema. Ok? Cioè, quindi, allora, A... Questo è... Quello che riconosce solo A, abbiamo detto, è fatto così, no? Poi c'è quello che riconosce solo B, che è fatto così. Giusto?  
Queste erano le due basi, no? Poi, qual è quello che riconosce AB? Quello che riconosce AB è quello che, se vi ricordate, faceva questa cosa qua, no? A, questo stato qui non è più finale, c'è l'epsilonarco, no? E ricominci da quell'altro. Vi ricordate questo, no? Cioè, questo è come abbiamo costruito l'NFA per la concatenazione, no? Per fare la concatenazione di A e B, no? Quello deve... Il stato finale del primo,  
non sarà più accettante, no? Perché altrimenti deve accettare solo A e B, non può accettare solo A. E quindi, con un epsilonarco vai a quell'altro, no? Vi ricordate questo? Era il modo in cui abbiamo concatenato due NFA. Esattamente, sì. Non ricordo il significato dell'epsilonarco. Questa è una domanda filosofica, adesso. L'epsilonarco, cioè, stiamo facendo linguaggi regolari, no? Abbiamo visto linguaggi regolari, è equivalente a dire che sono riconosciuti  
da DFA o da NFA, ok? L'epsilonarco sarebbe il non determinismo, no? Cioè il fatto che quando lei sta in uno stato può andare a finire in tanti stati. In particolare, può farlo anche se non legge niente. Cioè, quindi, un NFA può splitare la sua computazione e quando sta in quello stato lì, c'è un'altra copia della computazione che va anche in quell'altro stato, in contemporanea. Ok? Sta esplorando diversi rami di computazione contemporanea, anche se non legge nulla. Quello è l'epsilonarco. Ok?  
Sicuramente non è che serve, ok? Cioè, adesso, lei probabilmente mi può dare, mi potrebbe dare un NFA che riconosce AB e che non usa l'epsilonarco. Questo è sicuramente possibile, ma io sto applicando la cosa in maniera cieca, ok? Cioè, sto applicando esattamente l'NFA che abbiamo visto nella dimostrazione della concatenazione. E questo funziona sempre. Boh, adesso lei dice, nel caso AB posso semplificare. Sì, va bene, ok? Però, in generale, io le sto dando una ricetta che invece funziona sempre, ok?  
Va bene? Questa è la differenza. Ok? Quindi questo è AB, no? E... Poi abbiamo AB unito A. Ok? Vi ricordate AB unito A? AB unito A era questo. L'abbiamo visto, no? Cioè, abbiamo visto che aggiungi lo stato iniziale, poi ci fai due epsilonarchi che vanno sullo stato iniziale dei due NFA. Vi ricordate questo? Quindi il primo sarà questo adesso, quello di sopra, praticamente. A, epsilon,  
B. Cioè, ho copiato quello di sopra. Il secondo sarà quello che riconosce solo A. Cioè, quello là, allineato a sinistra. Cioè, quello che fa così. Giusto? Cioè, ho applicato l'unione di due NFA. Sappiamo che l'unione di due NFA si fa così. Stato nuovo iniziale, epsilon arco epsilon. No? Ecco, esattamente quello che abbiamo usato nella dimostrazione della chiusura.  
Ok? Adesso faccio due... Mi manca solo di fare lo stato. Praticamente, eh? Cioè, devo fare AB unito A. Stato. Vabbè, allora devo fare quella roba dello stato, no? Cioè, la roba dello stato era così, no? Che inizia, poi c'è lo stato iniziale che è accettante, perché quando c'è lo stato devi accettare la stringa vuota. Giusto? Poi ripeti l'NFA di sopra. Lo riprendi. Epsilon, epsilon. Questo era quello che accettava solo A. Quindi faceva così. Giusto?  
Poi c'era quest'altro, invece, che era quello che prima legge A, poi non accetta, perché è quello della concatenazione. C'è l'epsilon arco, c'è lo stato iniziale dell'altro, poi legge B, e poi accetta. No? Era quello sopra, no? Adesso che devo fare per fare lo stato? Quando arrivo alla fine, devo ricominciare da inizio. Mi sono fatto qualcosa. Questo era lo stato iniziale.  
Di questo, no? Sì, c'era questo qua, esatto. Devo tornare qua, no? Eh? Vi ricordate? Cioè, ho applicato la ricetta dell'NFA per lo stato. L'ho fatto così.  
Ho aggiunto gli epsilon archi che dagli stati finali ritornano a quello stato lì. Va bene? E qua c'è un epsilon. Ok, non ho fatto altro che applicare ricorsivamente gli NFA che abbiamo usato nei... E questo vale sempre. Perché, appunto, ricorsivamente ogni espressione regolare è definibile a partire di un'unione, unione concatenazione e star di altre espressioni regolari. Cioè, sempre così. Qualsiasi espressione regolare.  
Quanto vuoi, la puoi sempre trasformare in un NFA. Perché lo stato è iniziale? Perché lo star contiene sempre la stringa vuota. Per definizione. Però poi noi abbiamo visto che è un arco con la stringa vuota. Perché? Questo significa che lui, se inizia e l'input è la stringa vuota, accetta. Ok? In parallelo.  
Però l'epsilon significa che è un altro ramo di computazione che sta in quell'altro stato e continua a leggere. Non vi dovete confondere tra epsilon che sta scritto sulla freccia e stringa vuota nell'input. Ok? E non è che se legge la stringa vuota allora fa l'epsilon arco. L'epsilon arco fa sempre. Ok? Ok? Cioè, perché è un ramo parallelo di computazione che inizia sempre. Ok? Tanto basta che ci sia un ramo di computazione che accetta per cui l'NFA accetta.  
Questo è proprio il non determinismo. Ok? Ok? Abbiamo visto la dimostrazione, abbiamo visto l'esempio. Tutto pulito. No? Ok? Adesso facciamo la seconda parte che invece è quella più complicata. Cioè un po' più... Un po' più... Ma è parecchio più complicata. Non super difficile, però un po' più complicata. Cioè quello che dobbiamo dire che è appunto l'altro verso.  
Cioè che è il ramo oppure è contenuto in L di R. L di R. Giusto? Cioè dall'altra direzione. Cioè ovvero adesso dobbiamo... Dobbiamo costruire un NFA a partire da... Dobbiamo... Scusate. Partiamo dall'NFA. Ok? Quindi abbiamo un NFA. In generale. Ok? E vogliamo avere...  
Una ricetta che ci prende l'NFA. Whatever it is. E ci spara l'espressione regolare che corrisponde all'ingaggio associato anche all'NFA. Ok? Vogliamo tradurre... NFA in espressione regolare. Ok? Quindi partiamo adesso da... Partiamo... Da... NFA. Partiamo dall'NFA. No?  
Per... L appartenente al ram, no? Cioè quindi prendiamo un linguaggio regolare, no? Ovvero... NFA... N chiamiamolo. L di N è uguale a L. Ok? Cioè prendiamo un qualsiasi linguaggio regolare. Allora c'è un NFA che lo riconosce. Chiamiamolo N. Ok? Adesso però trasformare questo NFA in una espressione regolare  
è una procedura che è abbastanza... Cioè complessa. Cioè non è proprio così... Immediata. Ok? Non è immediata. Va bene? Allora per facilitare diciamo questa cosa introduciamo una generalizzazione degli NFA. Ok? Cioè adesso generalizzeremo il modello di calcolo NFA in una maniera che ci permetterà di introdurre le espressioni regolari praticamente e di fare questa traduzione senza cambiare però ovviamente... Niente. Cioè senza cambiare il linguaggio. Ok? Stando attenti che la nostra generalizzazione  
non introduca cose nuove che non stanno nel linguaggio di partenza. Ok? Quindi per facilitare diciamo... Per facilitare la conversione in un'espressione regolare introduciamo un concetto. Introduciamo un concetto. Introduciamo quello che si chiama... Introduciamo l'NFA generalizzato.  
Che si chiama GNFA. Ok? Che cos'è questo NFA generalizzato? Primamente è come un NFA. Cioè c'ha gli stati iniziali, gli stati finali, c'ha gli stati in mezzo, eccetera. L'unica differenza di questo NFA generalizzato è che l'etichetta degli archi, che invece di essere singoli,  
singoli caratteri, sono espressioni regolari. Ok? Questo significa NFA generalizzato. Che significa NFA generalizzato? Le etichette degli archi saranno adesso saranno espressioni regolari. Ok?  
Tutto qua, cioè questa è tutta la cosa dell'NFA generalizzato. Cioè quindi, praticamente, la delta, la puoi vedere così, che prende... La delta, sì, prenderà due stati, cioè quelli che sono collegati ad un arco. Cioè lo stato iniziale, lo stato di partenza e lo stato di arrivo. E farà corrispondere a quest'arco un'espressione regolare.  
Che cos'è? È un insieme di stringhe. Sono tutte quelle stringhe che portano l'NFA dallo stato di partenza allo stato di arrivo. Tutto qua. Solo che le sto mettendo tutte insieme dentro un'etichetta. Ok? Cioè quindi faccio un esempio, no? Se io ho uno stato, no? Che mi dice, guarda, se vai... Se parti da qui e vai lì, quando leggi A, no? E d'altra parte, anche quando leggi B, fai la stessa cosa, allora io lo posso rappresentare con un'espressione regolare.  
Che corrisponde all'insieme, a B, no? Ok? Va bene? Cioè questa è l'idea, no? E l'idea sarà di... Quale sarà l'idea, quindi? Sarà... Tu parti da un NFA, ok? E all'inizio l'NFA, su ogni arco, ha un solo carattere. E quindi mette un'espressione regolare al posto del carattere. Praticamente è il caso base dei linguaggi regolari, delle espressioni regolari. È sempre possibile. Nel caso iniziale, no? Cioè perché tu prendi ogni arco e lo fai corrispondere all'espressione regolare.  
Il banale. Cioè solo un valore, no? Ok? Perché questo ti aiuta però? Perché adesso vedremo che c'è una procedura per togliere gli stati. Ok? Cioè quindi partiamo da un NFA gigantesco, ok? Che ha semplici espressioni regolari sugli archi, che sono ottenute, diciamo, dalle transizioni di partenza. E faremo vedere una ricessa che ti dice, ok, prendi uno stato e lo togli. Come lo togli? Cambiando le espressioni regolari che stanno sugli archi. Ok?  
Poi togli un altro stato, poi togli un altro stato, poi togli un altro stato. Alla fine rimani solo lo stato iniziale e lo stato finale e un arco che c'ha dentro l'espressione regolare che corrisponde al linguaggio. Ok? Questa è l'idea. È chiaro a tutti l'idea? Adesso la dobbiamo solo attuare, ok? Per attuarla ci sono delle accortezze, ok? Per fare questa cosa in maniera che funzioni dobbiamo seguire delle accortezze. Ok? Possiamo rivedere la nostra propria idea? Sì. Rivediamo l'idea. Tanto è solo l'idea, cioè ancora non ho fatto niente. Cioè sto dicendo quindi l'idea sarà questa.  
Dobbiamo, per trasformare un NFA, complicato quanto vogliamo, in espressioni regolari, prima lo generalizziamo. Come lo generalizziamo? Sostituendo alle sue etichette, tra gli stati e gli archi, delle espressioni regolari. Ok? Questo sarà facile all'inizio, cioè perché appunto ogni etichetta è solo un singolo simbolo, o un epsilon arco, no? Una cosa di questo tipo. Oppure c'è l'etichetta quota. Cioè se non c'è l'etichetta, se non c'è l'arco, è come se ci fosse insieme, sono solo tre casi, singolo carattere.  
E' proprio infatti la base della definizione ricorsiva di linguaggi di espressioni regolari. Quindi sicuramente, dato un NFA, posso etichettare all'inizio gli archi con espressioni regolari. Ok? Però non ho fatto niente finora. Ok? Se non che adesso l'ingrediente fondamentale di questa dimostrazione sarà una procedura, cioè un algoritmo, ok? Che ti permette di fare questo. Parti dall'NFA di partenza, scegli uno stato qualsiasi, che non sia quello iniziale o quello finale, ok? E lo togli.  
Ok? E lo potrai sempre togliere. Ci sarà un modo generico per toglierlo. Ok? Quando lo togli, però, non è che lo puoi togliere e basta, no? Cioè perché se lo togli potresti cambiare le stringhe che sono riconosciute dall'NFA, no? Cioè devi stare attento, quindi... Però l'NFA sarà costruito in modo che c'è sempre un modo per toglierlo, nel modo corretto, senza introdurre nuovi elementi e senza perdere elementi, no? E per farlo dovrai aggiornare le etichette relative a alcuni archi dell'NFA, in modo che non hai cambiato niente.  
Cioè questo sarà, diciamo, l'idea, ok? Siccome questa cosa la potrai fare ricorsivamente, cioè quindi ogni volta c'è una procedura che non cambia il linguaggio e ti toglie uno stato, alla fine arrivi e ti rimane soltanto stato iniziale, stato finale, freccia. E sopra questa freccia ci sarà scritta l'espressione regolare che corrisponde al linguaggio, ok? Questa è l'idea, ok? Dobbiamo solo attuare questa idea, ok? Per attuare questa idea, quindi, partiamo dall'NFA generalizzato, va bene?  
Però a questo non basta, ok? Lo dovremo mettere in una forma canonica, ok? Cioè dovremo fare delle assunzioni su questo NFA generalizzato, che saranno senza perdere generalità, ok? Cioè, in altre parole, ci metteremo in una posizione comoda che ci permette di fare la cosa che vi ho raccontato, cioè di avere un modo generico di prendere uno stato, togliere e non cambiare niente. Per fare questo, sempre nello stesso modo, e quindi per semplificare l'esposizione, è comodo assumere che l'NFA generalizzato  
sia in una forma canonica, ok? Canonica che tanto sarà senza perdere generalità, fin tanto che è senza perdere generalità, va bene, ovviamente, però ci consentirà di agire in maniera generica, cioè di non fare differenze, no? Perché altrimenti, che cosa succede? Quando tu prendi uno stato, tu cominci a considerare vari casi, cioè quello c'è l'allarco entrante, oppure c'è l'allarco in se stesso, oppure è collegato a quello stato, è collegato all'altro stato, ok? Questo, se complichere in quella,  
la nostra procedura ricorsiva, invece ci metteremo una forma canonica che ci permetterà di prendere uno stato e fa sempre la stessa cosa, ok? Per togliere. Questa è l'idea, ok? Quindi, gli archi saranno espressioni regolari. Inoltre, assumiamo, per adesso dico assumiamo, però in realtà non sarà un'assunzione, cioè sarà un'assunzione, sarà without loss of generality, ok? Come vi dirò tra poco.  
Assumiamo without loss of generality che il GNFA sia in forma canonica, ok? Che cos'è questa forma canonica? Allora, la forma canonica è questa, che è lo stato iniziale, per quanto riguarda lo stato iniziale, ha altri uscenti,  
ha solo archi uscenti, solo archi uscenti, uscenti, quindi non c'è niente che entra nello stato iniziale, ok? Ha solo archi uscenti verso tutti gli altri stati. Ok? Quindi questa è la prima cosa. Cioè, vi anticipo una cosa, diciamo, in che direzione sto andando. La direzione in cui sto andando è che la forma canonica è che ogni stato,  
cioè avrà una freccia con tutti gli altri stati, ok? Così non vi devo preoccupare di dire quello è collegato a quello, quello non è collegato a quello, no, sono tutti collegati, ok? In maniera generica, però. Senza differenziare, diciamo, quel singolo stato che posizioni c'è, con chi è collegato, sono tutti collegati con tutti. Without loss of generality, perché tanto se due stati non sono collegati, ci metto l'arco vuoto, ok? Cioè, quindi lo posso sempre fare, no? Per questo dico without loss of generality, ok?  
Per dire che tutti gli altri, tutti gli stati sono collegati, lo posso sempre fare. Aggiungo archi e ci metto vuoto, ok? Però questo mi permetterà di essere cieco, di non pensare dopo, ok? Quando faccio l'algoritmo, prendo uno stato, non è che mi devo chiedere, oh, ma con chi sta collegato questo stato? Con tutti, collegato con tutti, ok? Va bene, ok? Questo è, diciamo, quindi... Quindi, lo stato iniziale ha solo archi uscenti verso tutti gli altri stati, ok? Questo l'ho detto, ok?  
Il stato finale, invece, lo stato finale... Ha solo archi entranti, invece, va bene. Ha solo archi entranti. Ok? Ok. Detto questo, quindi, escludi adesso però lo stato finale,  
e iniziale. C'è un arco, c'è un arco per ogni coppia di stati. Ok? Dico esclusi stato iniziale e stato finale, perché ovviamente abbiamo detto, lo stato iniziale non c'è nessun arco entrante, cioè quindi non c'è un arco che vada dall'arco finale, dallo stato finale a quello iniziale, no?  
Assolutamente, sto dicendo, voglio fare in modo che lo stato iniziale ha solo archi uscenti, lo stato finale ha solo archi entranti, ok? Quindi no, questi sono esclusi. Però se tu prendi due stati qualsiasi, di questo GNFA, in forma canonica, c'è stato un arco che va da quello stato all'arco finale, ok? Cioè gli archi stanno... Prendi due qualsiasi stato, c'è un arco, ok? C'è l'arco e... Va bene?  
Ok, quindi questo ovviamente vale pure per lo stato in se stesso, ok? Cioè questo è il caso estremo, diciamo, coppia di stati, non ho detto coppia di stati distinti, ok? Ok? Pure coppia di stati di cui lo stato è lo stesso, cioè la freccia su se stesso è pure, vale, come coppia, ok? Ok, questo è tutto. Adesso diciamo, vi spiego perché questa cosa è senza perdere di generalità, ok? Cioè, dato un qualsiasi NFA, generalizzato, iniziale,  
diciamo, posso sempre metterlo in questa forma canonica senza aver perso niente, ok? Cioè tutto quello che devo fare è aggiungere le frecce, eventualmente aggiungere stati iniziali e finali in modo che non ci abbiano frecce riuscite entrate, insomma, è una cosa molto semplice. Quindi vediamo. Prima diciamo più precisamente, ok? Quindi, in pratica, io G, ok? G,  
GNFA, G, è uguale a Q, sigma, delta, chiamiamolo Q start, Q accept, ok? Q start è stato iniziale, Q accept è stato finale, e la delta, che fa, prende una coppia di stati, ora sarà così, sarà, diciamo, Q accept,  
la delta semplicemente prende una coppia di stati e ti dà, quindi sto definendo la delta, prende una coppia di stati e ti dà un'espressione regolare. R insieme insieme espressioni regolari  
ok? Ok, quindi, che cosa fa la delta? Prende due stati, due stati qualsiasi, e ci associa un'espressione regolare sull'arco, ok? Ho messo come stati, ho messo Q meno Q accept, perché Q accept non c'ha archi uscenti, ok? Per quello che c'è stato scritto Q meno Q accept, perché se no, se il primo stato fosse Q accept, vuol dire che ci sarebbe un'arco uscente da Q accept, ma non ci può essere, abbiamo detto, va bene? La stessa cosa, non ci può essere un'arco entrante in Q start,  
quindi c'è Q meno Q start, chiaro? Però, per tutte le altre coppie, ok? Va bene? Ma questo meno Q start non dovrebbe essere forse... Ho scritto al contrario? No, questo è bene. Q meno Q start, perché se qui, se la seconda elemento fosse Q start, vuol dire che ci sarebbe un'arco entrante in Q start, perché questa delta prende lo stato iniziale e lo stato finale e ci associa un'espressione regolare, quindi,  
se lo stato iniziale sta a destra, vuol dire che c'è un'arco entrante, se lo stato finale sta a sinistra, vuol dire che c'è un'arco uscente da Q accept, non si può fare, abbiamo detto che questo è escluso, va bene? Qual è la freccia? Qual è la freccia più lì? La R? Ah, R, sì, R, la R caligrafica, R caligrafica, ok? È l'insieme di tutte le espressioni regolari sostituite.  
Come l'abbiamo chiamato? R di sigma? R di sigma? L'abbiamo chiamato R di sigma? Non mi ricordo, forse l'abbiamo chiamato R di sigma. Però è uguale, cioè, sto dicendo, è un'espressione regolare che riguarda sigma, cioè su questo alfabeto sigma, ok? Ma abbiamo tolto Q start proprio per definizione, perché avete detto che ogni ogni stato ha una, cioè, ogni coppia di stati ha una ha un arco, proprio per quello l'abbiamo tolto per un'altra semantica esattamente? No, il motivo per cui,  
non c'è semplicemente Q per Q, ok? Cioè, quindi la delta com'è fatta? La delta è così, ok? Q per Q, espressione regolare, ok? Poi ci sono solo due eccezioni, però. La prima è che Q accept non può stare a sinistra, perché se Q accept fosse a sinistra della delta, vuol dire che ci sarebbe un arco uscente dallo stato accettato, che è lo stato a sinistra, è quello iniziale. Cioè, questa delta che fa? Prende il Q a sinistra, che è lo stato di partenza, e il Q a destra, che è lo stato di arrivo, e ci mette una freccia,  
espressione regolare. Però io ho detto, ho assunto, che Q accept non ci può avere archi uscenti, e quindi Q accept non può stare a sinistra della delta, perché se Q accept fosse a sinistra, vuol dire che ci sarebbe un arco uscente, ok? Stessa cosa, Q start non può avere una freccia entrante, e quindi Q start non può stare a destra della delta, ok? Tutto qua. Ok? Va bene.  
Ok. Ci siamo. E quindi, ok, perché questa è la forma canonica? Ok. Come faccio a metterlo in forma canonica? Cioè, perché la forma canonica è without loss of generali? Ok? Perché, che faccio? Posso sempre aggiungere,  
posso sempre aggiungere Q start, lo aggiungo, ok? Q accept, e gli archi mancanti tra ogni coppia di stati. Ok? Cioè, come farò a fare questo?  
Ok? Cioè, quindi che faccio? Semplicemente, cioè, se dovesse succedere, no? Per esempio, cioè, se dovesse succedere, adesso lo scrivo, lo scrivo con un esempio, se dovesse succedere, questo è il mio stato iniziale, no? Lo chiamiamo Q0, no? Ok, Q0 fa così, ok? Però c'è pure l'arco entrante.  
Aggiungo un altro stato e ci metto l'epsino A. Ok? Cioè, faccio così, Q start, epsilon A, positivo. Ok? Ho risolto. Adesso non c'è più l'arco entrante. Se dovesse succedere che l'NFA, cioè, tanti, l'NFA ci può avere tanti stati finali, no? E questi ci possono avere anche uscenti.  
Cioè, so. Vabbè, faccio così. Aggiungo Q accept. Questi li faccio diventare non più finali e metto l'epsino A. Ha senso? Adesso tutti, in tutti i casi in cui quello accettava prima, accetta pure mo. E qua accept non c'ha più uscenti.  
Solo l'arco entrante. Vi trovate? Simple enough? Ok? Se invece mi succediva che, te ne so, era così. Ok. Cioè, adesso sicuramente dovrò aggiungere  
in realtà mi basta fare così, no? Sì, supponiamo che era così. Ok? E qui c'è A. Qua ci metterò un voto. Ok? Qua ci metterò un voto. Qua ci metterò un voto. Non è cambiato niente. Ok? È lo stesso NFA. Ok? Però mi sono messo in una situazione canonica. Ok? Cioè, adesso tutti gli archi, se prendo uno stato  
qualsiasi, non mi devo andare a interrogare come è fatto questo NFA. Ma l'altro sta in forma canonica. Cioè, tutti gli stati sono uguali. Ok? Cioè, hanno frecce che vanno dappertutto. Sono tutti uguali. Ok? L'ho reso, diciamo, non lo so, uguale in ogni sua parte. Ok? Prendo uno stato qualsiasi e potrò dire quello stato, cioè, in particolare, in particolare la cosa sarà così. Cioè, quando dovrò rimuovere uno stato adesso? Rimuoverò uno stato innanzitutto.  
Che non sarà né uno stato iniziale né quello finale. Quindi mi voglio tenere alla fine. Rimuoverò uno stato qualsiasi. Ne prendo uno qualsiasi. Adesso, se io prendo quello stato, ok? E fisso ogni possibile coppia agli altri stati, ok? Potrò considerare in maniera canonica tutti i modi che ho per andare dal primo stato allo stato che voglio rimuovere e dal secondo stato allo stato che voglio rimuovere. Perché è canonico adesso. Cioè, ci può andare, ci può  
andare direttamente o passando per ogni altro stato. Praticamente. E anche, diciamo, rimanendo in se stesso. Cioè, sarà una... Siccome ci sono tutte queste frecce, le frecce sono tutte, adesso ci sarà un modo canonico per dire come faccio ad andare dallo stato QI allo stato QJ. Ok? Bene. Vediamo. Perfetto. Vabbè, fino adesso abbiamo definito, diciamo, quindi, se abbiamo una forma, il nostro NFA ha la forma generalizzata.  
Adesso siamo pronti per fare la conversione. Ok? Convertiamo. Ok? Siamo pronti per convertire... Siamo pronti per convertire G in espressione regolare. Ok? Lo facciamo in maniera induttiva o regolativa, diciamo. Con una procedura che chiamiamo convert di G. Ok?  
Convert di G sarà regolzia. E dice questa. Sia K uguale numero di stati in G. Ok? Allora, se K è 2, G avrà solo due stati. Avrà solo due stati. Stati che saranno Qstar,  
Qarset, e un singolo arco, arco con etichetta R appartenente a R. Output R. Ok? Cioè, quando sono arrivato alla fine, questo sarà quello che farò alla fine, se dovesse essere il caso che ci sono solo due stati,  
ok? Sicuramente questi saranno solamente Qstar e Qarset. Ok? E... Saranno solamente Qstar e Qarset. Ci sarà un arco che va solo da Qstar a Qarset. Perché Qstar non ha entranti, Qarset non ha entranti, quindi c'è solo uno stato. Solo un arco. E quell'arco ci avrà sovrascritta l'espressione regolare. Ok? Quella è l'espressione regolare che toglie Output. Ok? Va bene? Il resto degli altri casi sarà invece  
però a rimuovere uno stato, uno alla volta, mantenendo invariato il linguaggio. Ok? Cioè, quindi, da una parte dovrò prima dire come faccio e poi dovrò dimostrare che in questo mio procedere non mi stia perdendo niente passo dopo passo. Cioè, le stringhe che stanno nel linguaggio associato all'NFA generalizzato con K stati è lo stesso quando ci sono K-1 stati e poi K-2, poi K-3, poi K-4, fino a che non arriva a 2.  
E ho finito. Ok? Questa è la cosa. Ok? Quindi l'altro caso è quello che adesso devo togliere lo stato. K maggiore di 2. Allora scelgo uno stato. Ok? Qrip. Ok? Qrip è diverso da Qstart e è diverso da Qarset. Ok?  
Che stato scelgo? Non importa. Ok? Perché tutti gli stati sono uguali. Perché siamo in forma canonica. Ok? Questa è, diciamo, il motivo per cui abbiamo introdotto la forma canonica. Perché così non mi importa quale posso scegliere. Non ce n'è uno meglio di un altro. Ok? E a questo punto che faccio? Scelgo Qrip e definisco diciamo G'. Ok? G' è il nuovo G'  
che ci avrà questo nuovo G' sarà uguale a quell'altro senza Qrip praticamente. Cioè quindi sarà G' sarà Q' Sigma è lo stesso ovviamente. Delta' poi Qstart è lo stesso perché non riduco e Quarset è lo stesso perché non riduco. Ok? Cioè l'unica cosa che cambia di G' sarà l'insieme di stati e la delta. Ok? L'insieme di stati che sarà? Sarà quelli di prima meno Qrip. Cioè Qrip Q'  
sarà uguale a Q meno Qrip. Ok? Adesso devo definire la delta' primo. La delta' primo. Ok? E... Ok. La delta' primo che sarà? Come sarà fatta sta delta' primo?  
La delta' primo ricordiamoci sarà come questa. No? Cioè prenderà devo definire per tutti i possibili stati. Ok? Che stanno in ovviamente Q' no? Meno Q' e in Q' meno Qstart. Ok? Perché la delta definirà sempre in Q meno Qstart e Q meno Qstart. Quindi la delta' primo la delta' primo la delta' primo intanto andrà da Q' meno  
Q' abbiamo detto per Q' meno Qstart in R. Ok? Questa è la sua diciamo natura. E quindi come la definisco? Adesso la definisco così. Prendo un qualsiasi Q' appartenente a Q' meno Q' ok? Questo è il mio Q' quindi la delta' primo che prenderà  
in input. Vabbè prenderà in input Q' e Qj. E Q' sta in Q' meno Q' Qj sta appunto in Q' meno Qstart. Ok? E devo definire adesso la mia delta' primo di Q' Qj. Ok? Delta' primo di Q'  
se mi sposto così. Devo definire la mia delta' primo Ok? Devo definire questa. Ma come sarà la mia situazione però adesso? Perché siccome la NFA è in forma canonica la mia situazione sarà sempre questa che c'è Q' ok? C'è Qj  
Ok? Cioè se io prendo qualsiasi Q' e qualsiasi Qj che non sono Q' cioè non sono Qstart e qualsiasi altra cosa e come sarà fatta? Vabbè ma c'è una freccia tra ogni coppia di stati. Cioè chi so gli stati che entrano e escono in Q' cioè mi interessano solo quelli che escono. Cioè non è che li disegno tutti. Disegno solo quelli che riguardano Q' perché io Q' sto togliendo. Cioè lo tolgo le frecce che ci andavano dentro e che ci uscivano poi non ci stanno più e devo fare qualcosa. Quindi Q' c'è questa freccia c'è Q'  
poi c'è pure questa ok? poi c'è pure questa e poi c'è pure questa ok? Cioè queste frecce ci stanno no? Cioè in altre parole che sto dicendo che quali sono tutti i modi per andare da Q' quali sono tutti i modi per raggiungere Q' ok? Ci posso andare diciamo direttamente da Q' giusto?  
Ci posso andare direttamente da Q' ma ci posso anche andare ci posso anche andare passando per Q'  
e poi la risposta è  
deve essere così no? Ok no deve essere penso che sia così. Ma questo professore non ci sono tutte cioè su tutti questi quegli arti? Io sto voglio considerare soltanto gli arti che riguardano Q' ok? Cioè quelli che entrano e escono da Q'  
e poi ci sono anche le cose che si possono fare da Q' e poi ci sono anche le cose che si possono fare da Q'  
no però ok ok cioè quello che sto dicendo qua adesso io quello che sto definendo io sono tutti i modi da per andare da Q' a Q' ok? Cioè io sto definendo la delta primo di Q' ok? La delta primo di Q' riguarda tutti i modi per transitare da Q' a Q' ok? Quindi era giusta la freccia ok? Era giusta allora mi sto confondendo mi sto ragionando sul curriculum non devo ragionare sul curriculum ok? Io sto definendo la delta primo per andare da Q' a Q' la nuova delta prima ok? Alla metodologia  
devo chiedere nella vecchia situazione quali erano tutti i modi che c'avevo per andare da Q' a Q' ok? E quelle sono le frecce che ho disegnato riguardano soltanto la transizione da Q' a Q' l'altra freccia non mi interessa ok? Cioè per ogni possibile coppia di nodi Q' Q' io che cosa devo fare? Devo aggiornare le stringhe che mi mandano da Q' a Q' ok? Adesso siccome l'NFA è in forma canonica quali sono tutti i modi per andare da Q' a Q' sono  
direttamente questa è la freccia da cui affeggeri e passando per Q' ok? Queste sono le frecce che sono le uniche frecce che mi interessano ok? Professore le dispiace se mi ripete cos'è Q' Q' è un stato che voglio far riposare ok rimuoverlo ok ok ok ok ok ok  
Dallo stato Q' vado a Q' poi leggo qualcosa e rimango sempre in Q' e poi vado in Q' e quella lì adesso la devo tenere incontro No perché Q' seppure mi interessa mi interessa però il punto è che non devo fare niente su questa freccia cioè questa freccia esiste ma rimarrà nel mio GNFA ok? Cioè qui questo non è importante ovviamente c'è questa freccia ok?  
Ho disegnato tutte le frecce però sto disegnando solamente le frecce che mi portano da Q' a Q' e che riguardano Q' ok? Va bene? Va bene? Sì ovviamente se c'è la freccia che da Q' va in se stessa quella rimane ma non cambierà niente cioè non... Perché riguarderebbe Q' la freccia che va da Q' a Q'  
diciamo che però io sto considerando Q' e Q' e voglio dire che quella freccia lì la devo mantenere cioè sì cioè secondo me diciamo qual è il punto che cioè lei sta dicendo sto considerando quella da Q' a Q' allora ci potrei mettere pure questa e ci potrei mettere pure questa ok? Questo è vero no?  
Secondo me per come definire la ricorsione quello che gli succede è che quando poi lei rimuoverà Q' tanto dopo rimuove Q' allora Q' diventa Q' e quindi quella freccia la sta considerando semplicemente dopo capito? E semplicemente lo sto spostando se non lo considero esatto cioè questo è arbitrario in realtà io penso che infatti avrebbe potuto anche metterci quelle frecce e aver definito la conversione in maniera leggermente diversa se poi quelle frecce ovviamente non le considerava dopo ok? Però questo va bene così fatto così perché ripeto pure se ci sta quella freccia  
che da Q' va in se stesso a un certo punto Q' sarà Q' e quindi quella freccia la considererò dopo ok? Va bene quindi per adesso sto considerando queste frecce cioè poi tanto devo dimostrare che non me l'ho persa niente però va bene però diciamo ok? Cioè quindi la logica è questa prendo Q' e Q' sicuramente ci stanno queste frecce qua e poi sicuro questo è sicuro ok? Sicuro queste sono tutte le frecce che diciamo mi permettono  
di andare da Q' a Q' o direttamente o passando per Q' ok? Sto considerando queste ok? E queste le tolgo tutte adesso ok? Cioè le tolgo tutte lascio soltanto la freccia Q' e Q' ok? Questa freccia qua ci potrebbe essere ci sarà anzi questa freccia qua ci sarà va bene? E ovviamente cioè  
anche altre ma è pure questa freccia qua ci sarà no? Ok? Ma non mi interessano però ok? Non mi interessano perché io mi sto chiedendo adesso perché ovviamente quella freccia lì tratteggiata in basso mi interessa quando dovrò considerare le transizioni che mi portano da Q' a Q' ma io infatti questa cosa la devo fare per ogni Q' e per ogni Q' cioè quindi ci sarà pure il caso Q' da sinistra e Q' a destra ok? Lo sto prendendo per tutte le coppie è chiaro?  
Ok? Quindi non voglio overcomplicare la figura con tutte le frecce ok? Quelle che mi stanno interessando e che sto modificando sono quelle che mi portano da Q' a Q' o direttamente o passando per Q' ok? Perché sono queste quindi adesso come sono fatte queste frecce? Ce le saranno ce le saranno nelle relazioni cioè nelle espressioni regolari sopra ok? Perché abbiamo detto nel gen F' ogni freccia  
è un'espressione regolare quindi che significa? Come devo definire la mia delta? La devo definire come R1 no? Concatenato con R2 star concatenato con R3 e poi unito a R4 ok? Cioè perché vuol dire che posso andarci o direttamente quello sarebbe unito a R4 oppure passando per Q' cioè R1 qualsiasi ripetizione di R2 R3  
ok? Cioè dove R1 ovviamente è la delta di QI QRIP R2 è la delta di QRIP QRIP R3 è la delta di QRIP QJ e R4 è la delta di QI QJ  
ok? perché c'è un star sopra R2? perché perché siccome c'è la freccia che da QRIP va in se stessa quella l'espressione regolare di lei la può arrivare da quante volte vuole cioè se per esempio ci fosse l'espressione regolare di R2 fosse 0 allora quello quando legge 0 sta in QRIP ritorna in QRIP eh ma se legge 2 e 0 pure se legge 3 e 0 pure e poi lo legge star allora ok? star perché  
il fatto che R2 può essere vuota no? perché infatti non mi serve più forza R2 per andare a QJ posso fare soltanto R1 R3 questo è tenuto in conto dal fatto che c'è lo star e lo star contiene anche l'insieme la stringa vuota no? ok? ok? questo è ok? e diciamo è di fatto una convenzione il fatto che ho considerato solo queste frecce ma ripeto queste senza perdere generalità perché ogni altra freccia che ho tratteggiato verrà considerata quando cambierai  
gli altri stati o quando rimuoverrai uno degli altri stati ok? è tutto chiaro? cioè l'idea è abbastanza chiara cioè abbastanza semplice già adesso dimostrare che questa roba è corretta non è troppo difficile cioè richiede soltanto un po' di osservazione cioè di osservare che non ci stiamo perdendo niente quindi faccio questa cosa e ritorno in C1 cioè che faccio se K maggiore 2  
e scelgo QJ bla bla bla bla bla e poi faccio questa roba qui e dico ritorno in G1  
ma secondo me ritorno in G1 è sbagliato no, ritorno in G1 adesso lancio converte di G1 giusto? cioè se se K è maggiore di 2 ok? rimuovo lo stato definisco G1 e e  
converte di G1 vabbè perché nel caso K uguale 2 ho dato in output l'espressione regolare no? cioè quindi questo converte dovrebbe dare in output l'espressione regolare non lo so vabbè diciamo questa è non lo so adesso non so come sta scritto sul libro però è indifferente cioè potete dire che dà in output l'automa e poi per definire l'espressione regolare  
gli interrogo questa cosa prego certo vuole fare subito la pausa? o vuole finire questa questa dimostrazione? eh? facciamo una pausa? sì pausa? va bene  
ehm  
ok  
eh devo dimostrare che  
che converta di G è equivalente all'espressione è a è equivalente a G ok? cioè devo dimostrare che per ogni numero di stati qualsiasi sia il numero di stati di G ok?  
l'espressione regolare che è quello che ti tira fuori alla fine ok? eh questa è equivalente a è associata ad essa allo stesso linguaggio che era associato a G ok? questo devo dimostrare se ho dimostrato questo ho dimostrato che eh l'espressione regolare che ho tirato fuori è equivalente all'NFA di partenza ok? questo devo far vedere no? lo faccio siccome lo devo far vedere per ogni K lo faccio per induzione  
per ogni eh per K uguale 2 è vero è sicuramente vero ok? cioè perché se ci sono solo due stati no? c'è una sola freccia e quella freccia ha proprio tutte le stringhe che portano dallo stato iniziale a quello qui e quindi eh l'espressione regolare che ci sta che è associata a quella freccia è proprio tutte le stringhe che il NFA c'entra  
le parametri va bene? cioè quindi diciamo la stringa R la l'espressione regolare R l'espressione regolare F eh associate che scrive tutte le stringhe  
che portano G a A o A2 ok? devo dimostrare che quindi eh per K uguale 2 è sicuramente vero ok? adesso supponiamo vero per K meno uno stati  
e faccio vedere che è vero per K stati ok? ok? vabbè tutto quello che devo fare per fare questa cosa è che io parto dal mio G tutto quello che devo dimostrare è che che G' riconosce le stesse stringhe di G ok? se è vero che G'  
riconosce tutte le stringhe di G ho finito perché G' è la stessa cosa di G ma con uno stato in meno per l'ipotesi induttiva eh l'espressione regolare data in output usando G' è quella equivalente al linguaggio e quindi ho finito ok? basta mostrare che L di G è uguale a L di G' così  
la prova così la prova segue la diposita induttiva induttiva siccome numero di stati di G' K meno uno ok? cioè se per induzione la cosa è vera per K meno uno ok? cioè ovvero che per K meno uno converte di G'  
ti tira fuori l'espressione regolare che è associata eh a G' allora eh devo far vedere che è vera pure per K tutto quello che per G c'è K stati tutto quello che devo dimostrare è che G' e G sono uguali ma G' sono stati in meno poi apri con induzione ok? quindi devo solo dimostrare che G' e G eh riconoscono lo stesso linguaggio ok? va bene? va bene ma  
se G accetta Q' allora deve esistere un ramo di computazione tale che G percorre gli stati diciamo Q star Q1  
e poi Q access ok? cioè prendiamo una una qualsiasi stringa W ok? e supponiamo che eh appunto W sia accettata da G ok? che significa W accetta da G che esiste almeno una sequenza di stati che sarà del tipo Q start poi il rambo in mezzo può accettare ok? sarà sicuramente ok? adesso adesso eh ci sono  
due casi cioè il primo caso è che questa sequenza di stati non contiene Q rip ma se non lo contiene tappo ok? cioè se eh se la sequenza la sequenza non contiene Q rip allora banalmente L di G è uguale a L di G'  
ok? questo cioè questo perché nella nostra procedura di eh aver rimosso Q rip ok? nella nostra procedura di aver rimosso Q rip eh cioè le frecce che c'erano prima tra gli altri stati eh non le abbiamo quelle vecchie diciamo non le abbiamo mai  
cancellate ok? cioè se per esempio Q e QJ stanno nella sequenza no? ma non c'è Q rip eh R4 è rimasta cioè sta infatti come sta nell'unione di R4 cioè l'unione vedete no? in delta per esempio R4 l'ho mantenuta ok? cioè quindi se e questo è vero per ogni possibile stato assumendo che non c'è mai Q rip questa sequenza se non c'è Q rip eh tutto apposta cioè tutte le transizioni Q e QJ sono sempre mantenute come parte di un'unione  
di R4 ok? senso la proporzione converte era quella che che dava in alto tutte le specie regolari mentre adesso sto considerando non converte ma sto guardando soltanto l'automa G' ok? se G' e G riconoscono lo stesso linguaggio allora per induzione convert funziona perché sto assumendo adesso che convert funziona per K-1 stati e G' riconosce lo stesso linguaggio ma c'ha uno stato in meno cioè c'è una K-1 quindi posso applicare l'induzione ok?  
quindi questa è l'idea ok? ok? perché diciamo questo perché diciamo le le nuove espressioni regolari le nuove espressioni regolari contengono le vecchie contengono le vecchie come unioni diciamo  
come parte di un'unione ok? e va bene ok adesso invece se c'è Q rip cioè se per esempio qua in mezzo a questa sequenza c'è Q rip ok? vabbè adesso diciamo nella nuova sequenza  
Q rip non ci sarà più ok? però qualsiasi sia Q rip no? cioè quindi se se invece c'è Q rip c'è Q rip avrò ad esempio ad esempio non lo so Q1 Q rip e poi Q2 ok? però adesso io Q Q1  
Q rip Q2 e Q rip l'ho tolto cioè non c'è più Q1 Q rip Q2 però nel nuovo NFA ci stanno tutti i modi possibili per andare da Q1 a Q2 o direttamente o passando per Q rip quindi non è cambiato niente quindi lì ce l'ho messi cioè tutti i modi che se io prima facevo questo facevo Q1 Q rip Q2 e quindi la situazione era questa no? per esempio allora io ho tutti i modi per andare ma io ho tutti i modi per andare da Q1 a Q2 passando per Q rip e li ho mantenuti  
per definizione per analisi per osservazione di come ho costruito quelle espressioni regolari ok? cioè quindi se c'è Q rip avrò ad esempio e quindi una nuova sequenza sequenza di stati per G' ok?  
ma gli stati adiacenti a Q rip gli stati adiacenti adiacenti a Q rip che sarebbe diciamo Q1 Q2 in G' hanno arco che tiene conto di tutti i modi di tutti i modi  
per andare da Q1 a Q2 direttamente o passando per Q rip ok? quindi non ho perso niente ok? perché cioè se potevo passare da Q1 a Q2 per Q rip prima vabbè pure adesso ci posso passare perché guarda quando ho tolto Q rip  
ho tutti i modi per andare da Q1 a QG passando per Q rip li ho mantenuti R1 R2 star R3 ok? va bene quindi un'altra volta quindi ancora L di G è uguale a L di G' ok? quindi questo finisce la dimostrazione perché adesso abbiamo detto se L di G è uguale a L di G' il linguaggio è lo stesso ma quello c'è uno stato in meno per induzione l'espressione regolare che ti spara alla fine è la stessa  
in G' hanno un arco che tiene conto di tutti i modi per andare da Q1 a Q2 direttamente o passando per Q rip cioè che sarebbe questo ok? cioè se nella mia transizione di stadi che accettava Q' c'era Q1 Q rip QI Q rip QG se c'era ok? adesso la nuova transizione di stadi di G' sarà QI QG ok? e sicuramente  
quando c'è input W passerò da QI a QG perché se ci potevo passare per Q rip adesso ci passo direttamente perché tutti i modi che c'avevo per andare da QI a QG passando per Q rip li ho inclusi nella freccia che sta sopra QI QG e quindi non mi sono perso niente ok? va bene tutto qua va bene cioè questo era un po' diciamo più involved questa dimostrazione però spero che sia chiaro ci sono domande?  
se non ci sono domande vi farei vedere un esempio un esempio un esempio ok? di applicazione di questa ROM ok? cioè in generale come facciamo quindi a trasformare un un un NFA in espressione regolare ok? usando esattamente la tecnica di questa dimostrazione in maniera  
puntuale quello che abbiamo detto nella dimostrazione lo applichiamo a un un NFA particolare diciamo ok? questa NFA per per ragioni chiare diciamo come sarà chiaro sarà semplice perché vedrai che questo si è un algoritmo lo puoi anche diciamo ovviamente lo potresti codificare in un qualsiasi linguaggio di programmazione ma se lo devi fare a mano diciamo il foglio diventa subito un crowded di frecce ok? come vedrete adesso va bene  
facciamo un esempio esempio esempio è trovare espressione regolare associata a la cosa seguente start b 0 1  
2 c 0 ok? ho questo e lo voglio far diventare un'espressione regolare ok? all'inizio è così che faccio? allora prima lo faccio diventare  
generalizzato no? cioè generalizzato quindi questo per esempio lo stato iniziale c'ha gli archi entranti e lo stato finale c'ha gli archi uscenti ok? quindi che faccio? aggiungerò due nuovi stati ok? aggiungerò chiamiamolo in questo lo possiamo chiamare a in questo caso giusto per chiamiamolo a è il mio nuovo stato iniziale poi c'è b  
poi c'è c c non è più il finale e poi c'è d d è il finale ok? questo sarebbe g e n e come faccio? quindi qui c'è l'orex e un arco no? tra b e c ci sta la stessa cosa di prima 2 poi ci sta  
poi ci sta ehm ci sta 0,1 ehm sì un modo diciamo compatto  
cioè adesso invece di 0,1 sarebbe o 0 o 1 ok? cioè con un'espressione regolare questo si indica diciamo con l'unione sarebbe sarebbe l'unione tra il singolo icon 0 e il singolo icon 1 quindi sarebbe questa unione qua che per invece di scrivere parentesi unito parentesi si indica anche così con una freccia così con una freccia dritta sarebbe l'unione però e sarebbe 0 unito 1  
ok? bene e 0 unito 1 poi c'è epsilon giusto? ok e queste sono tutte quelle che adesso così diciamo ho gestito gli stati iniziali adesso ho introdotto lo stato iniziale e e e non c'ha archi entranti c'è solo un arco uscente lo stato finale l'ho introdotto nuovo c'è solo l'arco eh eh eh entrante e non c'ha archi uscenti questo c c'era sempre 0,1 rimane giusto?  
e 2 0 1 questo è tutto quello che c'era prima giusto? ok adesso devo aggiungere qui quindi mette la barretta ah si la metto la metto così sono tutte espressioni regolari ok domande? abbiamo aggiunto a alcuni perchè custate e quattro avevano gli archi non traduiscenti esatto non li dovevano avere esatto ho aggiunto custate e quattro  
avrebbero custate e quattro A e D lo chiamati A e D così è più compatto va bene? prego se invece B e C non avevano gli archi che andavano in loro stessi potrebbero rimanere potrebbero rimanere come beh diciamo sarebbe stato già risultato no non è necessariamente in loro stessi no? cioè poteva essere che B cioè ci poteva essere l'arco CB per esempio quello pure non andava bene però se fosse stato vero che B non c'aveva archi entranti e C non c'aveva  
archi uscenti andava bene non doveva non doveva fare l'unica cosa che potrebbe essere è che ci sono tanti stati finali allora in quel caso lei deve comunque metterne uno solo e fare l'epsilon arco no? perchè vuole un solo stato finale per applicare la procedura però se ci fosse un solo stato finale e questo non c'ha archi uscenti non fa niente lo solo tiene questo va bene? ok ok adesso devo aggiungere tutte le frecce mancanti cioè quelle che abbiamo detto ci deve essere una freccia  
ovvia di codice tranne tra tranne però la versione iniziale e quello finale no? quello iniziale e quello finale non c'hanno archi entranti dobbiamo rispettare queste invarianti che non ci sono gli archi entranti e gli archi uscenti quindi per esempio devo aggiungere sicuramente questa freccia e sarà marcata all'insieme vuoto ok? poi devo aggiungere anche la freccia questa qui che va da A a C giusto?  
che è una freccia uscente va bene e quindi la devo mettere la freccia da C a A non ce la metto perchè sarebbe entrante ok? e da A da B a D sicuramente bello da B a D bellissimo da B a D giusto? da B a D e poi anche da A a D  
non ci sono scordato alcuna? no ma c'è differenza tra insieme vuoto e epsilon nell'archi? sì c'è una differenza importante ok? l'insieme vuoto significa che che la freccia non c'è ok? vuol dire che se c'è un ramo di computazione che sta in quella in quella cosa ok? e  
non c'è quella freccia che non può mai andare da A a D non ci può mai andare questo è l'insieme vuoto ok? cioè l'insieme vuoto vuol dire che una transizione non è definita non è mai possibile ok? questa è la convenzione che abbiamo detto quando disegniamo gli NFA non facciamo tutte le frecce perchè sennò è un casino quando una freccia non c'è rifiuta ok? poi sto dicendo sto aggiungendo le frecce però se non ci può andare mai è vuoto l'insieme quindi non può mai succedere  
l'epsilon arco è un'altra cosa perchè invece l'epsilon arco dice no può succedere appena sta lì va pure nell'altro stato senza leggere niente ok? è diverso la differenza è importante va bene l'utilità è che poi sta potrò rimuovere gli stati  
in maniera universale ok? e intanto ho aggiunto la cosa vuota quando poi considero l'unione un vuoto cioè capito nel senso è semplicemente che mi spermette di farlo in maniera universale senza andare esatto l'ho tipo fatto un algoritmo esatto esatto altrimenti se non lo facessi certo lei ha ragione che ci avevo messo a fare le frecce poi però quando guardo video e dico la freccia non c'è  
ok? cioè invece così faccio una cosa tanto poi quell'insieme vuoto non mi dà fastidio perchè tanto poi lo considererò nell'espressione regolare finale ok? va bene ok quindi l'ho messo adesso rimuovo adesso da qua lo voglio fare qua però rimuovo  
voglio rimuovere B ok? B lo voglio togliere adesso B sarebbe QRIP ok? va bene B sarebbe QRIP cioè quindi vedi adesso ti trovi in questa situazione che è quella che abbiamo analizzato nella prova cioè per esempio prendi diciamo A e C no?  
A e C sarebbero QI e QJ per esempio no? cioè allora quando guardi A e C vedi hai tutti i modi per andare da A a C o direttamente questo è quello vuoto o passando per B per QRIP che infatti fa così poi freccia su se stesso e poi va in C quindi è proprio uguale e questo vale per tutte le coppie di strati ok? questo ci permette di farlo in maniera universale ok? ok quindi devo rimuovere B per rimuovere B che faccio? comincio da qua start  
ci sarà A ovviamente poi B non c'è ci sarà solo C e poi ci sarà il mio D ok? va bene adesso devo considerare devo mettere tutte le frecce ok? cioè devo mettere tutte le frecce quindi devo mettere la freccia per esempio da A a C ok? devo mettere questa freccia  
cioè qua da A a C poi allora ci sarà la freccia da C in se stesso poi ci sarà la freccia da C a D e poi ci sarà la freccia da A a D e basta giusto? perché questo rispetta l'invariante che non ci sono frecce entranti su A non ci sono frecce uscenti da D e ci sono frecce tra tutte le altre coppie di stati che non sono A e D giusto?  
cioè saranno queste le frecce ok? ora devo metterci le etichette però come faccio a mettere le etichette? applico quello che ho fatto nella dimostrazione del teorema cioè prendo ogni coppia di stati quindi A e C no? ok? che ti posso dire su A e C? allora A e C sarebbero Q e QJ ok? che ci devo mettere sopra quella freccia? ci devo mettere tutti i modi per andare da A a C o direttamente o passando per Q e C direttamente è l'insieme vuoto giusto?  
poi sarà unito no? infatti l'insieme vuoto sarebbe R4 era quello che avevamo chiamato R4 perché R4 era quella che andava direttamente da Q e A a QJ infatti vedi R4 è unito ok? poi ci devo mettere QI QRIP poi QRIP in se stesso star e poi R3 no? R1 R2 star R3 ok? vabbè ma è facile basta applicare la cosa ci dovrò mettere e qui ci sarà insieme vuoto unito  
poi ci sta per andare da A a C ci avrò Epsilon giusto? poi ci avrò 0 1 star 0 unito 1 star e poi 2 concatenato cioè qui sarà Epsilon poi avrò 0 1 star R1 R2 star R3 ok? vabbè Epsilon 0 unito 1 star sarebbe l'espressione regolare  
R2 star e R3 sarebbe 2 si? ok? questo e... questo ovviamente lo puoi cominciare cioè l'insieme vuoto unito Epsilon cioè questo praticamente è 0 1 star 2 ok? come espressione regolare è la stessa cosa ah quindi anche Epsilon si è sparito  
si direi di si intanto ci fa 0 1 star si si a parte è vero è equivalente vero ok? adesso C devo fare la stessa cosa con C in se stesso C in se stesso ok? devo considerare tutti i modi di andare da C in se stesso o direttamente 0 1 la prima è 0 1 1 quindi ci sarà  
0 unito 1 ok? si unito quella era direttamente no? e... 0 unito 1 unito e... unito tutti i modi per andare da C in se stesso direttamente o passando per Corrip Corrip sarebbe B quindi posso fare insieme vuoto 0 1 star 2 giusto? vado da C in se stesso passando per per B no? cioè insieme vuoto  
0 1 star 2 vi trovate? quindi sarà unito a quello che ho detto adesso insieme vuoto 0 1 star 2 e... va bene?  
vi trovate? questo dovrebbe essere 0 unito 1 perché l'insieme vuoto lo che è il catena a qualsiasi cosa ottengo insieme vuoto ok? si questo dovrebbe essere si insieme vuoto un catenato a qualsiasi cosa è insieme vuoto quindi questo è praticamente 0 unito 1 ok? poi la stessa cosa adesso lo faccio da C a D no? C a D  
da C a D ci posso andare da C a D da C a D ci posso andare o direttamente Epsilon giusto? da C a D ci posso andare o direttamente che sarebbe Epsilon unito a passando per Corrip cioè faccio insieme vuoto 0 1 star insieme vuoto ok? insieme vuoto  
1 star ok? questa è un'altra stessa cosa di prima è Epsilon ok? qua c'è pure da start a D da start a D un altro quale? per passare da C a D cioè ciclo indietro e  
ritorno su C insieme vuoto insieme vuoto C 2 2 3 no io sto sto eliminando B ok? e voglio vedere come faccio a passare da C a D e devo prendere tutti i modi per andare da C a D o direttamente o passando per Corrip in quel modo che abbiamo considerato però sempre lo stesso nella dimostrazione cioè quindi faccio da C a B poi da B in se stesso e poi da B a D ok?  
lei deve lasciare stare che ci sono altri modi per andarci perché lei applica sempre lo stesso cioè quello è il motivo per cui l'abbiamo messo in forma canonica perché così facciamo sempre la stessa cosa ok? non fa niente che lei lo può fare anche in altri modi perché facendolo così in forma canonica abbiamo visto che facendo sempre lo stesso procedimento otteniamo sempre la stessa cosa ok? può essere che può fare anche la cosa che dice lei però questo non le permette di utilizzare diciamo la procedura che abbiamo dimostrato è sicuramente corretta capito?  
è C perché la concatenazione con il seno in vuoto è vuota non fa niente perché lei concatena il seno in vuoto a qualcosa e questo è il seno in vuoto quando concatena il seno in vuoto a qualcosa è sempre vuoto ok? D era unita in quella sutta l'epsilon è unita  
se concatena l'epsilon è come se se l'epsilon lo concatena lo può ignorare in quel caso lo può ignorare perché c'è 0 1 star e comunque l'epsilon sta lì dentro ok? va bene? da A a D dovrebbe essere così vuoto epsilon 0 1 star vuoto ok vuoto  
ok? cioè da A a D ci volevo andare o direttamente vuoto o passando per corretto epsilon 0 1 star vuoto ho visto? è canonico ok? sto considerando sempre gli stessi modi da A a D ci vado o col vuoto diretto oppure epsilon e sto a B 0 1 star e rimango in B D e sto in vuoto ok? vuoto concatenato in vuoto  
vuoto tutto vuoto qua ok? va bene? cioè che ha senso no? vedi infatti A a D mi è venuto vuoto no? cioè questo c'ha senso no? perché infatti se vedi quello precedente da A a D non ci andavo mai ma manco passando per B perché l'arco da B a D è vuoto ok? questo è il motivo per cui la concatenazione con vuoto è vuoto cioè c'ha senso no? perché non ci potevo mai andare  
per B potevo mai andare su D perché c'è quel vuoto il vuoto vuol dire la freccia non c'è ok? no per C non c'entra niente per C non c'entra niente per C non lo sto io sto dicendo sto considerando i modi per andare direttamente da A a D se lei passa per C ci vuole andare da A a D e questo c'è stato nella freccia sopra non è che l'ho tolto quello ok? però sto dicendo  
rispetto a quel percorso lì che abbiamo considerato in maniera canonica abbiamo eliminato passi quando passano io non ci potevo andare da A a D passando per B non ci posso andare questo è il punto non ci posso andare né direttamente né passando per D questo è consistente col fatto che la freccia A a D è vuota beh è un check diciamo questa cosa certo lei dice ci posso andare con C vabbè certo infatti non ci posso ancora andare tra B e C l'ho tenuto conto quando ho definito la delta tra A e C dopo che è rimasto B ok?  
va bene? cioè ripeto questa dimostrazione questo trema è una ricetta che in maniera cieca ti permette di fare la stessa cosa in un modo che funziona sempre ok? questo ti permette di non sbagliare perché altrimenti rischi di dire ok quando tolgo questo stato posso passare per quell'altro ma poi l'ho già considerato lo devo rimettere o non lo devo mettere ok? questo non succede mai seguendo questi passi perché è canonico ok? sempre uguale e funziona sempre perché l'abbiamo dimostrato una volta per tutti ok?  
va bene? se cominciate a fare delle modifiche da questa cosa qui allora potreste cercare di perdervi qualcosa dovete stare attenti va bene questo è finito così e adesso voglio rimuovere voglio rimuovere voglio rimuovere C devo rimuovere solo C no? rimuovo anche C ok?  
cioè voglio dire che arriva la situazione start A e va bene scusate lo riscrivo prima e poi rimuovo C ok? così lo cioè siamo arrivati a questo punto ok? me lo sto solo copiando  
ok? lo sono copiato eh ho copiato quello che avevo semplificato sopra va bene? questa è la cosa e devo rimuovere C ok? lo rimuovo tutto start A D ok? e poi ho scelto  
finito eh ok? adesso devo considerare ci saranno tutti i modi per andare da A a D ok? cioè o direttamente insieme o vuoto unito tutti i modi per andare da A a D passando per C questo sarebbe 0 1 start 2 unito 0 1 start 2  
non è un unito scusate concatenato 0 1 start 2 concatenato concatenato 0 1 start sì concatenato epsilon sì questo è uguale a questo è uguale a 0 1 start 2 0 1 start ok? qui ho trovato la mia R  
L di R è R è uguale a 0 1 start 2 0 1 start va bene? cioè infatti questa automa andiamo a rivederlo infatti questa automa accetta che cosa? accetta tutte le stringhe  
che hanno mezzo 2 ok? eventualmente 0 ripetizioni di infatti 0 unito 1 start 2 0 unito 1 start giusto no? cioè cioè cioè makes a lot of sense no? cioè questo qui infatti può essere 0 ripetizioni di 0 1 2 in mezzo 0 ripetizioni di 0 1 cioè tutte le stringhe ovviamente che ci hanno 2 in mezzo eh? va bene?  
cioè esattamente questa è la questione regolare qua che abbiamo ottenuto ok? beh spero che questo esempio sia stato chiarificatore domande? prego certo questa è una bella domanda mi sembra che sia sì corretto insieme a 1 start è epsilon sì è corretto  
altra domanda? esatto sì è come se non ci mette niente vicino quindi ok? va bene e  
ok e cominciamo un attimo a parlare dell'ultima cosa che faremo per i linguaggi regolari cominciamo nel discorso un po' qualche una decina di minuti e poi continuiamo la prossima volta ok? cioè l'ultimo argomento di cui che trattiamo nei per i linguaggi regolari è pure diciamo l'argomento che ci permette poi di andare avanti e di motivare diciamo tutto il resto che faremo nel corso che è quello che si chiama il pumping lemma ok? iniziamo diciamo  
adesso il discorso ma poi lo finiamo la prossima volta va bene? ok? cioè la domanda a cui vogliamo rispondere adesso è una domanda veramente importante cioè abbiamo visto adesso che ok ci sono dei linguaggi che sono anche infiniti no? e questi linguaggi sono regolari ovvero esistono dei DFA che li riconoscono e non solo la classe di linguaggi regolari che risponde all'insieme di tutte le espressioni regolari quindi abbiamo visto insomma c'è una grande classe di linguaggi che sono regolari cioè sono riconosciuti dai DFA ma la domanda è tutti i linguaggi sono regolari?  
ok? cioè questa è la grande domanda che vogliamo rispondere adesso è tutti i linguaggi sono regolari? e la risposta è no ok? non è vero che tutto è regolare ci sono linguaggi che non sono regolari ok? e a un certo punto cioè uno infatti ha cominciato a chiedere come si fa a fare cioè quindi dato un linguaggio come faccio a decidere se è regolare o meno?  
ok? ovviamente un modo per definirlo è che faccio vedere c'è un DFA che lo riconosce allora è regolare però se voglio dimostrare che invece non è regolare come faccio? ok? il pumping lemma sarà un modo per rispondere a questa domanda cioè sarà un modo per dire c'è una condizione che mi dice quando un linguaggio se un linguaggio è regolare questa condizione deve essere necessariamente verificata ok? significa che se questa condizione viene a mancare il linguaggio non è regolare non può essere regolare ok?  
faccio un esempio magari ti puoi pensare che un linguaggio non regolare è un linguaggio strano ok? invece no non è strano cioè ad esempio L uguale 0 alla N 1 alla N è l'esempio canonico di linguaggio non regolare non è regolare ok? perché non è regolare diciamo il motivo per cui non è regolare è proprio diciamo la risposta precisa  
questa domanda è quella che appunto premisce il pumping lemma va bene però diciamo anche a livello intuitivo puoi cominciare a pensare se tu provi a fare un DFA in questo linguaggio vedrai che andrai in difficoltà cioè perché perché vai in difficoltà? intuitivamente vai in difficoltà perché cioè un DFA che riconosce questo linguaggio in qualche modo deve contare il numero di 0 ok? siccome il numero di 0 però può essere  
in questo caso arbitrario mentre il numero di stati del DFA è finito ok? e non li può contare tutti se apri con lui cioè non puoi avere un DFA che riconosce questo linguaggio per ogni valore di N no? ok? perché se ci pensi per quanto tu possa contare il numero di stati è finito mentre questo numero di 0 che tu devi contare potrebbe essere infinito ma allora anche con lo star no? con? con lo star dico quando noi facciamo il linguaggio  
regolare si e poi decidiamo appunto il numero arbitrario di quando deve essere lunga questa certo io non sto dicendo che i DFA non possono riconoscere linguaggi infiniti ok? però sto dicendo i DFA non possono contare fino all'infinito perché hanno solo un numero di stati infinito ok? cioè questa è la cosa fondamentale che sto dicendo cioè in qualche modo per riconoscere questo linguaggio tu devi contare gli 0 cioè ci deve essere uno stato che ti dice quando ci hai contato uno 0 e uno quando ne hai contati 2 e uno quando ne hai contati 3 e uno quando ne hai contati 100  
però il tuo DFA ha solo un numero finito di stati e non ne puoi avere un numero infinito sembrerebbe che qua te ne servono un numero infinito perché tu cioè se lo stato iniziale ha più tante e fa 5 e se ha 0 e 1 me lo vuoi impegnare? guarda vuoi dare un DFA che riconosce questo linguaggio? non penso no no però vuoi fare una prova no è giusto è legato cioè lei dice se lo stato solo iniziale che ha più tante e va su stesso testo sia con 0 e 1  
questo qua per esempio questo qui riconosce la stringa 0 appartiene a questo linguaggio si trova? e non è 0 alla n1 anche questo linguaggio perché anche la stringa per esempio è 0 0 1 quindi non sta nel linguaggio  
va bene? cioè il discorso è che ci possiamo provare a fare un DFA che tanto è possibile e quindi non riuscirete mai a fare un DFA che lo riconosce ok? ovviamente diciamo la cosa che vi sto dicendo io adesso perché è impossibile non è che vi ho convinto che è impossibile vi sto dando un'intuizione per cui questa cosa è impossibile ma il motivo vero per cui è impossibile è che si può dimostrare che è impossibile ok? è quello che faremo proprio usando il passi che lei ha va bene?  
il potere del pumping lemma è quello che poi vi permette di dire di dimostrare che ok? vedremo che vedremo la prossima volta che il pumping lemma è un modo per dimostrare  
che un linguaggio non è regolare ok? cioè in altri termini vedremo che ci sono certe condizioni che quando il linguaggio è regolare devono essere sempre verificali ok? e queste condizioni non saranno verificali ad esempio per questo linguaggio ok? che ci permetterà di dire che questo linguaggio non è regolare va bene? faremo questo la prossima volta mi fermerei qua per oggi  
grazie  
grazie  
grazie