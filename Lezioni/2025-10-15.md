# Lezione 07
###### ESERCIZI
#### Grammatiche
Introduciamo un modello di computazione più potente, utile in diverse applicazioni (es. parser per $i$ compilatori). Vedremo che le grammatiche coincidono anche con un diverso tipo si automa.

Ad es. sarà molto facile dare una grammatica che genera le stringhe $0^{n}1^{n}$ con $n\ge0$. Facciamo subito questo come esempio.

Una grammatica è una sequenza di sostituzioni e produzioni:
$$\begin{gathered}\substack{\text{Regole della }\\ \text{grammatica} }\begin{cases} A\longrightarrow0A1& (R_{1}) \\
A \longrightarrow B &(R_{2}) \\
B\longrightarrow \# & (R_{3}) \end{cases} \end{gathered}$$
dove $0,1,\#$ sono **terminali**, mentre $A,B$ sono **variabili**.

La grammatica genera stringhe:
- Scrivo la variabile iniziale
- Sostituisco variabili con altre espressioni seguendo le regole della grammatica
- Ripeto fino a che non ci sono più variabili

Nell'esempio:
$$\begin{gathered} A\stackrel{R_{1}}{\implies}0A1\stackrel{R_{1}}{\implies}00A11 \\ \stackrel{R_{1}}{\implies}000A111\stackrel{R_{2}}{\implies}000B111 \\ \stackrel{R_{3}}{\implies}000\#111\end{gathered}$$
Per ogni tale produzione posso associare un **albero sintattico**:
<span style="background:#affad1">IMMAGINE DELL'ALBERO SINTATTICO</span>

Altra grammatica $G$:
$$\begin{aligned}(R_{1})\quad & E\longrightarrow E+E \\ (R_{1})\quad & E\longrightarrow E*E\\ (R_{1})\quad & E\longrightarrow (E)\\ (R_{1})\quad & E\longrightarrow |0|1|2|...|9 \end{aligned}$$
I terminali sono: $0,1,...9, +,*,(,)$
Variabili: $E$
$G$ genera $(3+4)*4$ ma non genera $(3+4+)*4$
$$\begin{aligned} E &\stackrel{R_{2}}{\implies}E*E \stackrel{R_{3}}{\implies}(E)*E \\ &\stackrel{R_{1}}{\implies}(E+E)*E \stackrel{R_{4}}{\implies} (E+E)*4 \\ &\stackrel{R_{4}}{\implies}(3+E)*4 \stackrel{R_{4}}{\implies} (3+4)*4\end{aligned}$$
<span style="background:#affad1">DISEGNO DELL'ALBERO SINTATTICO 2</span>

###### Definizione - CFG (Context-Free Grammar)
Una grammatica acontestuale (CFG) è una tupla $(V,\Sigma,R,S)$ dove:
- $V$ è l'insieme finito delle variabili
- $\Sigma$ è l'insieme finito dei terminali, ($\underset{\text{finito}}{V\cap\Sigma}=\emptyset$)
- $R$ è l'insieme $V$ di regole
- $S\in V$ è la variabile iniziale.

Se $u,v,w\in\Sigma\cup V$ e $(A\longrightarrow w)\in R$ diremo che $uAv$ produce $uwv$ e lo scriviamo come $uAv\implies uvw$.

Diciamo che $u$ *deriva* $v,u \stackrel{*}{\implies}v$ se:
- $u=v$, oppure
- $\exists u_{1},...u_{k},\quad k\ge 0$ tale che $$u\implies u_{1}\implies u_{2}\implies...\implies u_{k}\implies v.$$
Questo ci permette di definire il linguaggio associato ad una CFG.

Sia $G=(V,\Sigma,R,S)$, allora $L(G)=\{w\in\Sigma^{*}: S\stackrel{*}{\implies} w \}$

Esempio:
<span style="background:#affad1">DISEGNA ESEMPIO</span>

Iniziamo a vedere alcune tecniche per costruire grammatiche:
1. Unione di grammatiche
2. Da DFA alle grammatiche
3. Sfruttare la ricorsione